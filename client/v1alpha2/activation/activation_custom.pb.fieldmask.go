// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/activation_custom.proto
// DO NOT EDIT!!!

package activation_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_service_account_key "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/service_account_key"
	probe "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/probe"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &iam_service_account_key.ServiceAccountKey{}
	_ = &probe.Probe{}
)

type ActivationRequest_FieldMask struct {
	Paths []ActivationRequest_FieldPath
}

func FullActivationRequest_FieldMask() *ActivationRequest_FieldMask {
	res := &ActivationRequest_FieldMask{}
	res.Paths = append(res.Paths, &ActivationRequest_FieldTerminalPath{selector: ActivationRequest_FieldPathSelectorActivate})
	res.Paths = append(res.Paths, &ActivationRequest_FieldTerminalPath{selector: ActivationRequest_FieldPathSelectorConfirmActivation})
	return res
}

func (fieldMask *ActivationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationRequest_FieldPath(raw)
	})
}

func (fieldMask *ActivationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationRequest_FieldMask) Subtract(other *ActivationRequest_FieldMask) *ActivationRequest_FieldMask {
	result := &ActivationRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ActivationRequest_FieldPathSelector]gotenobject.FieldMask{
		ActivationRequest_FieldPathSelectorActivate:          &ActivationRequest_Activate_FieldMask{},
		ActivationRequest_FieldPathSelectorConfirmActivation: &ActivationRequest_ConfirmActivation_FieldMask{},
	}
	mySubMasks := map[ActivationRequest_FieldPathSelector]gotenobject.FieldMask{
		ActivationRequest_FieldPathSelectorActivate:          &ActivationRequest_Activate_FieldMask{},
		ActivationRequest_FieldPathSelectorConfirmActivation: &ActivationRequest_ConfirmActivation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivationRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivationRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivationRequest_FieldPathSelectorActivate:
						mySubMasks[ActivationRequest_FieldPathSelectorActivate] = FullActivationRequest_Activate_FieldMask()
					case ActivationRequest_FieldPathSelectorConfirmActivation:
						mySubMasks[ActivationRequest_FieldPathSelectorConfirmActivation] = FullActivationRequest_ConfirmActivation_FieldMask()
					}
				} else if tp, ok := path.(*ActivationRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivationRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationRequest_FieldMask) FilterInputFields() *ActivationRequest_FieldMask {
	result := &ActivationRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ActivationRequest_FieldPathSelectorActivate:
			if _, ok := path.(*ActivationRequest_FieldTerminalPath); ok {
				for _, subpath := range FullActivationRequest_Activate_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ActivationRequest_FieldSubPath); ok {
				selectedMask := &ActivationRequest_Activate_FieldMask{
					Paths: []ActivationRequestActivate_FieldPath{sub.subPath.(ActivationRequestActivate_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationRequest_FieldSubPath{selector: ActivationRequest_FieldPathSelectorActivate, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_FieldMask) AppendPath(path ActivationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationRequest_FieldPath))
}

func (fieldMask *ActivationRequest_FieldMask) GetPaths() []ActivationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationRequest_FieldMask) Set(target, source *ActivationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationRequest), source.(*ActivationRequest))
}

func (fieldMask *ActivationRequest_FieldMask) Project(source *ActivationRequest) *ActivationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationRequest{}
	activateMask := &ActivationRequest_Activate_FieldMask{}
	wholeActivateAccepted := false
	confirmActivationMask := &ActivationRequest_ConfirmActivation_FieldMask{}
	wholeConfirmActivationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationRequest_FieldTerminalPath:
			switch tp.selector {
			case ActivationRequest_FieldPathSelectorActivate:
				if source, ok := source.Msg.(*ActivationRequest_Activate_); ok {
					result.Msg = &ActivationRequest_Activate_{
						Activate: source.Activate,
					}
				}
				wholeActivateAccepted = true
			case ActivationRequest_FieldPathSelectorConfirmActivation:
				if source, ok := source.Msg.(*ActivationRequest_ConfirmActivation_); ok {
					result.Msg = &ActivationRequest_ConfirmActivation_{
						ConfirmActivation: source.ConfirmActivation,
					}
				}
				wholeConfirmActivationAccepted = true
			}
		case *ActivationRequest_FieldSubPath:
			switch tp.selector {
			case ActivationRequest_FieldPathSelectorActivate:
				activateMask.AppendPath(tp.subPath.(ActivationRequestActivate_FieldPath))
			case ActivationRequest_FieldPathSelectorConfirmActivation:
				confirmActivationMask.AppendPath(tp.subPath.(ActivationRequestConfirmActivation_FieldPath))
			}
		}
	}
	if wholeActivateAccepted == false && len(activateMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ActivationRequest_Activate_); ok {
			result.Msg = (*ActivationRequest_Activate_)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivationRequest_Activate_{}
				oneOfRes.Activate = activateMask.Project(asOneOf.Activate)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeConfirmActivationAccepted == false && len(confirmActivationMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ActivationRequest_ConfirmActivation_); ok {
			result.Msg = (*ActivationRequest_ConfirmActivation_)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivationRequest_ConfirmActivation_{}
				oneOfRes.ConfirmActivation = confirmActivationMask.Project(asOneOf.ConfirmActivation)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ActivationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationRequest))
}

func (fieldMask *ActivationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivationRequest_Activate_FieldMask struct {
	Paths []ActivationRequestActivate_FieldPath
}

func FullActivationRequest_Activate_FieldMask() *ActivationRequest_Activate_FieldMask {
	res := &ActivationRequest_Activate_FieldMask{}
	res.Paths = append(res.Paths, &ActivationRequestActivate_FieldTerminalPath{selector: ActivationRequestActivate_FieldPathSelectorToken})
	res.Paths = append(res.Paths, &ActivationRequestActivate_FieldTerminalPath{selector: ActivationRequestActivate_FieldPathSelectorClientCookie})
	res.Paths = append(res.Paths, &ActivationRequestActivate_FieldTerminalPath{selector: ActivationRequestActivate_FieldPathSelectorProbe})
	res.Paths = append(res.Paths, &ActivationRequestActivate_FieldTerminalPath{selector: ActivationRequestActivate_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &ActivationRequestActivate_FieldTerminalPath{selector: ActivationRequestActivate_FieldPathSelectorPublicKeyData})
	return res
}

func (fieldMask *ActivationRequest_Activate_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationRequest_Activate_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationRequest_Activate_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationRequestActivate_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationRequest_Activate_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationRequestActivate_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationRequest_Activate_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationRequestActivate_FieldPath(raw)
	})
}

func (fieldMask *ActivationRequest_Activate_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationRequest_Activate_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationRequest_Activate_FieldMask) Subtract(other *ActivationRequest_Activate_FieldMask) *ActivationRequest_Activate_FieldMask {
	result := &ActivationRequest_Activate_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ActivationRequestActivate_FieldPathSelector]gotenobject.FieldMask{
		ActivationRequestActivate_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[ActivationRequestActivate_FieldPathSelector]gotenobject.FieldMask{
		ActivationRequestActivate_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationRequestActivate_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivationRequestActivate_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivationRequestActivate_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivationRequestActivate_FieldPathSelectorProbe:
						mySubMasks[ActivationRequestActivate_FieldPathSelectorProbe] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*ActivationRequestActivate_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivationRequestActivate_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationRequest_Activate_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationRequest_Activate_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationRequest_Activate_FieldMask) FilterInputFields() *ActivationRequest_Activate_FieldMask {
	result := &ActivationRequest_Activate_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ActivationRequestActivate_FieldPathSelectorProbe:
			if _, ok := path.(*ActivationRequestActivate_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationRequestActivate_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ActivationRequestActivate_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationRequestActivate_FieldSubPath{selector: ActivationRequestActivate_FieldPathSelectorProbe, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationRequest_Activate_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationRequest_Activate_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationRequestActivate_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationRequestActivate_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationRequest_Activate_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationRequest_Activate_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_Activate_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationRequest_Activate_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationRequest_Activate_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_Activate_FieldMask) AppendPath(path ActivationRequestActivate_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationRequest_Activate_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationRequestActivate_FieldPath))
}

func (fieldMask *ActivationRequest_Activate_FieldMask) GetPaths() []ActivationRequestActivate_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationRequest_Activate_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationRequest_Activate_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationRequestActivate_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationRequest_Activate_FieldMask) Set(target, source *ActivationRequest_Activate) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationRequest_Activate_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationRequest_Activate), source.(*ActivationRequest_Activate))
}

func (fieldMask *ActivationRequest_Activate_FieldMask) Project(source *ActivationRequest_Activate) *ActivationRequest_Activate {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationRequest_Activate{}
	probeMask := &probe.Probe_FieldMask{}
	wholeProbeAccepted := false
	var metadataMapKeys []string
	wholeMetadataAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationRequestActivate_FieldTerminalPath:
			switch tp.selector {
			case ActivationRequestActivate_FieldPathSelectorToken:
				result.Token = source.Token
			case ActivationRequestActivate_FieldPathSelectorClientCookie:
				result.ClientCookie = source.ClientCookie
			case ActivationRequestActivate_FieldPathSelectorProbe:
				result.Probe = source.Probe
				wholeProbeAccepted = true
			case ActivationRequestActivate_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case ActivationRequestActivate_FieldPathSelectorPublicKeyData:
				result.PublicKeyData = source.PublicKeyData
			}
		case *ActivationRequestActivate_FieldSubPath:
			switch tp.selector {
			case ActivationRequestActivate_FieldPathSelectorProbe:
				probeMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		case *ActivationRequestActivate_FieldPathMap:
			switch tp.selector {
			case ActivationRequestActivate_FieldPathSelectorMetadata:
				metadataMapKeys = append(metadataMapKeys, tp.key)
			}
		}
	}
	if wholeProbeAccepted == false && len(probeMask.Paths) > 0 {
		result.Probe = probeMask.Project(source.GetProbe())
	}
	if wholeMetadataAccepted == false && len(metadataMapKeys) > 0 && source.GetMetadata() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetMetadata()
		for _, key := range metadataMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Metadata = copiedMap
	}
	return result
}

func (fieldMask *ActivationRequest_Activate_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationRequest_Activate))
}

func (fieldMask *ActivationRequest_Activate_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivationRequest_ConfirmActivation_FieldMask struct {
	Paths []ActivationRequestConfirmActivation_FieldPath
}

func FullActivationRequest_ConfirmActivation_FieldMask() *ActivationRequest_ConfirmActivation_FieldMask {
	res := &ActivationRequest_ConfirmActivation_FieldMask{}
	res.Paths = append(res.Paths, &ActivationRequestConfirmActivation_FieldTerminalPath{selector: ActivationRequestConfirmActivation_FieldPathSelectorClientCookie})
	return res
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationRequestConfirmActivation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationRequestConfirmActivation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationRequestConfirmActivation_FieldPath(raw)
	})
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Subtract(other *ActivationRequest_ConfirmActivation_FieldMask) *ActivationRequest_ConfirmActivation_FieldMask {
	result := &ActivationRequest_ConfirmActivation_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationRequestConfirmActivation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationRequest_ConfirmActivation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) FilterInputFields() *ActivationRequest_ConfirmActivation_FieldMask {
	result := &ActivationRequest_ConfirmActivation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationRequestConfirmActivation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationRequestConfirmActivation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationRequest_ConfirmActivation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationRequest_ConfirmActivation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) AppendPath(path ActivationRequestConfirmActivation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationRequestConfirmActivation_FieldPath))
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) GetPaths() []ActivationRequestConfirmActivation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationRequestConfirmActivation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Set(target, source *ActivationRequest_ConfirmActivation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationRequest_ConfirmActivation), source.(*ActivationRequest_ConfirmActivation))
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) Project(source *ActivationRequest_ConfirmActivation) *ActivationRequest_ConfirmActivation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationRequest_ConfirmActivation{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationRequestConfirmActivation_FieldTerminalPath:
			switch tp.selector {
			case ActivationRequestConfirmActivation_FieldPathSelectorClientCookie:
				result.ClientCookie = source.ClientCookie
			}
		}
	}
	return result
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationRequest_ConfirmActivation))
}

func (fieldMask *ActivationRequest_ConfirmActivation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivationResponse_FieldMask struct {
	Paths []ActivationResponse_FieldPath
}

func FullActivationResponse_FieldMask() *ActivationResponse_FieldMask {
	res := &ActivationResponse_FieldMask{}
	res.Paths = append(res.Paths, &ActivationResponse_FieldTerminalPath{selector: ActivationResponse_FieldPathSelectorActivated})
	res.Paths = append(res.Paths, &ActivationResponse_FieldTerminalPath{selector: ActivationResponse_FieldPathSelectorConfirmActivationAck})
	return res
}

func (fieldMask *ActivationResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationResponse_FieldPath(raw)
	})
}

func (fieldMask *ActivationResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationResponse_FieldMask) Subtract(other *ActivationResponse_FieldMask) *ActivationResponse_FieldMask {
	result := &ActivationResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ActivationResponse_FieldPathSelector]gotenobject.FieldMask{
		ActivationResponse_FieldPathSelectorActivated:            &ActivationResponse_Activated_FieldMask{},
		ActivationResponse_FieldPathSelectorConfirmActivationAck: &ActivationResponse_ConfirmActivationAck_FieldMask{},
	}
	mySubMasks := map[ActivationResponse_FieldPathSelector]gotenobject.FieldMask{
		ActivationResponse_FieldPathSelectorActivated:            &ActivationResponse_Activated_FieldMask{},
		ActivationResponse_FieldPathSelectorConfirmActivationAck: &ActivationResponse_ConfirmActivationAck_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivationResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivationResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivationResponse_FieldPathSelectorActivated:
						mySubMasks[ActivationResponse_FieldPathSelectorActivated] = FullActivationResponse_Activated_FieldMask()
					case ActivationResponse_FieldPathSelectorConfirmActivationAck:
						mySubMasks[ActivationResponse_FieldPathSelectorConfirmActivationAck] = FullActivationResponse_ConfirmActivationAck_FieldMask()
					}
				} else if tp, ok := path.(*ActivationResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivationResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationResponse_FieldMask) FilterInputFields() *ActivationResponse_FieldMask {
	result := &ActivationResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ActivationResponse_FieldPathSelectorActivated:
			if _, ok := path.(*ActivationResponse_FieldTerminalPath); ok {
				for _, subpath := range FullActivationResponse_Activated_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ActivationResponse_FieldSubPath); ok {
				selectedMask := &ActivationResponse_Activated_FieldMask{
					Paths: []ActivationResponseActivated_FieldPath{sub.subPath.(ActivationResponseActivated_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponse_FieldSubPath{selector: ActivationResponse_FieldPathSelectorActivated, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_FieldMask) AppendPath(path ActivationResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationResponse_FieldPath))
}

func (fieldMask *ActivationResponse_FieldMask) GetPaths() []ActivationResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationResponse_FieldMask) Set(target, source *ActivationResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationResponse), source.(*ActivationResponse))
}

func (fieldMask *ActivationResponse_FieldMask) Project(source *ActivationResponse) *ActivationResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationResponse{}
	activatedMask := &ActivationResponse_Activated_FieldMask{}
	wholeActivatedAccepted := false
	confirmActivationAckMask := &ActivationResponse_ConfirmActivationAck_FieldMask{}
	wholeConfirmActivationAckAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationResponse_FieldTerminalPath:
			switch tp.selector {
			case ActivationResponse_FieldPathSelectorActivated:
				if source, ok := source.Msg.(*ActivationResponse_Activated_); ok {
					result.Msg = &ActivationResponse_Activated_{
						Activated: source.Activated,
					}
				}
				wholeActivatedAccepted = true
			case ActivationResponse_FieldPathSelectorConfirmActivationAck:
				if source, ok := source.Msg.(*ActivationResponse_ConfirmActivationAck_); ok {
					result.Msg = &ActivationResponse_ConfirmActivationAck_{
						ConfirmActivationAck: source.ConfirmActivationAck,
					}
				}
				wholeConfirmActivationAckAccepted = true
			}
		case *ActivationResponse_FieldSubPath:
			switch tp.selector {
			case ActivationResponse_FieldPathSelectorActivated:
				activatedMask.AppendPath(tp.subPath.(ActivationResponseActivated_FieldPath))
			case ActivationResponse_FieldPathSelectorConfirmActivationAck:
				confirmActivationAckMask.AppendPath(tp.subPath.(ActivationResponseConfirmActivationAck_FieldPath))
			}
		}
	}
	if wholeActivatedAccepted == false && len(activatedMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ActivationResponse_Activated_); ok {
			result.Msg = (*ActivationResponse_Activated_)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivationResponse_Activated_{}
				oneOfRes.Activated = activatedMask.Project(asOneOf.Activated)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeConfirmActivationAckAccepted == false && len(confirmActivationAckMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ActivationResponse_ConfirmActivationAck_); ok {
			result.Msg = (*ActivationResponse_ConfirmActivationAck_)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivationResponse_ConfirmActivationAck_{}
				oneOfRes.ConfirmActivationAck = confirmActivationAckMask.Project(asOneOf.ConfirmActivationAck)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ActivationResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationResponse))
}

func (fieldMask *ActivationResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivationResponse_Activated_FieldMask struct {
	Paths []ActivationResponseActivated_FieldPath
}

func FullActivationResponse_Activated_FieldMask() *ActivationResponse_Activated_FieldMask {
	res := &ActivationResponse_Activated_FieldMask{}
	res.Paths = append(res.Paths, &ActivationResponseActivated_FieldTerminalPath{selector: ActivationResponseActivated_FieldPathSelectorProbe})
	res.Paths = append(res.Paths, &ActivationResponseActivated_FieldTerminalPath{selector: ActivationResponseActivated_FieldPathSelectorServiceAccountKey})
	return res
}

func (fieldMask *ActivationResponse_Activated_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationResponse_Activated_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationResponse_Activated_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationResponseActivated_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationResponse_Activated_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationResponseActivated_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationResponse_Activated_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationResponseActivated_FieldPath(raw)
	})
}

func (fieldMask *ActivationResponse_Activated_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationResponse_Activated_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationResponse_Activated_FieldMask) Subtract(other *ActivationResponse_Activated_FieldMask) *ActivationResponse_Activated_FieldMask {
	result := &ActivationResponse_Activated_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ActivationResponseActivated_FieldPathSelector]gotenobject.FieldMask{
		ActivationResponseActivated_FieldPathSelectorProbe:             &probe.Probe_FieldMask{},
		ActivationResponseActivated_FieldPathSelectorServiceAccountKey: &iam_service_account_key.ServiceAccountKey_FieldMask{},
	}
	mySubMasks := map[ActivationResponseActivated_FieldPathSelector]gotenobject.FieldMask{
		ActivationResponseActivated_FieldPathSelectorProbe:             &probe.Probe_FieldMask{},
		ActivationResponseActivated_FieldPathSelectorServiceAccountKey: &iam_service_account_key.ServiceAccountKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationResponseActivated_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivationResponseActivated_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivationResponseActivated_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivationResponseActivated_FieldPathSelectorProbe:
						mySubMasks[ActivationResponseActivated_FieldPathSelectorProbe] = probe.FullProbe_FieldMask()
					case ActivationResponseActivated_FieldPathSelectorServiceAccountKey:
						mySubMasks[ActivationResponseActivated_FieldPathSelectorServiceAccountKey] = iam_service_account_key.FullServiceAccountKey_FieldMask()
					}
				} else if tp, ok := path.(*ActivationResponseActivated_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivationResponseActivated_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationResponse_Activated_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationResponse_Activated_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationResponse_Activated_FieldMask) FilterInputFields() *ActivationResponse_Activated_FieldMask {
	result := &ActivationResponse_Activated_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ActivationResponseActivated_FieldPathSelectorProbe:
			if _, ok := path.(*ActivationResponseActivated_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponseActivated_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ActivationResponseActivated_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponseActivated_FieldSubPath{selector: ActivationResponseActivated_FieldPathSelectorProbe, subPath: allowedPath})
				}
			}
		case ActivationResponseActivated_FieldPathSelectorServiceAccountKey:
			if _, ok := path.(*ActivationResponseActivated_FieldTerminalPath); ok {
				for _, subpath := range iam_service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponseActivated_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ActivationResponseActivated_FieldSubPath); ok {
				selectedMask := &iam_service_account_key.ServiceAccountKey_FieldMask{
					Paths: []iam_service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(iam_service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ActivationResponseActivated_FieldSubPath{selector: ActivationResponseActivated_FieldPathSelectorServiceAccountKey, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationResponse_Activated_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationResponse_Activated_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationResponseActivated_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationResponseActivated_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationResponse_Activated_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationResponse_Activated_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_Activated_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationResponse_Activated_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationResponse_Activated_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_Activated_FieldMask) AppendPath(path ActivationResponseActivated_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationResponse_Activated_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationResponseActivated_FieldPath))
}

func (fieldMask *ActivationResponse_Activated_FieldMask) GetPaths() []ActivationResponseActivated_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationResponse_Activated_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationResponse_Activated_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationResponseActivated_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationResponse_Activated_FieldMask) Set(target, source *ActivationResponse_Activated) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationResponse_Activated_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationResponse_Activated), source.(*ActivationResponse_Activated))
}

func (fieldMask *ActivationResponse_Activated_FieldMask) Project(source *ActivationResponse_Activated) *ActivationResponse_Activated {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationResponse_Activated{}
	probeMask := &probe.Probe_FieldMask{}
	wholeProbeAccepted := false
	serviceAccountKeyMask := &iam_service_account_key.ServiceAccountKey_FieldMask{}
	wholeServiceAccountKeyAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationResponseActivated_FieldTerminalPath:
			switch tp.selector {
			case ActivationResponseActivated_FieldPathSelectorProbe:
				result.Probe = source.Probe
				wholeProbeAccepted = true
			case ActivationResponseActivated_FieldPathSelectorServiceAccountKey:
				result.ServiceAccountKey = source.ServiceAccountKey
				wholeServiceAccountKeyAccepted = true
			}
		case *ActivationResponseActivated_FieldSubPath:
			switch tp.selector {
			case ActivationResponseActivated_FieldPathSelectorProbe:
				probeMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			case ActivationResponseActivated_FieldPathSelectorServiceAccountKey:
				serviceAccountKeyMask.AppendPath(tp.subPath.(iam_service_account_key.ServiceAccountKey_FieldPath))
			}
		}
	}
	if wholeProbeAccepted == false && len(probeMask.Paths) > 0 {
		result.Probe = probeMask.Project(source.GetProbe())
	}
	if wholeServiceAccountKeyAccepted == false && len(serviceAccountKeyMask.Paths) > 0 {
		result.ServiceAccountKey = serviceAccountKeyMask.Project(source.GetServiceAccountKey())
	}
	return result
}

func (fieldMask *ActivationResponse_Activated_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationResponse_Activated))
}

func (fieldMask *ActivationResponse_Activated_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivationResponse_ConfirmActivationAck_FieldMask struct {
	Paths []ActivationResponseConfirmActivationAck_FieldPath
}

func FullActivationResponse_ConfirmActivationAck_FieldMask() *ActivationResponse_ConfirmActivationAck_FieldMask {
	res := &ActivationResponse_ConfirmActivationAck_FieldMask{}
	return res
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivationResponseConfirmActivationAck_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivationResponseConfirmActivationAck_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivationResponseConfirmActivationAck_FieldPath(raw)
	})
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) ProtoMessage() {}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Subtract(other *ActivationResponse_ConfirmActivationAck_FieldMask) *ActivationResponse_ConfirmActivationAck_FieldMask {
	result := &ActivationResponse_ConfirmActivationAck_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivationResponseConfirmActivationAck_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivationResponse_ConfirmActivationAck_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) FilterInputFields() *ActivationResponse_ConfirmActivationAck_FieldMask {
	result := &ActivationResponse_ConfirmActivationAck_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivationResponseConfirmActivationAck_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivationResponseConfirmActivationAck_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivationResponse_ConfirmActivationAck_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivationResponse_ConfirmActivationAck_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) AppendPath(path ActivationResponseConfirmActivationAck_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivationResponseConfirmActivationAck_FieldPath))
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) GetPaths() []ActivationResponseConfirmActivationAck_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivationResponseConfirmActivationAck_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Set(target, source *ActivationResponse_ConfirmActivationAck) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivationResponse_ConfirmActivationAck), source.(*ActivationResponse_ConfirmActivationAck))
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) Project(source *ActivationResponse_ConfirmActivationAck) *ActivationResponse_ConfirmActivationAck {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivationResponse_ConfirmActivationAck{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivationResponseConfirmActivationAck_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivationResponse_ConfirmActivationAck))
}

func (fieldMask *ActivationResponse_ConfirmActivationAck_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SendActivationInvitationRequest_FieldMask struct {
	Paths []SendActivationInvitationRequest_FieldPath
}

func FullSendActivationInvitationRequest_FieldMask() *SendActivationInvitationRequest_FieldMask {
	res := &SendActivationInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &SendActivationInvitationRequest_FieldTerminalPath{selector: SendActivationInvitationRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SendActivationInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSendActivationInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SendActivationInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSendActivationInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Subtract(other *SendActivationInvitationRequest_FieldMask) *SendActivationInvitationRequest_FieldMask {
	result := &SendActivationInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SendActivationInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SendActivationInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SendActivationInvitationRequest_FieldMask) FilterInputFields() *SendActivationInvitationRequest_FieldMask {
	result := &SendActivationInvitationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SendActivationInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SendActivationInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSendActivationInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SendActivationInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SendActivationInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) AppendPath(path SendActivationInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SendActivationInvitationRequest_FieldPath))
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) GetPaths() []SendActivationInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSendActivationInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Set(target, source *SendActivationInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SendActivationInvitationRequest), source.(*SendActivationInvitationRequest))
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) Project(source *SendActivationInvitationRequest) *SendActivationInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SendActivationInvitationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SendActivationInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case SendActivationInvitationRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SendActivationInvitationRequest))
}

func (fieldMask *SendActivationInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ResetActivationRequest_FieldMask struct {
	Paths []ResetActivationRequest_FieldPath
}

func FullResetActivationRequest_FieldMask() *ResetActivationRequest_FieldMask {
	res := &ResetActivationRequest_FieldMask{}
	res.Paths = append(res.Paths, &ResetActivationRequest_FieldTerminalPath{selector: ResetActivationRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *ResetActivationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ResetActivationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ResetActivationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseResetActivationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ResetActivationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ResetActivationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ResetActivationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseResetActivationRequest_FieldPath(raw)
	})
}

func (fieldMask *ResetActivationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ResetActivationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ResetActivationRequest_FieldMask) Subtract(other *ResetActivationRequest_FieldMask) *ResetActivationRequest_FieldMask {
	result := &ResetActivationRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ResetActivationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ResetActivationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ResetActivationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ResetActivationRequest_FieldMask) FilterInputFields() *ResetActivationRequest_FieldMask {
	result := &ResetActivationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ResetActivationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ResetActivationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ResetActivationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseResetActivationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ResetActivationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ResetActivationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ResetActivationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ResetActivationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ResetActivationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ResetActivationRequest_FieldMask) AppendPath(path ResetActivationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ResetActivationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ResetActivationRequest_FieldPath))
}

func (fieldMask *ResetActivationRequest_FieldMask) GetPaths() []ResetActivationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ResetActivationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ResetActivationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseResetActivationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ResetActivationRequest_FieldMask) Set(target, source *ResetActivationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ResetActivationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ResetActivationRequest), source.(*ResetActivationRequest))
}

func (fieldMask *ResetActivationRequest_FieldMask) Project(source *ResetActivationRequest) *ResetActivationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ResetActivationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ResetActivationRequest_FieldTerminalPath:
			switch tp.selector {
			case ResetActivationRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *ResetActivationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ResetActivationRequest))
}

func (fieldMask *ResetActivationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
