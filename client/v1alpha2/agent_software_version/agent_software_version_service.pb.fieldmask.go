// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/agent_software_version_service.proto
// DO NOT EDIT!!!

package agent_software_version_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	agent_software_version "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/agent_software_version"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &agent_software_version.AgentSoftwareVersion{}
)

type GetAgentSoftwareVersionRequest_FieldMask struct {
	Paths []GetAgentSoftwareVersionRequest_FieldPath
}

func FullGetAgentSoftwareVersionRequest_FieldMask() *GetAgentSoftwareVersionRequest_FieldMask {
	res := &GetAgentSoftwareVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetAgentSoftwareVersionRequest_FieldTerminalPath{selector: GetAgentSoftwareVersionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetAgentSoftwareVersionRequest_FieldTerminalPath{selector: GetAgentSoftwareVersionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetAgentSoftwareVersionRequest_FieldTerminalPath{selector: GetAgentSoftwareVersionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetAgentSoftwareVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetAgentSoftwareVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetAgentSoftwareVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Subtract(other *GetAgentSoftwareVersionRequest_FieldMask) *GetAgentSoftwareVersionRequest_FieldMask {
	result := &GetAgentSoftwareVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetAgentSoftwareVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetAgentSoftwareVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) FilterInputFields() *GetAgentSoftwareVersionRequest_FieldMask {
	result := &GetAgentSoftwareVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetAgentSoftwareVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetAgentSoftwareVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetAgentSoftwareVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetAgentSoftwareVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) AppendPath(path GetAgentSoftwareVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetAgentSoftwareVersionRequest_FieldPath))
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) GetPaths() []GetAgentSoftwareVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetAgentSoftwareVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Set(target, source *GetAgentSoftwareVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetAgentSoftwareVersionRequest), source.(*GetAgentSoftwareVersionRequest))
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) Project(source *GetAgentSoftwareVersionRequest) *GetAgentSoftwareVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetAgentSoftwareVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetAgentSoftwareVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case GetAgentSoftwareVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetAgentSoftwareVersionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetAgentSoftwareVersionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetAgentSoftwareVersionRequest))
}

func (fieldMask *GetAgentSoftwareVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetAgentSoftwareVersionsRequest_FieldMask struct {
	Paths []BatchGetAgentSoftwareVersionsRequest_FieldPath
}

func FullBatchGetAgentSoftwareVersionsRequest_FieldMask() *BatchGetAgentSoftwareVersionsRequest_FieldMask {
	res := &BatchGetAgentSoftwareVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath{selector: BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath{selector: BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath{selector: BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetAgentSoftwareVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetAgentSoftwareVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Subtract(other *BatchGetAgentSoftwareVersionsRequest_FieldMask) *BatchGetAgentSoftwareVersionsRequest_FieldMask {
	result := &BatchGetAgentSoftwareVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetAgentSoftwareVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) FilterInputFields() *BatchGetAgentSoftwareVersionsRequest_FieldMask {
	result := &BatchGetAgentSoftwareVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetAgentSoftwareVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetAgentSoftwareVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetAgentSoftwareVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetAgentSoftwareVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) AppendPath(path BatchGetAgentSoftwareVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetAgentSoftwareVersionsRequest_FieldPath))
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) GetPaths() []BatchGetAgentSoftwareVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetAgentSoftwareVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Set(target, source *BatchGetAgentSoftwareVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetAgentSoftwareVersionsRequest), source.(*BatchGetAgentSoftwareVersionsRequest))
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) Project(source *BatchGetAgentSoftwareVersionsRequest) *BatchGetAgentSoftwareVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetAgentSoftwareVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetAgentSoftwareVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetAgentSoftwareVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetAgentSoftwareVersionsRequest))
}

func (fieldMask *BatchGetAgentSoftwareVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetAgentSoftwareVersionsResponse_FieldMask struct {
	Paths []BatchGetAgentSoftwareVersionsResponse_FieldPath
}

func FullBatchGetAgentSoftwareVersionsResponse_FieldMask() *BatchGetAgentSoftwareVersionsResponse_FieldMask {
	res := &BatchGetAgentSoftwareVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath{selector: BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions})
	res.Paths = append(res.Paths, &BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath{selector: BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetAgentSoftwareVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetAgentSoftwareVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Subtract(other *BatchGetAgentSoftwareVersionsResponse_FieldMask) *BatchGetAgentSoftwareVersionsResponse_FieldMask {
	result := &BatchGetAgentSoftwareVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}
	mySubMasks := map[BatchGetAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetAgentSoftwareVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
						mySubMasks[BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions] = agent_software_version.FullAgentSoftwareVersion_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetAgentSoftwareVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetAgentSoftwareVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetAgentSoftwareVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) FilterInputFields() *BatchGetAgentSoftwareVersionsResponse_FieldMask {
	result := &BatchGetAgentSoftwareVersionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
			if _, ok := path.(*BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
				for _, subpath := range agent_software_version.FullAgentSoftwareVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetAgentSoftwareVersionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetAgentSoftwareVersionsResponse_FieldSubPath); ok {
				selectedMask := &agent_software_version.AgentSoftwareVersion_FieldMask{
					Paths: []agent_software_version.AgentSoftwareVersion_FieldPath{sub.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetAgentSoftwareVersionsResponse_FieldSubPath{selector: BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetAgentSoftwareVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetAgentSoftwareVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetAgentSoftwareVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetAgentSoftwareVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) AppendPath(path BatchGetAgentSoftwareVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetAgentSoftwareVersionsResponse_FieldPath))
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) GetPaths() []BatchGetAgentSoftwareVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetAgentSoftwareVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Set(target, source *BatchGetAgentSoftwareVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetAgentSoftwareVersionsResponse), source.(*BatchGetAgentSoftwareVersionsResponse))
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) Project(source *BatchGetAgentSoftwareVersionsResponse) *BatchGetAgentSoftwareVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetAgentSoftwareVersionsResponse{}
	agentSoftwareVersionsMask := &agent_software_version.AgentSoftwareVersion_FieldMask{}
	wholeAgentSoftwareVersionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetAgentSoftwareVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
				result.AgentSoftwareVersions = source.AgentSoftwareVersions
				wholeAgentSoftwareVersionsAccepted = true
			case BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetAgentSoftwareVersionsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
				agentSoftwareVersionsMask.AppendPath(tp.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath))
			}
		}
	}
	if wholeAgentSoftwareVersionsAccepted == false && len(agentSoftwareVersionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAgentSoftwareVersions() {
			result.AgentSoftwareVersions = append(result.AgentSoftwareVersions, agentSoftwareVersionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetAgentSoftwareVersionsResponse))
}

func (fieldMask *BatchGetAgentSoftwareVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListAgentSoftwareVersionsRequest_FieldMask struct {
	Paths []ListAgentSoftwareVersionsRequest_FieldPath
}

func FullListAgentSoftwareVersionsRequest_FieldMask() *ListAgentSoftwareVersionsRequest_FieldMask {
	res := &ListAgentSoftwareVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsRequest_FieldTerminalPath{selector: ListAgentSoftwareVersionsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListAgentSoftwareVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListAgentSoftwareVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListAgentSoftwareVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Subtract(other *ListAgentSoftwareVersionsRequest_FieldMask) *ListAgentSoftwareVersionsRequest_FieldMask {
	result := &ListAgentSoftwareVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListAgentSoftwareVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListAgentSoftwareVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) FilterInputFields() *ListAgentSoftwareVersionsRequest_FieldMask {
	result := &ListAgentSoftwareVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListAgentSoftwareVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListAgentSoftwareVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListAgentSoftwareVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListAgentSoftwareVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) AppendPath(path ListAgentSoftwareVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListAgentSoftwareVersionsRequest_FieldPath))
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) GetPaths() []ListAgentSoftwareVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListAgentSoftwareVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Set(target, source *ListAgentSoftwareVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListAgentSoftwareVersionsRequest), source.(*ListAgentSoftwareVersionsRequest))
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) Project(source *ListAgentSoftwareVersionsRequest) *ListAgentSoftwareVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListAgentSoftwareVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListAgentSoftwareVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListAgentSoftwareVersionsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListAgentSoftwareVersionsRequest))
}

func (fieldMask *ListAgentSoftwareVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListAgentSoftwareVersionsResponse_FieldMask struct {
	Paths []ListAgentSoftwareVersionsResponse_FieldPath
}

func FullListAgentSoftwareVersionsResponse_FieldMask() *ListAgentSoftwareVersionsResponse_FieldMask {
	res := &ListAgentSoftwareVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsResponse_FieldTerminalPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsResponse_FieldTerminalPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsResponse_FieldTerminalPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsResponse_FieldTerminalPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListAgentSoftwareVersionsResponse_FieldTerminalPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListAgentSoftwareVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListAgentSoftwareVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Subtract(other *ListAgentSoftwareVersionsResponse_FieldMask) *ListAgentSoftwareVersionsResponse_FieldMask {
	result := &ListAgentSoftwareVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}
	mySubMasks := map[ListAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListAgentSoftwareVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListAgentSoftwareVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
						mySubMasks[ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions] = agent_software_version.FullAgentSoftwareVersion_FieldMask()
					}
				} else if tp, ok := path.(*ListAgentSoftwareVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListAgentSoftwareVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListAgentSoftwareVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) FilterInputFields() *ListAgentSoftwareVersionsResponse_FieldMask {
	result := &ListAgentSoftwareVersionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
			if _, ok := path.(*ListAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
				for _, subpath := range agent_software_version.FullAgentSoftwareVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListAgentSoftwareVersionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListAgentSoftwareVersionsResponse_FieldSubPath); ok {
				selectedMask := &agent_software_version.AgentSoftwareVersion_FieldMask{
					Paths: []agent_software_version.AgentSoftwareVersion_FieldPath{sub.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListAgentSoftwareVersionsResponse_FieldSubPath{selector: ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListAgentSoftwareVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListAgentSoftwareVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListAgentSoftwareVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListAgentSoftwareVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) AppendPath(path ListAgentSoftwareVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListAgentSoftwareVersionsResponse_FieldPath))
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) GetPaths() []ListAgentSoftwareVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListAgentSoftwareVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Set(target, source *ListAgentSoftwareVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListAgentSoftwareVersionsResponse), source.(*ListAgentSoftwareVersionsResponse))
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) Project(source *ListAgentSoftwareVersionsResponse) *ListAgentSoftwareVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListAgentSoftwareVersionsResponse{}
	agentSoftwareVersionsMask := &agent_software_version.AgentSoftwareVersion_FieldMask{}
	wholeAgentSoftwareVersionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListAgentSoftwareVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
				result.AgentSoftwareVersions = source.AgentSoftwareVersions
				wholeAgentSoftwareVersionsAccepted = true
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListAgentSoftwareVersionsResponse_FieldSubPath:
			switch tp.selector {
			case ListAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersions:
				agentSoftwareVersionsMask.AppendPath(tp.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath))
			}
		}
	}
	if wholeAgentSoftwareVersionsAccepted == false && len(agentSoftwareVersionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAgentSoftwareVersions() {
			result.AgentSoftwareVersions = append(result.AgentSoftwareVersions, agentSoftwareVersionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListAgentSoftwareVersionsResponse))
}

func (fieldMask *ListAgentSoftwareVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAgentSoftwareVersionRequest_FieldMask struct {
	Paths []WatchAgentSoftwareVersionRequest_FieldPath
}

func FullWatchAgentSoftwareVersionRequest_FieldMask() *WatchAgentSoftwareVersionRequest_FieldMask {
	res := &WatchAgentSoftwareVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAgentSoftwareVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAgentSoftwareVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAgentSoftwareVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Subtract(other *WatchAgentSoftwareVersionRequest_FieldMask) *WatchAgentSoftwareVersionRequest_FieldMask {
	result := &WatchAgentSoftwareVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAgentSoftwareVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAgentSoftwareVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) FilterInputFields() *WatchAgentSoftwareVersionRequest_FieldMask {
	result := &WatchAgentSoftwareVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAgentSoftwareVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAgentSoftwareVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAgentSoftwareVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAgentSoftwareVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) AppendPath(path WatchAgentSoftwareVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAgentSoftwareVersionRequest_FieldPath))
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) GetPaths() []WatchAgentSoftwareVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAgentSoftwareVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Set(target, source *WatchAgentSoftwareVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAgentSoftwareVersionRequest), source.(*WatchAgentSoftwareVersionRequest))
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) Project(source *WatchAgentSoftwareVersionRequest) *WatchAgentSoftwareVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAgentSoftwareVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAgentSoftwareVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchAgentSoftwareVersionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchAgentSoftwareVersionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAgentSoftwareVersionRequest))
}

func (fieldMask *WatchAgentSoftwareVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAgentSoftwareVersionResponse_FieldMask struct {
	Paths []WatchAgentSoftwareVersionResponse_FieldPath
}

func FullWatchAgentSoftwareVersionResponse_FieldMask() *WatchAgentSoftwareVersionResponse_FieldMask {
	res := &WatchAgentSoftwareVersionResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAgentSoftwareVersionResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAgentSoftwareVersionResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAgentSoftwareVersionResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Subtract(other *WatchAgentSoftwareVersionResponse_FieldMask) *WatchAgentSoftwareVersionResponse_FieldMask {
	result := &WatchAgentSoftwareVersionResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAgentSoftwareVersionResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAgentSoftwareVersionResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) FilterInputFields() *WatchAgentSoftwareVersionResponse_FieldMask {
	result := &WatchAgentSoftwareVersionResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAgentSoftwareVersionResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAgentSoftwareVersionResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAgentSoftwareVersionResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAgentSoftwareVersionResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) AppendPath(path WatchAgentSoftwareVersionResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAgentSoftwareVersionResponse_FieldPath))
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) GetPaths() []WatchAgentSoftwareVersionResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAgentSoftwareVersionResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Set(target, source *WatchAgentSoftwareVersionResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAgentSoftwareVersionResponse), source.(*WatchAgentSoftwareVersionResponse))
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) Project(source *WatchAgentSoftwareVersionResponse) *WatchAgentSoftwareVersionResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAgentSoftwareVersionResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAgentSoftwareVersionResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAgentSoftwareVersionResponse))
}

func (fieldMask *WatchAgentSoftwareVersionResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAgentSoftwareVersionsRequest_FieldMask struct {
	Paths []WatchAgentSoftwareVersionsRequest_FieldPath
}

func FullWatchAgentSoftwareVersionsRequest_FieldMask() *WatchAgentSoftwareVersionsRequest_FieldMask {
	res := &WatchAgentSoftwareVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsRequest_FieldTerminalPath{selector: WatchAgentSoftwareVersionsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAgentSoftwareVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAgentSoftwareVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAgentSoftwareVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Subtract(other *WatchAgentSoftwareVersionsRequest_FieldMask) *WatchAgentSoftwareVersionsRequest_FieldMask {
	result := &WatchAgentSoftwareVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAgentSoftwareVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAgentSoftwareVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) FilterInputFields() *WatchAgentSoftwareVersionsRequest_FieldMask {
	result := &WatchAgentSoftwareVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAgentSoftwareVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAgentSoftwareVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAgentSoftwareVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAgentSoftwareVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) AppendPath(path WatchAgentSoftwareVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAgentSoftwareVersionsRequest_FieldPath))
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) GetPaths() []WatchAgentSoftwareVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAgentSoftwareVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Set(target, source *WatchAgentSoftwareVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAgentSoftwareVersionsRequest), source.(*WatchAgentSoftwareVersionsRequest))
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) Project(source *WatchAgentSoftwareVersionsRequest) *WatchAgentSoftwareVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAgentSoftwareVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAgentSoftwareVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchAgentSoftwareVersionsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAgentSoftwareVersionsRequest))
}

func (fieldMask *WatchAgentSoftwareVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAgentSoftwareVersionsResponse_FieldMask struct {
	Paths []WatchAgentSoftwareVersionsResponse_FieldPath
}

func FullWatchAgentSoftwareVersionsResponse_FieldMask() *WatchAgentSoftwareVersionsResponse_FieldMask {
	res := &WatchAgentSoftwareVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersionChanges})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponse_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAgentSoftwareVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAgentSoftwareVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Subtract(other *WatchAgentSoftwareVersionsResponse_FieldMask) *WatchAgentSoftwareVersionsResponse_FieldMask {
	result := &WatchAgentSoftwareVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange: &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchAgentSoftwareVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange: &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAgentSoftwareVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchAgentSoftwareVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchAgentSoftwareVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange] = FullWatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchAgentSoftwareVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchAgentSoftwareVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAgentSoftwareVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) FilterInputFields() *WatchAgentSoftwareVersionsResponse_FieldMask {
	result := &WatchAgentSoftwareVersionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAgentSoftwareVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAgentSoftwareVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAgentSoftwareVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAgentSoftwareVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) AppendPath(path WatchAgentSoftwareVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAgentSoftwareVersionsResponse_FieldPath))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) GetPaths() []WatchAgentSoftwareVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAgentSoftwareVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Set(target, source *WatchAgentSoftwareVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAgentSoftwareVersionsResponse), source.(*WatchAgentSoftwareVersionsResponse))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) Project(source *WatchAgentSoftwareVersionsResponse) *WatchAgentSoftwareVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAgentSoftwareVersionsResponse{}
	pageTokenChangeMask := &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAgentSoftwareVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorAgentSoftwareVersionChanges:
				result.AgentSoftwareVersionChanges = source.AgentSoftwareVersionChanges
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchAgentSoftwareVersionsResponse_FieldSubPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAgentSoftwareVersionsResponse))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath
}

func FullWatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask() *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask {
	res := &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponsePageTokenChange_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchAgentSoftwareVersionsResponsePageTokenChange_FieldTerminalPath{selector: WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAgentSoftwareVersionsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Subtract(other *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask {
	result := &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAgentSoftwareVersionsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask {
	result := &WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) AppendPath(path WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) GetPaths() []WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAgentSoftwareVersionsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Set(target, source *WatchAgentSoftwareVersionsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAgentSoftwareVersionsResponse_PageTokenChange), source.(*WatchAgentSoftwareVersionsResponse_PageTokenChange))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) Project(source *WatchAgentSoftwareVersionsResponse_PageTokenChange) *WatchAgentSoftwareVersionsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAgentSoftwareVersionsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAgentSoftwareVersionsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchAgentSoftwareVersionsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAgentSoftwareVersionsResponse_PageTokenChange))
}

func (fieldMask *WatchAgentSoftwareVersionsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateAgentSoftwareVersionRequest_FieldMask struct {
	Paths []CreateAgentSoftwareVersionRequest_FieldPath
}

func FullCreateAgentSoftwareVersionRequest_FieldMask() *CreateAgentSoftwareVersionRequest_FieldMask {
	res := &CreateAgentSoftwareVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateAgentSoftwareVersionRequest_FieldTerminalPath{selector: CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion})
	return res
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateAgentSoftwareVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateAgentSoftwareVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Subtract(other *CreateAgentSoftwareVersionRequest_FieldMask) *CreateAgentSoftwareVersionRequest_FieldMask {
	result := &CreateAgentSoftwareVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[CreateAgentSoftwareVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}
	mySubMasks := map[CreateAgentSoftwareVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateAgentSoftwareVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateAgentSoftwareVersionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
						mySubMasks[CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion] = agent_software_version.FullAgentSoftwareVersion_FieldMask()
					}
				} else if tp, ok := path.(*CreateAgentSoftwareVersionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateAgentSoftwareVersionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateAgentSoftwareVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) FilterInputFields() *CreateAgentSoftwareVersionRequest_FieldMask {
	result := &CreateAgentSoftwareVersionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
			if _, ok := path.(*CreateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range agent_software_version.FullAgentSoftwareVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateAgentSoftwareVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateAgentSoftwareVersionRequest_FieldSubPath); ok {
				selectedMask := &agent_software_version.AgentSoftwareVersion_FieldMask{
					Paths: []agent_software_version.AgentSoftwareVersion_FieldPath{sub.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateAgentSoftwareVersionRequest_FieldSubPath{selector: CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateAgentSoftwareVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateAgentSoftwareVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateAgentSoftwareVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateAgentSoftwareVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) AppendPath(path CreateAgentSoftwareVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateAgentSoftwareVersionRequest_FieldPath))
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) GetPaths() []CreateAgentSoftwareVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateAgentSoftwareVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Set(target, source *CreateAgentSoftwareVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateAgentSoftwareVersionRequest), source.(*CreateAgentSoftwareVersionRequest))
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) Project(source *CreateAgentSoftwareVersionRequest) *CreateAgentSoftwareVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateAgentSoftwareVersionRequest{}
	agentSoftwareVersionMask := &agent_software_version.AgentSoftwareVersion_FieldMask{}
	wholeAgentSoftwareVersionAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateAgentSoftwareVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
				result.AgentSoftwareVersion = source.AgentSoftwareVersion
				wholeAgentSoftwareVersionAccepted = true
			}
		case *CreateAgentSoftwareVersionRequest_FieldSubPath:
			switch tp.selector {
			case CreateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
				agentSoftwareVersionMask.AppendPath(tp.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath))
			}
		}
	}
	if wholeAgentSoftwareVersionAccepted == false && len(agentSoftwareVersionMask.Paths) > 0 {
		result.AgentSoftwareVersion = agentSoftwareVersionMask.Project(source.GetAgentSoftwareVersion())
	}
	return result
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateAgentSoftwareVersionRequest))
}

func (fieldMask *CreateAgentSoftwareVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateAgentSoftwareVersionRequest_FieldMask struct {
	Paths []UpdateAgentSoftwareVersionRequest_FieldPath
}

func FullUpdateAgentSoftwareVersionRequest_FieldMask() *UpdateAgentSoftwareVersionRequest_FieldMask {
	res := &UpdateAgentSoftwareVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateAgentSoftwareVersionRequest_FieldTerminalPath{selector: UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion})
	res.Paths = append(res.Paths, &UpdateAgentSoftwareVersionRequest_FieldTerminalPath{selector: UpdateAgentSoftwareVersionRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateAgentSoftwareVersionRequest_FieldTerminalPath{selector: UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateAgentSoftwareVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateAgentSoftwareVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Subtract(other *UpdateAgentSoftwareVersionRequest_FieldMask) *UpdateAgentSoftwareVersionRequest_FieldMask {
	result := &UpdateAgentSoftwareVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateAgentSoftwareVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion: &agent_software_version.AgentSoftwareVersion_FieldMask{},
		UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:                  &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateAgentSoftwareVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion: &agent_software_version.AgentSoftwareVersion_FieldMask{},
		UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:                  &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateAgentSoftwareVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateAgentSoftwareVersionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
						mySubMasks[UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion] = agent_software_version.FullAgentSoftwareVersion_FieldMask()
					case UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:
						mySubMasks[UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas] = FullUpdateAgentSoftwareVersionRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateAgentSoftwareVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) FilterInputFields() *UpdateAgentSoftwareVersionRequest_FieldMask {
	result := &UpdateAgentSoftwareVersionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
			if _, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range agent_software_version.FullAgentSoftwareVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldSubPath); ok {
				selectedMask := &agent_software_version.AgentSoftwareVersion_FieldMask{
					Paths: []agent_software_version.AgentSoftwareVersion_FieldPath{sub.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequest_FieldSubPath{selector: UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion, subPath: allowedPath})
				}
			}
		case UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateAgentSoftwareVersionRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAgentSoftwareVersionRequest_FieldSubPath); ok {
				selectedMask := &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{
					Paths: []UpdateAgentSoftwareVersionRequestCAS_FieldPath{sub.subPath.(UpdateAgentSoftwareVersionRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequest_FieldSubPath{selector: UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateAgentSoftwareVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateAgentSoftwareVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateAgentSoftwareVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateAgentSoftwareVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) AppendPath(path UpdateAgentSoftwareVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateAgentSoftwareVersionRequest_FieldPath))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) GetPaths() []UpdateAgentSoftwareVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateAgentSoftwareVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Set(target, source *UpdateAgentSoftwareVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateAgentSoftwareVersionRequest), source.(*UpdateAgentSoftwareVersionRequest))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) Project(source *UpdateAgentSoftwareVersionRequest) *UpdateAgentSoftwareVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateAgentSoftwareVersionRequest{}
	agentSoftwareVersionMask := &agent_software_version.AgentSoftwareVersion_FieldMask{}
	wholeAgentSoftwareVersionAccepted := false
	casMask := &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateAgentSoftwareVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
				result.AgentSoftwareVersion = source.AgentSoftwareVersion
				wholeAgentSoftwareVersionAccepted = true
			case UpdateAgentSoftwareVersionRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateAgentSoftwareVersionRequest_FieldSubPath:
			switch tp.selector {
			case UpdateAgentSoftwareVersionRequest_FieldPathSelectorAgentSoftwareVersion:
				agentSoftwareVersionMask.AppendPath(tp.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath))
			case UpdateAgentSoftwareVersionRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateAgentSoftwareVersionRequestCAS_FieldPath))
			}
		}
	}
	if wholeAgentSoftwareVersionAccepted == false && len(agentSoftwareVersionMask.Paths) > 0 {
		result.AgentSoftwareVersion = agentSoftwareVersionMask.Project(source.GetAgentSoftwareVersion())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateAgentSoftwareVersionRequest))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateAgentSoftwareVersionRequest_CAS_FieldMask struct {
	Paths []UpdateAgentSoftwareVersionRequestCAS_FieldPath
}

func FullUpdateAgentSoftwareVersionRequest_CAS_FieldMask() *UpdateAgentSoftwareVersionRequest_CAS_FieldMask {
	res := &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath{selector: UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath{selector: UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateAgentSoftwareVersionRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateAgentSoftwareVersionRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Subtract(other *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) *UpdateAgentSoftwareVersionRequest_CAS_FieldMask {
	result := &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateAgentSoftwareVersionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}
	mySubMasks := map[UpdateAgentSoftwareVersionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState: &agent_software_version.AgentSoftwareVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateAgentSoftwareVersionRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState] = agent_software_version.FullAgentSoftwareVersion_FieldMask()
					}
				} else if tp, ok := path.(*UpdateAgentSoftwareVersionRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateAgentSoftwareVersionRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) FilterInputFields() *UpdateAgentSoftwareVersionRequest_CAS_FieldMask {
	result := &UpdateAgentSoftwareVersionRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range agent_software_version.FullAgentSoftwareVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAgentSoftwareVersionRequestCAS_FieldSubPath); ok {
				selectedMask := &agent_software_version.AgentSoftwareVersion_FieldMask{
					Paths: []agent_software_version.AgentSoftwareVersion_FieldPath{sub.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAgentSoftwareVersionRequestCAS_FieldSubPath{selector: UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateAgentSoftwareVersionRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateAgentSoftwareVersionRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateAgentSoftwareVersionRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) AppendPath(path UpdateAgentSoftwareVersionRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateAgentSoftwareVersionRequestCAS_FieldPath))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) GetPaths() []UpdateAgentSoftwareVersionRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateAgentSoftwareVersionRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Set(target, source *UpdateAgentSoftwareVersionRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateAgentSoftwareVersionRequest_CAS), source.(*UpdateAgentSoftwareVersionRequest_CAS))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) Project(source *UpdateAgentSoftwareVersionRequest_CAS) *UpdateAgentSoftwareVersionRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateAgentSoftwareVersionRequest_CAS{}
	conditionalStateMask := &agent_software_version.AgentSoftwareVersion_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateAgentSoftwareVersionRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateAgentSoftwareVersionRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateAgentSoftwareVersionRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(agent_software_version.AgentSoftwareVersion_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateAgentSoftwareVersionRequest_CAS))
}

func (fieldMask *UpdateAgentSoftwareVersionRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteAgentSoftwareVersionRequest_FieldMask struct {
	Paths []DeleteAgentSoftwareVersionRequest_FieldPath
}

func FullDeleteAgentSoftwareVersionRequest_FieldMask() *DeleteAgentSoftwareVersionRequest_FieldMask {
	res := &DeleteAgentSoftwareVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteAgentSoftwareVersionRequest_FieldTerminalPath{selector: DeleteAgentSoftwareVersionRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteAgentSoftwareVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteAgentSoftwareVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteAgentSoftwareVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Subtract(other *DeleteAgentSoftwareVersionRequest_FieldMask) *DeleteAgentSoftwareVersionRequest_FieldMask {
	result := &DeleteAgentSoftwareVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteAgentSoftwareVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteAgentSoftwareVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) FilterInputFields() *DeleteAgentSoftwareVersionRequest_FieldMask {
	result := &DeleteAgentSoftwareVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteAgentSoftwareVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteAgentSoftwareVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteAgentSoftwareVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteAgentSoftwareVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) AppendPath(path DeleteAgentSoftwareVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteAgentSoftwareVersionRequest_FieldPath))
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) GetPaths() []DeleteAgentSoftwareVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteAgentSoftwareVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Set(target, source *DeleteAgentSoftwareVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteAgentSoftwareVersionRequest), source.(*DeleteAgentSoftwareVersionRequest))
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) Project(source *DeleteAgentSoftwareVersionRequest) *DeleteAgentSoftwareVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteAgentSoftwareVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteAgentSoftwareVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteAgentSoftwareVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteAgentSoftwareVersionRequest))
}

func (fieldMask *DeleteAgentSoftwareVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
