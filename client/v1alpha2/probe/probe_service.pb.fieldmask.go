// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/probe_service.proto
// DO NOT EDIT!!!

package probe_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	probe "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/probe"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/project"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &probe.Probe{}
	_ = &project.Project{}
)

type GetProbeRequest_FieldMask struct {
	Paths []GetProbeRequest_FieldPath
}

func FullGetProbeRequest_FieldMask() *GetProbeRequest_FieldMask {
	res := &GetProbeRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProbeRequest_FieldTerminalPath{selector: GetProbeRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProbeRequest_FieldTerminalPath{selector: GetProbeRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProbeRequest_FieldTerminalPath{selector: GetProbeRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProbeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProbeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProbeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProbeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProbeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProbeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProbeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProbeRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProbeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProbeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProbeRequest_FieldMask) Subtract(other *GetProbeRequest_FieldMask) *GetProbeRequest_FieldMask {
	result := &GetProbeRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProbeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProbeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProbeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProbeRequest_FieldMask) FilterInputFields() *GetProbeRequest_FieldMask {
	result := &GetProbeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProbeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProbeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProbeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProbeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProbeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProbeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProbeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProbeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbeRequest_FieldMask) AppendPath(path GetProbeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProbeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProbeRequest_FieldPath))
}

func (fieldMask *GetProbeRequest_FieldMask) GetPaths() []GetProbeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProbeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProbeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProbeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProbeRequest_FieldMask) Set(target, source *GetProbeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProbeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProbeRequest), source.(*GetProbeRequest))
}

func (fieldMask *GetProbeRequest_FieldMask) Project(source *GetProbeRequest) *GetProbeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProbeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProbeRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProbeRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProbeRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProbeRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProbeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProbeRequest))
}

func (fieldMask *GetProbeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbesRequest_FieldMask struct {
	Paths []BatchGetProbesRequest_FieldPath
}

func FullBatchGetProbesRequest_FieldMask() *BatchGetProbesRequest_FieldMask {
	res := &BatchGetProbesRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbesRequest_FieldTerminalPath{selector: BatchGetProbesRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProbesRequest_FieldTerminalPath{selector: BatchGetProbesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProbesRequest_FieldTerminalPath{selector: BatchGetProbesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProbesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbesRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbesRequest_FieldMask) Subtract(other *BatchGetProbesRequest_FieldMask) *BatchGetProbesRequest_FieldMask {
	result := &BatchGetProbesRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbesRequest_FieldMask) FilterInputFields() *BatchGetProbesRequest_FieldMask {
	result := &BatchGetProbesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbesRequest_FieldMask) AppendPath(path BatchGetProbesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbesRequest_FieldPath))
}

func (fieldMask *BatchGetProbesRequest_FieldMask) GetPaths() []BatchGetProbesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbesRequest_FieldMask) Set(target, source *BatchGetProbesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbesRequest), source.(*BatchGetProbesRequest))
}

func (fieldMask *BatchGetProbesRequest_FieldMask) Project(source *BatchGetProbesRequest) *BatchGetProbesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbesRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbesRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProbesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProbesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProbesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbesRequest))
}

func (fieldMask *BatchGetProbesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbesResponse_FieldMask struct {
	Paths []BatchGetProbesResponse_FieldPath
}

func FullBatchGetProbesResponse_FieldMask() *BatchGetProbesResponse_FieldMask {
	res := &BatchGetProbesResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbesResponse_FieldTerminalPath{selector: BatchGetProbesResponse_FieldPathSelectorProbes})
	res.Paths = append(res.Paths, &BatchGetProbesResponse_FieldTerminalPath{selector: BatchGetProbesResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProbesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbesResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbesResponse_FieldMask) Subtract(other *BatchGetProbesResponse_FieldMask) *BatchGetProbesResponse_FieldMask {
	result := &BatchGetProbesResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[BatchGetProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProbesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProbesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProbesResponse_FieldPathSelectorProbes:
						mySubMasks[BatchGetProbesResponse_FieldPathSelectorProbes] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProbesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProbesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbesResponse_FieldMask) FilterInputFields() *BatchGetProbesResponse_FieldMask {
	result := &BatchGetProbesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProbesResponse_FieldPathSelectorProbes:
			if _, ok := path.(*BatchGetProbesResponse_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProbesResponse_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbesResponse_FieldSubPath{selector: BatchGetProbesResponse_FieldPathSelectorProbes, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbesResponse_FieldMask) AppendPath(path BatchGetProbesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbesResponse_FieldPath))
}

func (fieldMask *BatchGetProbesResponse_FieldMask) GetPaths() []BatchGetProbesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbesResponse_FieldMask) Set(target, source *BatchGetProbesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbesResponse), source.(*BatchGetProbesResponse))
}

func (fieldMask *BatchGetProbesResponse_FieldMask) Project(source *BatchGetProbesResponse) *BatchGetProbesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbesResponse{}
	probesMask := &probe.Probe_FieldMask{}
	wholeProbesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbesResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbesResponse_FieldPathSelectorProbes:
				result.Probes = source.Probes
				wholeProbesAccepted = true
			case BatchGetProbesResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProbesResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProbesResponse_FieldPathSelectorProbes:
				probesMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		}
	}
	if wholeProbesAccepted == false && len(probesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbes() {
			result.Probes = append(result.Probes, probesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProbesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbesResponse))
}

func (fieldMask *BatchGetProbesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbesRequest_FieldMask struct {
	Paths []ListProbesRequest_FieldPath
}

func FullListProbesRequest_FieldMask() *ListProbesRequest_FieldMask {
	res := &ListProbesRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProbesRequest_FieldTerminalPath{selector: ListProbesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListProbesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbesRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProbesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbesRequest_FieldMask) Subtract(other *ListProbesRequest_FieldMask) *ListProbesRequest_FieldMask {
	result := &ListProbesRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbesRequest_FieldMask) FilterInputFields() *ListProbesRequest_FieldMask {
	result := &ListProbesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbesRequest_FieldMask) AppendPath(path ListProbesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbesRequest_FieldPath))
}

func (fieldMask *ListProbesRequest_FieldMask) GetPaths() []ListProbesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbesRequest_FieldMask) Set(target, source *ListProbesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbesRequest), source.(*ListProbesRequest))
}

func (fieldMask *ListProbesRequest_FieldMask) Project(source *ListProbesRequest) *ListProbesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbesRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProbesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProbesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProbesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProbesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProbesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProbesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProbesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListProbesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbesRequest))
}

func (fieldMask *ListProbesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbesResponse_FieldMask struct {
	Paths []ListProbesResponse_FieldPath
}

func FullListProbesResponse_FieldMask() *ListProbesResponse_FieldMask {
	res := &ListProbesResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProbesResponse_FieldTerminalPath{selector: ListProbesResponse_FieldPathSelectorProbes})
	res.Paths = append(res.Paths, &ListProbesResponse_FieldTerminalPath{selector: ListProbesResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProbesResponse_FieldTerminalPath{selector: ListProbesResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListProbesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbesResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProbesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbesResponse_FieldMask) Subtract(other *ListProbesResponse_FieldMask) *ListProbesResponse_FieldMask {
	result := &ListProbesResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[ListProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProbesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProbesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProbesResponse_FieldPathSelectorProbes:
						mySubMasks[ListProbesResponse_FieldPathSelectorProbes] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*ListProbesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProbesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbesResponse_FieldMask) FilterInputFields() *ListProbesResponse_FieldMask {
	result := &ListProbesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProbesResponse_FieldPathSelectorProbes:
			if _, ok := path.(*ListProbesResponse_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProbesResponse_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbesResponse_FieldSubPath{selector: ListProbesResponse_FieldPathSelectorProbes, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbesResponse_FieldMask) AppendPath(path ListProbesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbesResponse_FieldPath))
}

func (fieldMask *ListProbesResponse_FieldMask) GetPaths() []ListProbesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbesResponse_FieldMask) Set(target, source *ListProbesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbesResponse), source.(*ListProbesResponse))
}

func (fieldMask *ListProbesResponse_FieldMask) Project(source *ListProbesResponse) *ListProbesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbesResponse{}
	probesMask := &probe.Probe_FieldMask{}
	wholeProbesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbesResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProbesResponse_FieldPathSelectorProbes:
				result.Probes = source.Probes
				wholeProbesAccepted = true
			case ListProbesResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProbesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListProbesResponse_FieldSubPath:
			switch tp.selector {
			case ListProbesResponse_FieldPathSelectorProbes:
				probesMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		}
	}
	if wholeProbesAccepted == false && len(probesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbes() {
			result.Probes = append(result.Probes, probesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProbesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbesResponse))
}

func (fieldMask *ListProbesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbeRequest_FieldMask struct {
	Paths []WatchProbeRequest_FieldPath
}

func FullWatchProbeRequest_FieldMask() *WatchProbeRequest_FieldMask {
	res := &WatchProbeRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbeRequest_FieldTerminalPath{selector: WatchProbeRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProbeRequest_FieldTerminalPath{selector: WatchProbeRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbeRequest_FieldTerminalPath{selector: WatchProbeRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProbeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbeRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbeRequest_FieldMask) Subtract(other *WatchProbeRequest_FieldMask) *WatchProbeRequest_FieldMask {
	result := &WatchProbeRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbeRequest_FieldMask) FilterInputFields() *WatchProbeRequest_FieldMask {
	result := &WatchProbeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbeRequest_FieldMask) AppendPath(path WatchProbeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbeRequest_FieldPath))
}

func (fieldMask *WatchProbeRequest_FieldMask) GetPaths() []WatchProbeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbeRequest_FieldMask) Set(target, source *WatchProbeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbeRequest), source.(*WatchProbeRequest))
}

func (fieldMask *WatchProbeRequest_FieldMask) Project(source *WatchProbeRequest) *WatchProbeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbeRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbeRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProbeRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbeRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProbeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbeRequest))
}

func (fieldMask *WatchProbeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbeResponse_FieldMask struct {
	Paths []WatchProbeResponse_FieldPath
}

func FullWatchProbeResponse_FieldMask() *WatchProbeResponse_FieldMask {
	res := &WatchProbeResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbeResponse_FieldTerminalPath{selector: WatchProbeResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProbeResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbeResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbeResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbeResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbeResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbeResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbeResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbeResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbeResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbeResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbeResponse_FieldMask) Subtract(other *WatchProbeResponse_FieldMask) *WatchProbeResponse_FieldMask {
	result := &WatchProbeResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbeResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbeResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbeResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbeResponse_FieldMask) FilterInputFields() *WatchProbeResponse_FieldMask {
	result := &WatchProbeResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbeResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbeResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbeResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbeResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbeResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbeResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbeResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbeResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbeResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbeResponse_FieldMask) AppendPath(path WatchProbeResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbeResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbeResponse_FieldPath))
}

func (fieldMask *WatchProbeResponse_FieldMask) GetPaths() []WatchProbeResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbeResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbeResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbeResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbeResponse_FieldMask) Set(target, source *WatchProbeResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbeResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbeResponse), source.(*WatchProbeResponse))
}

func (fieldMask *WatchProbeResponse_FieldMask) Project(source *WatchProbeResponse) *WatchProbeResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbeResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbeResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbeResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProbeResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbeResponse))
}

func (fieldMask *WatchProbeResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbesRequest_FieldMask struct {
	Paths []WatchProbesRequest_FieldPath
}

func FullWatchProbesRequest_FieldMask() *WatchProbesRequest_FieldMask {
	res := &WatchProbesRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProbesRequest_FieldTerminalPath{selector: WatchProbesRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProbesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbesRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbesRequest_FieldMask) Subtract(other *WatchProbesRequest_FieldMask) *WatchProbesRequest_FieldMask {
	result := &WatchProbesRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbesRequest_FieldMask) FilterInputFields() *WatchProbesRequest_FieldMask {
	result := &WatchProbesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesRequest_FieldMask) AppendPath(path WatchProbesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbesRequest_FieldPath))
}

func (fieldMask *WatchProbesRequest_FieldMask) GetPaths() []WatchProbesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbesRequest_FieldMask) Set(target, source *WatchProbesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbesRequest), source.(*WatchProbesRequest))
}

func (fieldMask *WatchProbesRequest_FieldMask) Project(source *WatchProbesRequest) *WatchProbesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbesRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbesRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProbesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProbesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProbesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProbesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProbesRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProbesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbesRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProbesRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProbesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbesRequest))
}

func (fieldMask *WatchProbesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbesResponse_FieldMask struct {
	Paths []WatchProbesResponse_FieldPath
}

func FullWatchProbesResponse_FieldMask() *WatchProbesResponse_FieldMask {
	res := &WatchProbesResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorProbeChanges})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProbesResponse_FieldTerminalPath{selector: WatchProbesResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProbesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbesResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbesResponse_FieldMask) Subtract(other *WatchProbesResponse_FieldMask) *WatchProbesResponse_FieldMask {
	result := &WatchProbesResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbesResponse_FieldPathSelectorPageTokenChange: &WatchProbesResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbesResponse_FieldPathSelectorPageTokenChange: &WatchProbesResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProbesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProbesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProbesResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProbesResponse_FieldPathSelectorPageTokenChange] = FullWatchProbesResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProbesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProbesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbesResponse_FieldMask) FilterInputFields() *WatchProbesResponse_FieldMask {
	result := &WatchProbesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesResponse_FieldMask) AppendPath(path WatchProbesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbesResponse_FieldPath))
}

func (fieldMask *WatchProbesResponse_FieldMask) GetPaths() []WatchProbesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbesResponse_FieldMask) Set(target, source *WatchProbesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbesResponse), source.(*WatchProbesResponse))
}

func (fieldMask *WatchProbesResponse_FieldMask) Project(source *WatchProbesResponse) *WatchProbesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbesResponse{}
	pageTokenChangeMask := &WatchProbesResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbesResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbesResponse_FieldPathSelectorProbeChanges:
				result.ProbeChanges = source.ProbeChanges
			case WatchProbesResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProbesResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProbesResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbesResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProbesResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProbesResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProbesResponse_FieldSubPath:
			switch tp.selector {
			case WatchProbesResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProbesResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProbesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbesResponse))
}

func (fieldMask *WatchProbesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbesResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProbesResponsePageTokenChange_FieldPath
}

func FullWatchProbesResponse_PageTokenChange_FieldMask() *WatchProbesResponse_PageTokenChange_FieldMask {
	res := &WatchProbesResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbesResponsePageTokenChange_FieldTerminalPath{selector: WatchProbesResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProbesResponsePageTokenChange_FieldTerminalPath{selector: WatchProbesResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbesResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbesResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbesResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Subtract(other *WatchProbesResponse_PageTokenChange_FieldMask) *WatchProbesResponse_PageTokenChange_FieldMask {
	result := &WatchProbesResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbesResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbesResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProbesResponse_PageTokenChange_FieldMask {
	result := &WatchProbesResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbesResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbesResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbesResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbesResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) AppendPath(path WatchProbesResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbesResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) GetPaths() []WatchProbesResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbesResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Set(target, source *WatchProbesResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbesResponse_PageTokenChange), source.(*WatchProbesResponse_PageTokenChange))
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) Project(source *WatchProbesResponse_PageTokenChange) *WatchProbesResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbesResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbesResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProbesResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProbesResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbesResponse_PageTokenChange))
}

func (fieldMask *WatchProbesResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProbeRequest_FieldMask struct {
	Paths []CreateProbeRequest_FieldPath
}

func FullCreateProbeRequest_FieldMask() *CreateProbeRequest_FieldMask {
	res := &CreateProbeRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProbeRequest_FieldTerminalPath{selector: CreateProbeRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProbeRequest_FieldTerminalPath{selector: CreateProbeRequest_FieldPathSelectorProbe})
	return res
}

func (fieldMask *CreateProbeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProbeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProbeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProbeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProbeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProbeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProbeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProbeRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProbeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProbeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProbeRequest_FieldMask) Subtract(other *CreateProbeRequest_FieldMask) *CreateProbeRequest_FieldMask {
	result := &CreateProbeRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProbeRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbeRequest_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[CreateProbeRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbeRequest_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProbeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProbeRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProbeRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProbeRequest_FieldPathSelectorProbe:
						mySubMasks[CreateProbeRequest_FieldPathSelectorProbe] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*CreateProbeRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProbeRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProbeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProbeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProbeRequest_FieldMask) FilterInputFields() *CreateProbeRequest_FieldMask {
	result := &CreateProbeRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProbeRequest_FieldPathSelectorProbe:
			if _, ok := path.(*CreateProbeRequest_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbeRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProbeRequest_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbeRequest_FieldSubPath{selector: CreateProbeRequest_FieldPathSelectorProbe, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProbeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProbeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProbeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProbeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProbeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProbeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProbeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProbeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbeRequest_FieldMask) AppendPath(path CreateProbeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProbeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProbeRequest_FieldPath))
}

func (fieldMask *CreateProbeRequest_FieldMask) GetPaths() []CreateProbeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProbeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProbeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProbeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProbeRequest_FieldMask) Set(target, source *CreateProbeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProbeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProbeRequest), source.(*CreateProbeRequest))
}

func (fieldMask *CreateProbeRequest_FieldMask) Project(source *CreateProbeRequest) *CreateProbeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProbeRequest{}
	probeMask := &probe.Probe_FieldMask{}
	wholeProbeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProbeRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProbeRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProbeRequest_FieldPathSelectorProbe:
				result.Probe = source.Probe
				wholeProbeAccepted = true
			}
		case *CreateProbeRequest_FieldSubPath:
			switch tp.selector {
			case CreateProbeRequest_FieldPathSelectorProbe:
				probeMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		}
	}
	if wholeProbeAccepted == false && len(probeMask.Paths) > 0 {
		result.Probe = probeMask.Project(source.GetProbe())
	}
	return result
}

func (fieldMask *CreateProbeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProbeRequest))
}

func (fieldMask *CreateProbeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbeRequest_FieldMask struct {
	Paths []UpdateProbeRequest_FieldPath
}

func FullUpdateProbeRequest_FieldMask() *UpdateProbeRequest_FieldMask {
	res := &UpdateProbeRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbeRequest_FieldTerminalPath{selector: UpdateProbeRequest_FieldPathSelectorProbe})
	res.Paths = append(res.Paths, &UpdateProbeRequest_FieldTerminalPath{selector: UpdateProbeRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProbeRequest_FieldTerminalPath{selector: UpdateProbeRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProbeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbeRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbeRequest_FieldMask) Subtract(other *UpdateProbeRequest_FieldMask) *UpdateProbeRequest_FieldMask {
	result := &UpdateProbeRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProbeRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbeRequest_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
		UpdateProbeRequest_FieldPathSelectorCas:   &UpdateProbeRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProbeRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbeRequest_FieldPathSelectorProbe: &probe.Probe_FieldMask{},
		UpdateProbeRequest_FieldPathSelectorCas:   &UpdateProbeRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbeRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbeRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbeRequest_FieldPathSelectorProbe:
						mySubMasks[UpdateProbeRequest_FieldPathSelectorProbe] = probe.FullProbe_FieldMask()
					case UpdateProbeRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProbeRequest_FieldPathSelectorCas] = FullUpdateProbeRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbeRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbeRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbeRequest_FieldMask) FilterInputFields() *UpdateProbeRequest_FieldMask {
	result := &UpdateProbeRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbeRequest_FieldPathSelectorProbe:
			if _, ok := path.(*UpdateProbeRequest_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbeRequest_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequest_FieldSubPath{selector: UpdateProbeRequest_FieldPathSelectorProbe, subPath: allowedPath})
				}
			}
		case UpdateProbeRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProbeRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProbeRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbeRequest_FieldSubPath); ok {
				selectedMask := &UpdateProbeRequest_CAS_FieldMask{
					Paths: []UpdateProbeRequestCAS_FieldPath{sub.subPath.(UpdateProbeRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequest_FieldSubPath{selector: UpdateProbeRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_FieldMask) AppendPath(path UpdateProbeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbeRequest_FieldPath))
}

func (fieldMask *UpdateProbeRequest_FieldMask) GetPaths() []UpdateProbeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbeRequest_FieldMask) Set(target, source *UpdateProbeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbeRequest), source.(*UpdateProbeRequest))
}

func (fieldMask *UpdateProbeRequest_FieldMask) Project(source *UpdateProbeRequest) *UpdateProbeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbeRequest{}
	probeMask := &probe.Probe_FieldMask{}
	wholeProbeAccepted := false
	casMask := &UpdateProbeRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbeRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbeRequest_FieldPathSelectorProbe:
				result.Probe = source.Probe
				wholeProbeAccepted = true
			case UpdateProbeRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProbeRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProbeRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProbeRequest_FieldPathSelectorProbe:
				probeMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			case UpdateProbeRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProbeRequestCAS_FieldPath))
			}
		}
	}
	if wholeProbeAccepted == false && len(probeMask.Paths) > 0 {
		result.Probe = probeMask.Project(source.GetProbe())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProbeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbeRequest))
}

func (fieldMask *UpdateProbeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbeRequest_CAS_FieldMask struct {
	Paths []UpdateProbeRequestCAS_FieldPath
}

func FullUpdateProbeRequest_CAS_FieldMask() *UpdateProbeRequest_CAS_FieldMask {
	res := &UpdateProbeRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbeRequestCAS_FieldTerminalPath{selector: UpdateProbeRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProbeRequestCAS_FieldTerminalPath{selector: UpdateProbeRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbeRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbeRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbeRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbeRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Subtract(other *UpdateProbeRequest_CAS_FieldMask) *UpdateProbeRequest_CAS_FieldMask {
	result := &UpdateProbeRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProbeRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbeRequestCAS_FieldPathSelectorConditionalState: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[UpdateProbeRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbeRequestCAS_FieldPathSelectorConditionalState: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbeRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbeRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbeRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbeRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProbeRequestCAS_FieldPathSelectorConditionalState] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbeRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbeRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbeRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbeRequest_CAS_FieldMask) FilterInputFields() *UpdateProbeRequest_CAS_FieldMask {
	result := &UpdateProbeRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbeRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProbeRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbeRequestCAS_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbeRequestCAS_FieldSubPath{selector: UpdateProbeRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbeRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbeRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbeRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbeRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbeRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) AppendPath(path UpdateProbeRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbeRequestCAS_FieldPath))
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) GetPaths() []UpdateProbeRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbeRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Set(target, source *UpdateProbeRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbeRequest_CAS), source.(*UpdateProbeRequest_CAS))
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) Project(source *UpdateProbeRequest_CAS) *UpdateProbeRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbeRequest_CAS{}
	conditionalStateMask := &probe.Probe_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbeRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbeRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProbeRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProbeRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProbeRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbeRequest_CAS))
}

func (fieldMask *UpdateProbeRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProbeRequest_FieldMask struct {
	Paths []DeleteProbeRequest_FieldPath
}

func FullDeleteProbeRequest_FieldMask() *DeleteProbeRequest_FieldMask {
	res := &DeleteProbeRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProbeRequest_FieldTerminalPath{selector: DeleteProbeRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProbeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProbeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProbeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProbeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProbeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProbeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProbeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProbeRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProbeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProbeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProbeRequest_FieldMask) Subtract(other *DeleteProbeRequest_FieldMask) *DeleteProbeRequest_FieldMask {
	result := &DeleteProbeRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProbeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProbeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProbeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProbeRequest_FieldMask) FilterInputFields() *DeleteProbeRequest_FieldMask {
	result := &DeleteProbeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProbeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProbeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProbeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProbeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProbeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProbeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProbeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProbeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbeRequest_FieldMask) AppendPath(path DeleteProbeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProbeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProbeRequest_FieldPath))
}

func (fieldMask *DeleteProbeRequest_FieldMask) GetPaths() []DeleteProbeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProbeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProbeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProbeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProbeRequest_FieldMask) Set(target, source *DeleteProbeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProbeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProbeRequest), source.(*DeleteProbeRequest))
}

func (fieldMask *DeleteProbeRequest_FieldMask) Project(source *DeleteProbeRequest) *DeleteProbeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProbeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProbeRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProbeRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProbeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProbeRequest))
}

func (fieldMask *DeleteProbeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchProbesRequest_FieldMask struct {
	Paths []SearchProbesRequest_FieldPath
}

func FullSearchProbesRequest_FieldMask() *SearchProbesRequest_FieldMask {
	res := &SearchProbesRequest_FieldMask{}
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &SearchProbesRequest_FieldTerminalPath{selector: SearchProbesRequest_FieldPathSelectorPhrase})
	return res
}

func (fieldMask *SearchProbesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchProbesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchProbesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchProbesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchProbesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchProbesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchProbesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchProbesRequest_FieldPath(raw)
	})
}

func (fieldMask *SearchProbesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *SearchProbesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchProbesRequest_FieldMask) Subtract(other *SearchProbesRequest_FieldMask) *SearchProbesRequest_FieldMask {
	result := &SearchProbesRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchProbesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchProbesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchProbesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchProbesRequest_FieldMask) FilterInputFields() *SearchProbesRequest_FieldMask {
	result := &SearchProbesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchProbesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchProbesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchProbesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchProbesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchProbesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchProbesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchProbesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchProbesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchProbesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchProbesRequest_FieldMask) AppendPath(path SearchProbesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchProbesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchProbesRequest_FieldPath))
}

func (fieldMask *SearchProbesRequest_FieldMask) GetPaths() []SearchProbesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchProbesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchProbesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchProbesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchProbesRequest_FieldMask) Set(target, source *SearchProbesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchProbesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchProbesRequest), source.(*SearchProbesRequest))
}

func (fieldMask *SearchProbesRequest_FieldMask) Project(source *SearchProbesRequest) *SearchProbesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchProbesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchProbesRequest_FieldTerminalPath:
			switch tp.selector {
			case SearchProbesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case SearchProbesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case SearchProbesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case SearchProbesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case SearchProbesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case SearchProbesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case SearchProbesRequest_FieldPathSelectorView:
				result.View = source.View
			case SearchProbesRequest_FieldPathSelectorPhrase:
				result.Phrase = source.Phrase
			}
		}
	}
	return result
}

func (fieldMask *SearchProbesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchProbesRequest))
}

func (fieldMask *SearchProbesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchProbesResponse_FieldMask struct {
	Paths []SearchProbesResponse_FieldPath
}

func FullSearchProbesResponse_FieldMask() *SearchProbesResponse_FieldMask {
	res := &SearchProbesResponse_FieldMask{}
	res.Paths = append(res.Paths, &SearchProbesResponse_FieldTerminalPath{selector: SearchProbesResponse_FieldPathSelectorProbes})
	res.Paths = append(res.Paths, &SearchProbesResponse_FieldTerminalPath{selector: SearchProbesResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &SearchProbesResponse_FieldTerminalPath{selector: SearchProbesResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &SearchProbesResponse_FieldTerminalPath{selector: SearchProbesResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &SearchProbesResponse_FieldTerminalPath{selector: SearchProbesResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *SearchProbesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchProbesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchProbesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchProbesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchProbesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchProbesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchProbesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchProbesResponse_FieldPath(raw)
	})
}

func (fieldMask *SearchProbesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *SearchProbesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchProbesResponse_FieldMask) Subtract(other *SearchProbesResponse_FieldMask) *SearchProbesResponse_FieldMask {
	result := &SearchProbesResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[SearchProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}
	mySubMasks := map[SearchProbesResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchProbesResponse_FieldPathSelectorProbes: &probe.Probe_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchProbesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *SearchProbesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*SearchProbesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case SearchProbesResponse_FieldPathSelectorProbes:
						mySubMasks[SearchProbesResponse_FieldPathSelectorProbes] = probe.FullProbe_FieldMask()
					}
				} else if tp, ok := path.(*SearchProbesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &SearchProbesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchProbesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchProbesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchProbesResponse_FieldMask) FilterInputFields() *SearchProbesResponse_FieldMask {
	result := &SearchProbesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case SearchProbesResponse_FieldPathSelectorProbes:
			if _, ok := path.(*SearchProbesResponse_FieldTerminalPath); ok {
				for _, subpath := range probe.FullProbe_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchProbesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*SearchProbesResponse_FieldSubPath); ok {
				selectedMask := &probe.Probe_FieldMask{
					Paths: []probe.Probe_FieldPath{sub.subPath.(probe.Probe_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchProbesResponse_FieldSubPath{selector: SearchProbesResponse_FieldPathSelectorProbes, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchProbesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchProbesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchProbesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchProbesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchProbesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchProbesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchProbesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchProbesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchProbesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchProbesResponse_FieldMask) AppendPath(path SearchProbesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchProbesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchProbesResponse_FieldPath))
}

func (fieldMask *SearchProbesResponse_FieldMask) GetPaths() []SearchProbesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchProbesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchProbesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchProbesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchProbesResponse_FieldMask) Set(target, source *SearchProbesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchProbesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchProbesResponse), source.(*SearchProbesResponse))
}

func (fieldMask *SearchProbesResponse_FieldMask) Project(source *SearchProbesResponse) *SearchProbesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchProbesResponse{}
	probesMask := &probe.Probe_FieldMask{}
	wholeProbesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchProbesResponse_FieldTerminalPath:
			switch tp.selector {
			case SearchProbesResponse_FieldPathSelectorProbes:
				result.Probes = source.Probes
				wholeProbesAccepted = true
			case SearchProbesResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case SearchProbesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case SearchProbesResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case SearchProbesResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *SearchProbesResponse_FieldSubPath:
			switch tp.selector {
			case SearchProbesResponse_FieldPathSelectorProbes:
				probesMask.AppendPath(tp.subPath.(probe.Probe_FieldPath))
			}
		}
	}
	if wholeProbesAccepted == false && len(probesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbes() {
			result.Probes = append(result.Probes, probesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *SearchProbesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchProbesResponse))
}

func (fieldMask *SearchProbesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
