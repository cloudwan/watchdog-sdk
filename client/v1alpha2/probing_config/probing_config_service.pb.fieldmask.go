// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/probing_config_service.proto
// DO NOT EDIT!!!

package probing_config_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	probing_config "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/probing_config"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/project"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &probing_config.ProbingConfig{}
	_ = &project.Project{}
)

type GetProbingConfigRequest_FieldMask struct {
	Paths []GetProbingConfigRequest_FieldPath
}

func FullGetProbingConfigRequest_FieldMask() *GetProbingConfigRequest_FieldMask {
	res := &GetProbingConfigRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProbingConfigRequest_FieldTerminalPath{selector: GetProbingConfigRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProbingConfigRequest_FieldTerminalPath{selector: GetProbingConfigRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProbingConfigRequest_FieldTerminalPath{selector: GetProbingConfigRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProbingConfigRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProbingConfigRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProbingConfigRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProbingConfigRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProbingConfigRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProbingConfigRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProbingConfigRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProbingConfigRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProbingConfigRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProbingConfigRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProbingConfigRequest_FieldMask) Subtract(other *GetProbingConfigRequest_FieldMask) *GetProbingConfigRequest_FieldMask {
	result := &GetProbingConfigRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProbingConfigRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProbingConfigRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProbingConfigRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProbingConfigRequest_FieldMask) FilterInputFields() *GetProbingConfigRequest_FieldMask {
	result := &GetProbingConfigRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProbingConfigRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProbingConfigRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProbingConfigRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProbingConfigRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProbingConfigRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProbingConfigRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingConfigRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProbingConfigRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProbingConfigRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingConfigRequest_FieldMask) AppendPath(path GetProbingConfigRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProbingConfigRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProbingConfigRequest_FieldPath))
}

func (fieldMask *GetProbingConfigRequest_FieldMask) GetPaths() []GetProbingConfigRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProbingConfigRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProbingConfigRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProbingConfigRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProbingConfigRequest_FieldMask) Set(target, source *GetProbingConfigRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProbingConfigRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProbingConfigRequest), source.(*GetProbingConfigRequest))
}

func (fieldMask *GetProbingConfigRequest_FieldMask) Project(source *GetProbingConfigRequest) *GetProbingConfigRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProbingConfigRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProbingConfigRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProbingConfigRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProbingConfigRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProbingConfigRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProbingConfigRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProbingConfigRequest))
}

func (fieldMask *GetProbingConfigRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingConfigsRequest_FieldMask struct {
	Paths []BatchGetProbingConfigsRequest_FieldPath
}

func FullBatchGetProbingConfigsRequest_FieldMask() *BatchGetProbingConfigsRequest_FieldMask {
	res := &BatchGetProbingConfigsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingConfigsRequest_FieldTerminalPath{selector: BatchGetProbingConfigsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProbingConfigsRequest_FieldTerminalPath{selector: BatchGetProbingConfigsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProbingConfigsRequest_FieldTerminalPath{selector: BatchGetProbingConfigsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingConfigsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingConfigsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingConfigsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Subtract(other *BatchGetProbingConfigsRequest_FieldMask) *BatchGetProbingConfigsRequest_FieldMask {
	result := &BatchGetProbingConfigsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingConfigsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingConfigsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) FilterInputFields() *BatchGetProbingConfigsRequest_FieldMask {
	result := &BatchGetProbingConfigsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingConfigsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingConfigsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingConfigsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingConfigsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) AppendPath(path BatchGetProbingConfigsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingConfigsRequest_FieldPath))
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) GetPaths() []BatchGetProbingConfigsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingConfigsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Set(target, source *BatchGetProbingConfigsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingConfigsRequest), source.(*BatchGetProbingConfigsRequest))
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) Project(source *BatchGetProbingConfigsRequest) *BatchGetProbingConfigsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingConfigsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingConfigsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingConfigsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProbingConfigsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProbingConfigsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingConfigsRequest))
}

func (fieldMask *BatchGetProbingConfigsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingConfigsResponse_FieldMask struct {
	Paths []BatchGetProbingConfigsResponse_FieldPath
}

func FullBatchGetProbingConfigsResponse_FieldMask() *BatchGetProbingConfigsResponse_FieldMask {
	res := &BatchGetProbingConfigsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingConfigsResponse_FieldTerminalPath{selector: BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs})
	res.Paths = append(res.Paths, &BatchGetProbingConfigsResponse_FieldTerminalPath{selector: BatchGetProbingConfigsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingConfigsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingConfigsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingConfigsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Subtract(other *BatchGetProbingConfigsResponse_FieldMask) *BatchGetProbingConfigsResponse_FieldMask {
	result := &BatchGetProbingConfigsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs: &probing_config.ProbingConfig_FieldMask{},
	}
	mySubMasks := map[BatchGetProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs: &probing_config.ProbingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingConfigsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProbingConfigsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProbingConfigsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs:
						mySubMasks[BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs] = probing_config.FullProbingConfig_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProbingConfigsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProbingConfigsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingConfigsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) FilterInputFields() *BatchGetProbingConfigsResponse_FieldMask {
	result := &BatchGetProbingConfigsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs:
			if _, ok := path.(*BatchGetProbingConfigsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_config.FullProbingConfig_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingConfigsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProbingConfigsResponse_FieldSubPath); ok {
				selectedMask := &probing_config.ProbingConfig_FieldMask{
					Paths: []probing_config.ProbingConfig_FieldPath{sub.subPath.(probing_config.ProbingConfig_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingConfigsResponse_FieldSubPath{selector: BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingConfigsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingConfigsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingConfigsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingConfigsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) AppendPath(path BatchGetProbingConfigsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingConfigsResponse_FieldPath))
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) GetPaths() []BatchGetProbingConfigsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingConfigsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Set(target, source *BatchGetProbingConfigsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingConfigsResponse), source.(*BatchGetProbingConfigsResponse))
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) Project(source *BatchGetProbingConfigsResponse) *BatchGetProbingConfigsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingConfigsResponse{}
	probingConfigsMask := &probing_config.ProbingConfig_FieldMask{}
	wholeProbingConfigsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingConfigsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs:
				result.ProbingConfigs = source.ProbingConfigs
				wholeProbingConfigsAccepted = true
			case BatchGetProbingConfigsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProbingConfigsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProbingConfigsResponse_FieldPathSelectorProbingConfigs:
				probingConfigsMask.AppendPath(tp.subPath.(probing_config.ProbingConfig_FieldPath))
			}
		}
	}
	if wholeProbingConfigsAccepted == false && len(probingConfigsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingConfigs() {
			result.ProbingConfigs = append(result.ProbingConfigs, probingConfigsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingConfigsResponse))
}

func (fieldMask *BatchGetProbingConfigsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingConfigsRequest_FieldMask struct {
	Paths []ListProbingConfigsRequest_FieldPath
}

func FullListProbingConfigsRequest_FieldMask() *ListProbingConfigsRequest_FieldMask {
	res := &ListProbingConfigsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListProbingConfigsRequest_FieldTerminalPath{selector: ListProbingConfigsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingConfigsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingConfigsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingConfigsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingConfigsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Subtract(other *ListProbingConfigsRequest_FieldMask) *ListProbingConfigsRequest_FieldMask {
	result := &ListProbingConfigsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingConfigsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingConfigsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingConfigsRequest_FieldMask) FilterInputFields() *ListProbingConfigsRequest_FieldMask {
	result := &ListProbingConfigsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingConfigsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingConfigsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingConfigsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingConfigsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingConfigsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) AppendPath(path ListProbingConfigsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingConfigsRequest_FieldPath))
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) GetPaths() []ListProbingConfigsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingConfigsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Set(target, source *ListProbingConfigsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingConfigsRequest), source.(*ListProbingConfigsRequest))
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) Project(source *ListProbingConfigsRequest) *ListProbingConfigsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingConfigsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingConfigsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProbingConfigsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProbingConfigsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProbingConfigsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProbingConfigsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProbingConfigsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProbingConfigsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProbingConfigsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListProbingConfigsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingConfigsRequest))
}

func (fieldMask *ListProbingConfigsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingConfigsResponse_FieldMask struct {
	Paths []ListProbingConfigsResponse_FieldPath
}

func FullListProbingConfigsResponse_FieldMask() *ListProbingConfigsResponse_FieldMask {
	res := &ListProbingConfigsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingConfigsResponse_FieldTerminalPath{selector: ListProbingConfigsResponse_FieldPathSelectorProbingConfigs})
	res.Paths = append(res.Paths, &ListProbingConfigsResponse_FieldTerminalPath{selector: ListProbingConfigsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProbingConfigsResponse_FieldTerminalPath{selector: ListProbingConfigsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListProbingConfigsResponse_FieldTerminalPath{selector: ListProbingConfigsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListProbingConfigsResponse_FieldTerminalPath{selector: ListProbingConfigsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingConfigsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingConfigsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingConfigsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingConfigsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Subtract(other *ListProbingConfigsResponse_FieldMask) *ListProbingConfigsResponse_FieldMask {
	result := &ListProbingConfigsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingConfigsResponse_FieldPathSelectorProbingConfigs: &probing_config.ProbingConfig_FieldMask{},
	}
	mySubMasks := map[ListProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingConfigsResponse_FieldPathSelectorProbingConfigs: &probing_config.ProbingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingConfigsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProbingConfigsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProbingConfigsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProbingConfigsResponse_FieldPathSelectorProbingConfigs:
						mySubMasks[ListProbingConfigsResponse_FieldPathSelectorProbingConfigs] = probing_config.FullProbingConfig_FieldMask()
					}
				} else if tp, ok := path.(*ListProbingConfigsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProbingConfigsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingConfigsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingConfigsResponse_FieldMask) FilterInputFields() *ListProbingConfigsResponse_FieldMask {
	result := &ListProbingConfigsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProbingConfigsResponse_FieldPathSelectorProbingConfigs:
			if _, ok := path.(*ListProbingConfigsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_config.FullProbingConfig_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingConfigsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProbingConfigsResponse_FieldSubPath); ok {
				selectedMask := &probing_config.ProbingConfig_FieldMask{
					Paths: []probing_config.ProbingConfig_FieldPath{sub.subPath.(probing_config.ProbingConfig_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingConfigsResponse_FieldSubPath{selector: ListProbingConfigsResponse_FieldPathSelectorProbingConfigs, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingConfigsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingConfigsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingConfigsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingConfigsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingConfigsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) AppendPath(path ListProbingConfigsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingConfigsResponse_FieldPath))
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) GetPaths() []ListProbingConfigsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingConfigsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Set(target, source *ListProbingConfigsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingConfigsResponse), source.(*ListProbingConfigsResponse))
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) Project(source *ListProbingConfigsResponse) *ListProbingConfigsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingConfigsResponse{}
	probingConfigsMask := &probing_config.ProbingConfig_FieldMask{}
	wholeProbingConfigsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingConfigsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProbingConfigsResponse_FieldPathSelectorProbingConfigs:
				result.ProbingConfigs = source.ProbingConfigs
				wholeProbingConfigsAccepted = true
			case ListProbingConfigsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProbingConfigsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListProbingConfigsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListProbingConfigsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListProbingConfigsResponse_FieldSubPath:
			switch tp.selector {
			case ListProbingConfigsResponse_FieldPathSelectorProbingConfigs:
				probingConfigsMask.AppendPath(tp.subPath.(probing_config.ProbingConfig_FieldPath))
			}
		}
	}
	if wholeProbingConfigsAccepted == false && len(probingConfigsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingConfigs() {
			result.ProbingConfigs = append(result.ProbingConfigs, probingConfigsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingConfigsResponse))
}

func (fieldMask *ListProbingConfigsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingConfigRequest_FieldMask struct {
	Paths []WatchProbingConfigRequest_FieldPath
}

func FullWatchProbingConfigRequest_FieldMask() *WatchProbingConfigRequest_FieldMask {
	res := &WatchProbingConfigRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingConfigRequest_FieldTerminalPath{selector: WatchProbingConfigRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProbingConfigRequest_FieldTerminalPath{selector: WatchProbingConfigRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingConfigRequest_FieldTerminalPath{selector: WatchProbingConfigRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingConfigRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingConfigRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingConfigRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingConfigRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Subtract(other *WatchProbingConfigRequest_FieldMask) *WatchProbingConfigRequest_FieldMask {
	result := &WatchProbingConfigRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingConfigRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingConfigRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingConfigRequest_FieldMask) FilterInputFields() *WatchProbingConfigRequest_FieldMask {
	result := &WatchProbingConfigRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingConfigRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingConfigRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingConfigRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingConfigRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingConfigRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) AppendPath(path WatchProbingConfigRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingConfigRequest_FieldPath))
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) GetPaths() []WatchProbingConfigRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingConfigRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Set(target, source *WatchProbingConfigRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingConfigRequest), source.(*WatchProbingConfigRequest))
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) Project(source *WatchProbingConfigRequest) *WatchProbingConfigRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingConfigRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingConfigRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingConfigRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProbingConfigRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingConfigRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingConfigRequest))
}

func (fieldMask *WatchProbingConfigRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingConfigResponse_FieldMask struct {
	Paths []WatchProbingConfigResponse_FieldPath
}

func FullWatchProbingConfigResponse_FieldMask() *WatchProbingConfigResponse_FieldMask {
	res := &WatchProbingConfigResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingConfigResponse_FieldTerminalPath{selector: WatchProbingConfigResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingConfigResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingConfigResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingConfigResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingConfigResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Subtract(other *WatchProbingConfigResponse_FieldMask) *WatchProbingConfigResponse_FieldMask {
	result := &WatchProbingConfigResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingConfigResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingConfigResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingConfigResponse_FieldMask) FilterInputFields() *WatchProbingConfigResponse_FieldMask {
	result := &WatchProbingConfigResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingConfigResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingConfigResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingConfigResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingConfigResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingConfigResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) AppendPath(path WatchProbingConfigResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingConfigResponse_FieldPath))
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) GetPaths() []WatchProbingConfigResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingConfigResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Set(target, source *WatchProbingConfigResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingConfigResponse), source.(*WatchProbingConfigResponse))
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) Project(source *WatchProbingConfigResponse) *WatchProbingConfigResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingConfigResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingConfigResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingConfigResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingConfigResponse))
}

func (fieldMask *WatchProbingConfigResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingConfigsRequest_FieldMask struct {
	Paths []WatchProbingConfigsRequest_FieldPath
}

func FullWatchProbingConfigsRequest_FieldMask() *WatchProbingConfigsRequest_FieldMask {
	res := &WatchProbingConfigsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProbingConfigsRequest_FieldTerminalPath{selector: WatchProbingConfigsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingConfigsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingConfigsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingConfigsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingConfigsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Subtract(other *WatchProbingConfigsRequest_FieldMask) *WatchProbingConfigsRequest_FieldMask {
	result := &WatchProbingConfigsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingConfigsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingConfigsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingConfigsRequest_FieldMask) FilterInputFields() *WatchProbingConfigsRequest_FieldMask {
	result := &WatchProbingConfigsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingConfigsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingConfigsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingConfigsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingConfigsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingConfigsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) AppendPath(path WatchProbingConfigsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingConfigsRequest_FieldPath))
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) GetPaths() []WatchProbingConfigsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingConfigsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Set(target, source *WatchProbingConfigsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingConfigsRequest), source.(*WatchProbingConfigsRequest))
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) Project(source *WatchProbingConfigsRequest) *WatchProbingConfigsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingConfigsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingConfigsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingConfigsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProbingConfigsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProbingConfigsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProbingConfigsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProbingConfigsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProbingConfigsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingConfigsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchProbingConfigsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProbingConfigsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingConfigsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProbingConfigsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingConfigsRequest))
}

func (fieldMask *WatchProbingConfigsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingConfigsResponse_FieldMask struct {
	Paths []WatchProbingConfigsResponse_FieldPath
}

func FullWatchProbingConfigsResponse_FieldMask() *WatchProbingConfigsResponse_FieldMask {
	res := &WatchProbingConfigsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorProbingConfigChanges})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponse_FieldTerminalPath{selector: WatchProbingConfigsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingConfigsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingConfigsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingConfigsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingConfigsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Subtract(other *WatchProbingConfigsResponse_FieldMask) *WatchProbingConfigsResponse_FieldMask {
	result := &WatchProbingConfigsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange: &WatchProbingConfigsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProbingConfigsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange: &WatchProbingConfigsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingConfigsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProbingConfigsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProbingConfigsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange] = FullWatchProbingConfigsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProbingConfigsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProbingConfigsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingConfigsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingConfigsResponse_FieldMask) FilterInputFields() *WatchProbingConfigsResponse_FieldMask {
	result := &WatchProbingConfigsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingConfigsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingConfigsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingConfigsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingConfigsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingConfigsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) AppendPath(path WatchProbingConfigsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingConfigsResponse_FieldPath))
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) GetPaths() []WatchProbingConfigsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingConfigsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Set(target, source *WatchProbingConfigsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingConfigsResponse), source.(*WatchProbingConfigsResponse))
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) Project(source *WatchProbingConfigsResponse) *WatchProbingConfigsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingConfigsResponse{}
	pageTokenChangeMask := &WatchProbingConfigsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingConfigsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingConfigsResponse_FieldPathSelectorProbingConfigChanges:
				result.ProbingConfigChanges = source.ProbingConfigChanges
			case WatchProbingConfigsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProbingConfigsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingConfigsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProbingConfigsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProbingConfigsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProbingConfigsResponse_FieldSubPath:
			switch tp.selector {
			case WatchProbingConfigsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProbingConfigsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingConfigsResponse))
}

func (fieldMask *WatchProbingConfigsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingConfigsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProbingConfigsResponsePageTokenChange_FieldPath
}

func FullWatchProbingConfigsResponse_PageTokenChange_FieldMask() *WatchProbingConfigsResponse_PageTokenChange_FieldMask {
	res := &WatchProbingConfigsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingConfigsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingConfigsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProbingConfigsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingConfigsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingConfigsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingConfigsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingConfigsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Subtract(other *WatchProbingConfigsResponse_PageTokenChange_FieldMask) *WatchProbingConfigsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingConfigsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingConfigsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingConfigsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProbingConfigsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingConfigsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingConfigsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingConfigsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingConfigsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingConfigsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) AppendPath(path WatchProbingConfigsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingConfigsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) GetPaths() []WatchProbingConfigsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingConfigsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Set(target, source *WatchProbingConfigsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingConfigsResponse_PageTokenChange), source.(*WatchProbingConfigsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) Project(source *WatchProbingConfigsResponse_PageTokenChange) *WatchProbingConfigsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingConfigsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingConfigsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingConfigsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProbingConfigsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingConfigsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingConfigsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProbingConfigRequest_FieldMask struct {
	Paths []CreateProbingConfigRequest_FieldPath
}

func FullCreateProbingConfigRequest_FieldMask() *CreateProbingConfigRequest_FieldMask {
	res := &CreateProbingConfigRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProbingConfigRequest_FieldTerminalPath{selector: CreateProbingConfigRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProbingConfigRequest_FieldTerminalPath{selector: CreateProbingConfigRequest_FieldPathSelectorProbingConfig})
	return res
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProbingConfigRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProbingConfigRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProbingConfigRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProbingConfigRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Subtract(other *CreateProbingConfigRequest_FieldMask) *CreateProbingConfigRequest_FieldMask {
	result := &CreateProbingConfigRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProbingConfigRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingConfigRequest_FieldPathSelectorProbingConfig: &probing_config.ProbingConfig_FieldMask{},
	}
	mySubMasks := map[CreateProbingConfigRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingConfigRequest_FieldPathSelectorProbingConfig: &probing_config.ProbingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProbingConfigRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProbingConfigRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProbingConfigRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProbingConfigRequest_FieldPathSelectorProbingConfig:
						mySubMasks[CreateProbingConfigRequest_FieldPathSelectorProbingConfig] = probing_config.FullProbingConfig_FieldMask()
					}
				} else if tp, ok := path.(*CreateProbingConfigRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProbingConfigRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProbingConfigRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProbingConfigRequest_FieldMask) FilterInputFields() *CreateProbingConfigRequest_FieldMask {
	result := &CreateProbingConfigRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProbingConfigRequest_FieldPathSelectorProbingConfig:
			if _, ok := path.(*CreateProbingConfigRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_config.FullProbingConfig_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingConfigRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProbingConfigRequest_FieldSubPath); ok {
				selectedMask := &probing_config.ProbingConfig_FieldMask{
					Paths: []probing_config.ProbingConfig_FieldPath{sub.subPath.(probing_config.ProbingConfig_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingConfigRequest_FieldSubPath{selector: CreateProbingConfigRequest_FieldPathSelectorProbingConfig, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProbingConfigRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProbingConfigRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProbingConfigRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProbingConfigRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProbingConfigRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) AppendPath(path CreateProbingConfigRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProbingConfigRequest_FieldPath))
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) GetPaths() []CreateProbingConfigRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProbingConfigRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Set(target, source *CreateProbingConfigRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProbingConfigRequest), source.(*CreateProbingConfigRequest))
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) Project(source *CreateProbingConfigRequest) *CreateProbingConfigRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProbingConfigRequest{}
	probingConfigMask := &probing_config.ProbingConfig_FieldMask{}
	wholeProbingConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProbingConfigRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProbingConfigRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProbingConfigRequest_FieldPathSelectorProbingConfig:
				result.ProbingConfig = source.ProbingConfig
				wholeProbingConfigAccepted = true
			}
		case *CreateProbingConfigRequest_FieldSubPath:
			switch tp.selector {
			case CreateProbingConfigRequest_FieldPathSelectorProbingConfig:
				probingConfigMask.AppendPath(tp.subPath.(probing_config.ProbingConfig_FieldPath))
			}
		}
	}
	if wholeProbingConfigAccepted == false && len(probingConfigMask.Paths) > 0 {
		result.ProbingConfig = probingConfigMask.Project(source.GetProbingConfig())
	}
	return result
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProbingConfigRequest))
}

func (fieldMask *CreateProbingConfigRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingConfigRequest_FieldMask struct {
	Paths []UpdateProbingConfigRequest_FieldPath
}

func FullUpdateProbingConfigRequest_FieldMask() *UpdateProbingConfigRequest_FieldMask {
	res := &UpdateProbingConfigRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingConfigRequest_FieldTerminalPath{selector: UpdateProbingConfigRequest_FieldPathSelectorProbingConfig})
	res.Paths = append(res.Paths, &UpdateProbingConfigRequest_FieldTerminalPath{selector: UpdateProbingConfigRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProbingConfigRequest_FieldTerminalPath{selector: UpdateProbingConfigRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingConfigRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingConfigRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingConfigRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingConfigRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Subtract(other *UpdateProbingConfigRequest_FieldMask) *UpdateProbingConfigRequest_FieldMask {
	result := &UpdateProbingConfigRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProbingConfigRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingConfigRequest_FieldPathSelectorProbingConfig: &probing_config.ProbingConfig_FieldMask{},
		UpdateProbingConfigRequest_FieldPathSelectorCas:           &UpdateProbingConfigRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProbingConfigRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingConfigRequest_FieldPathSelectorProbingConfig: &probing_config.ProbingConfig_FieldMask{},
		UpdateProbingConfigRequest_FieldPathSelectorCas:           &UpdateProbingConfigRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingConfigRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingConfigRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingConfigRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingConfigRequest_FieldPathSelectorProbingConfig:
						mySubMasks[UpdateProbingConfigRequest_FieldPathSelectorProbingConfig] = probing_config.FullProbingConfig_FieldMask()
					case UpdateProbingConfigRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProbingConfigRequest_FieldPathSelectorCas] = FullUpdateProbingConfigRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingConfigRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingConfigRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingConfigRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingConfigRequest_FieldMask) FilterInputFields() *UpdateProbingConfigRequest_FieldMask {
	result := &UpdateProbingConfigRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingConfigRequest_FieldPathSelectorProbingConfig:
			if _, ok := path.(*UpdateProbingConfigRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_config.FullProbingConfig_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingConfigRequest_FieldSubPath); ok {
				selectedMask := &probing_config.ProbingConfig_FieldMask{
					Paths: []probing_config.ProbingConfig_FieldPath{sub.subPath.(probing_config.ProbingConfig_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequest_FieldSubPath{selector: UpdateProbingConfigRequest_FieldPathSelectorProbingConfig, subPath: allowedPath})
				}
			}
		case UpdateProbingConfigRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProbingConfigRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProbingConfigRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingConfigRequest_FieldSubPath); ok {
				selectedMask := &UpdateProbingConfigRequest_CAS_FieldMask{
					Paths: []UpdateProbingConfigRequestCAS_FieldPath{sub.subPath.(UpdateProbingConfigRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequest_FieldSubPath{selector: UpdateProbingConfigRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingConfigRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingConfigRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingConfigRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingConfigRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingConfigRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) AppendPath(path UpdateProbingConfigRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingConfigRequest_FieldPath))
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) GetPaths() []UpdateProbingConfigRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingConfigRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Set(target, source *UpdateProbingConfigRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingConfigRequest), source.(*UpdateProbingConfigRequest))
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) Project(source *UpdateProbingConfigRequest) *UpdateProbingConfigRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingConfigRequest{}
	probingConfigMask := &probing_config.ProbingConfig_FieldMask{}
	wholeProbingConfigAccepted := false
	casMask := &UpdateProbingConfigRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingConfigRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingConfigRequest_FieldPathSelectorProbingConfig:
				result.ProbingConfig = source.ProbingConfig
				wholeProbingConfigAccepted = true
			case UpdateProbingConfigRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProbingConfigRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProbingConfigRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProbingConfigRequest_FieldPathSelectorProbingConfig:
				probingConfigMask.AppendPath(tp.subPath.(probing_config.ProbingConfig_FieldPath))
			case UpdateProbingConfigRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProbingConfigRequestCAS_FieldPath))
			}
		}
	}
	if wholeProbingConfigAccepted == false && len(probingConfigMask.Paths) > 0 {
		result.ProbingConfig = probingConfigMask.Project(source.GetProbingConfig())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingConfigRequest))
}

func (fieldMask *UpdateProbingConfigRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingConfigRequest_CAS_FieldMask struct {
	Paths []UpdateProbingConfigRequestCAS_FieldPath
}

func FullUpdateProbingConfigRequest_CAS_FieldMask() *UpdateProbingConfigRequest_CAS_FieldMask {
	res := &UpdateProbingConfigRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingConfigRequestCAS_FieldTerminalPath{selector: UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProbingConfigRequestCAS_FieldTerminalPath{selector: UpdateProbingConfigRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingConfigRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingConfigRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingConfigRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Subtract(other *UpdateProbingConfigRequest_CAS_FieldMask) *UpdateProbingConfigRequest_CAS_FieldMask {
	result := &UpdateProbingConfigRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProbingConfigRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState: &probing_config.ProbingConfig_FieldMask{},
	}
	mySubMasks := map[UpdateProbingConfigRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState: &probing_config.ProbingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingConfigRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingConfigRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingConfigRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState] = probing_config.FullProbingConfig_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingConfigRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingConfigRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingConfigRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) FilterInputFields() *UpdateProbingConfigRequest_CAS_FieldMask {
	result := &UpdateProbingConfigRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProbingConfigRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range probing_config.FullProbingConfig_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingConfigRequestCAS_FieldSubPath); ok {
				selectedMask := &probing_config.ProbingConfig_FieldMask{
					Paths: []probing_config.ProbingConfig_FieldPath{sub.subPath.(probing_config.ProbingConfig_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingConfigRequestCAS_FieldSubPath{selector: UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingConfigRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingConfigRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingConfigRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingConfigRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) AppendPath(path UpdateProbingConfigRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingConfigRequestCAS_FieldPath))
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) GetPaths() []UpdateProbingConfigRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingConfigRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Set(target, source *UpdateProbingConfigRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingConfigRequest_CAS), source.(*UpdateProbingConfigRequest_CAS))
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) Project(source *UpdateProbingConfigRequest_CAS) *UpdateProbingConfigRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingConfigRequest_CAS{}
	conditionalStateMask := &probing_config.ProbingConfig_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingConfigRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProbingConfigRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProbingConfigRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProbingConfigRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(probing_config.ProbingConfig_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingConfigRequest_CAS))
}

func (fieldMask *UpdateProbingConfigRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProbingConfigRequest_FieldMask struct {
	Paths []DeleteProbingConfigRequest_FieldPath
}

func FullDeleteProbingConfigRequest_FieldMask() *DeleteProbingConfigRequest_FieldMask {
	res := &DeleteProbingConfigRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProbingConfigRequest_FieldTerminalPath{selector: DeleteProbingConfigRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProbingConfigRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProbingConfigRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProbingConfigRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProbingConfigRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Subtract(other *DeleteProbingConfigRequest_FieldMask) *DeleteProbingConfigRequest_FieldMask {
	result := &DeleteProbingConfigRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProbingConfigRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProbingConfigRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProbingConfigRequest_FieldMask) FilterInputFields() *DeleteProbingConfigRequest_FieldMask {
	result := &DeleteProbingConfigRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProbingConfigRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProbingConfigRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProbingConfigRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProbingConfigRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProbingConfigRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) AppendPath(path DeleteProbingConfigRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProbingConfigRequest_FieldPath))
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) GetPaths() []DeleteProbingConfigRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProbingConfigRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Set(target, source *DeleteProbingConfigRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProbingConfigRequest), source.(*DeleteProbingConfigRequest))
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) Project(source *DeleteProbingConfigRequest) *DeleteProbingConfigRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProbingConfigRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProbingConfigRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProbingConfigRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProbingConfigRequest))
}

func (fieldMask *DeleteProbingConfigRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
