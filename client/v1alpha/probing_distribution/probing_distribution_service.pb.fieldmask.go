// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha/probing_distribution_service.proto
// DO NOT EDIT!!!

package probing_distribution_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	probing_distribution "github.com/cloudwan/watchdog-sdk/resources/v1alpha/probing_distribution"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha/project"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &probing_distribution.ProbingDistribution{}
	_ = &project.Project{}
)

type GetProbingDistributionRequest_FieldMask struct {
	Paths []GetProbingDistributionRequest_FieldPath
}

func FullGetProbingDistributionRequest_FieldMask() *GetProbingDistributionRequest_FieldMask {
	res := &GetProbingDistributionRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProbingDistributionRequest_FieldTerminalPath{selector: GetProbingDistributionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProbingDistributionRequest_FieldTerminalPath{selector: GetProbingDistributionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProbingDistributionRequest_FieldTerminalPath{selector: GetProbingDistributionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProbingDistributionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProbingDistributionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProbingDistributionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProbingDistributionRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Subtract(other *GetProbingDistributionRequest_FieldMask) *GetProbingDistributionRequest_FieldMask {
	result := &GetProbingDistributionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProbingDistributionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProbingDistributionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProbingDistributionRequest_FieldMask) FilterInputFields() *GetProbingDistributionRequest_FieldMask {
	result := &GetProbingDistributionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProbingDistributionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProbingDistributionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProbingDistributionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProbingDistributionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProbingDistributionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) AppendPath(path GetProbingDistributionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProbingDistributionRequest_FieldPath))
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) GetPaths() []GetProbingDistributionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProbingDistributionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Set(target, source *GetProbingDistributionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProbingDistributionRequest), source.(*GetProbingDistributionRequest))
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) Project(source *GetProbingDistributionRequest) *GetProbingDistributionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProbingDistributionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProbingDistributionRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProbingDistributionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProbingDistributionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProbingDistributionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProbingDistributionRequest))
}

func (fieldMask *GetProbingDistributionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingDistributionsRequest_FieldMask struct {
	Paths []BatchGetProbingDistributionsRequest_FieldPath
}

func FullBatchGetProbingDistributionsRequest_FieldMask() *BatchGetProbingDistributionsRequest_FieldMask {
	res := &BatchGetProbingDistributionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsRequest_FieldTerminalPath{selector: BatchGetProbingDistributionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsRequest_FieldTerminalPath{selector: BatchGetProbingDistributionsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsRequest_FieldTerminalPath{selector: BatchGetProbingDistributionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsRequest_FieldTerminalPath{selector: BatchGetProbingDistributionsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingDistributionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingDistributionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingDistributionsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Subtract(other *BatchGetProbingDistributionsRequest_FieldMask) *BatchGetProbingDistributionsRequest_FieldMask {
	result := &BatchGetProbingDistributionsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingDistributionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingDistributionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) FilterInputFields() *BatchGetProbingDistributionsRequest_FieldMask {
	result := &BatchGetProbingDistributionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingDistributionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingDistributionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingDistributionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingDistributionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) AppendPath(path BatchGetProbingDistributionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingDistributionsRequest_FieldPath))
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) GetPaths() []BatchGetProbingDistributionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingDistributionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Set(target, source *BatchGetProbingDistributionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingDistributionsRequest), source.(*BatchGetProbingDistributionsRequest))
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) Project(source *BatchGetProbingDistributionsRequest) *BatchGetProbingDistributionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingDistributionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingDistributionsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingDistributionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetProbingDistributionsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProbingDistributionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProbingDistributionsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingDistributionsRequest))
}

func (fieldMask *BatchGetProbingDistributionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingDistributionsResponse_FieldMask struct {
	Paths []BatchGetProbingDistributionsResponse_FieldPath
}

func FullBatchGetProbingDistributionsResponse_FieldMask() *BatchGetProbingDistributionsResponse_FieldMask {
	res := &BatchGetProbingDistributionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsResponse_FieldTerminalPath{selector: BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions})
	res.Paths = append(res.Paths, &BatchGetProbingDistributionsResponse_FieldTerminalPath{selector: BatchGetProbingDistributionsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingDistributionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingDistributionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingDistributionsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Subtract(other *BatchGetProbingDistributionsResponse_FieldMask) *BatchGetProbingDistributionsResponse_FieldMask {
	result := &BatchGetProbingDistributionsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions: &probing_distribution.ProbingDistribution_FieldMask{},
	}
	mySubMasks := map[BatchGetProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions: &probing_distribution.ProbingDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingDistributionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProbingDistributionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProbingDistributionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
						mySubMasks[BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions] = probing_distribution.FullProbingDistribution_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProbingDistributionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProbingDistributionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingDistributionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) FilterInputFields() *BatchGetProbingDistributionsResponse_FieldMask {
	result := &BatchGetProbingDistributionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
			if _, ok := path.(*BatchGetProbingDistributionsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_distribution.FullProbingDistribution_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingDistributionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProbingDistributionsResponse_FieldSubPath); ok {
				selectedMask := &probing_distribution.ProbingDistribution_FieldMask{
					Paths: []probing_distribution.ProbingDistribution_FieldPath{sub.subPath.(probing_distribution.ProbingDistribution_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingDistributionsResponse_FieldSubPath{selector: BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingDistributionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingDistributionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingDistributionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingDistributionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) AppendPath(path BatchGetProbingDistributionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingDistributionsResponse_FieldPath))
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) GetPaths() []BatchGetProbingDistributionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingDistributionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Set(target, source *BatchGetProbingDistributionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingDistributionsResponse), source.(*BatchGetProbingDistributionsResponse))
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) Project(source *BatchGetProbingDistributionsResponse) *BatchGetProbingDistributionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingDistributionsResponse{}
	probingDistributionsMask := &probing_distribution.ProbingDistribution_FieldMask{}
	wholeProbingDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingDistributionsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
				result.ProbingDistributions = source.ProbingDistributions
				wholeProbingDistributionsAccepted = true
			case BatchGetProbingDistributionsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProbingDistributionsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
				probingDistributionsMask.AppendPath(tp.subPath.(probing_distribution.ProbingDistribution_FieldPath))
			}
		}
	}
	if wholeProbingDistributionsAccepted == false && len(probingDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingDistributions() {
			result.ProbingDistributions = append(result.ProbingDistributions, probingDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingDistributionsResponse))
}

func (fieldMask *BatchGetProbingDistributionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingDistributionsRequest_FieldMask struct {
	Paths []ListProbingDistributionsRequest_FieldPath
}

func FullListProbingDistributionsRequest_FieldMask() *ListProbingDistributionsRequest_FieldMask {
	res := &ListProbingDistributionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProbingDistributionsRequest_FieldTerminalPath{selector: ListProbingDistributionsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingDistributionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingDistributionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingDistributionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingDistributionsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Subtract(other *ListProbingDistributionsRequest_FieldMask) *ListProbingDistributionsRequest_FieldMask {
	result := &ListProbingDistributionsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingDistributionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingDistributionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingDistributionsRequest_FieldMask) FilterInputFields() *ListProbingDistributionsRequest_FieldMask {
	result := &ListProbingDistributionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingDistributionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingDistributionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingDistributionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingDistributionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingDistributionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) AppendPath(path ListProbingDistributionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingDistributionsRequest_FieldPath))
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) GetPaths() []ListProbingDistributionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingDistributionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Set(target, source *ListProbingDistributionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingDistributionsRequest), source.(*ListProbingDistributionsRequest))
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) Project(source *ListProbingDistributionsRequest) *ListProbingDistributionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingDistributionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingDistributionsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProbingDistributionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProbingDistributionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProbingDistributionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProbingDistributionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProbingDistributionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProbingDistributionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProbingDistributionsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingDistributionsRequest))
}

func (fieldMask *ListProbingDistributionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingDistributionsResponse_FieldMask struct {
	Paths []ListProbingDistributionsResponse_FieldPath
}

func FullListProbingDistributionsResponse_FieldMask() *ListProbingDistributionsResponse_FieldMask {
	res := &ListProbingDistributionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingDistributionsResponse_FieldTerminalPath{selector: ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions})
	res.Paths = append(res.Paths, &ListProbingDistributionsResponse_FieldTerminalPath{selector: ListProbingDistributionsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProbingDistributionsResponse_FieldTerminalPath{selector: ListProbingDistributionsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingDistributionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingDistributionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingDistributionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingDistributionsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Subtract(other *ListProbingDistributionsResponse_FieldMask) *ListProbingDistributionsResponse_FieldMask {
	result := &ListProbingDistributionsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions: &probing_distribution.ProbingDistribution_FieldMask{},
	}
	mySubMasks := map[ListProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions: &probing_distribution.ProbingDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingDistributionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProbingDistributionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProbingDistributionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
						mySubMasks[ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions] = probing_distribution.FullProbingDistribution_FieldMask()
					}
				} else if tp, ok := path.(*ListProbingDistributionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProbingDistributionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingDistributionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingDistributionsResponse_FieldMask) FilterInputFields() *ListProbingDistributionsResponse_FieldMask {
	result := &ListProbingDistributionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
			if _, ok := path.(*ListProbingDistributionsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_distribution.FullProbingDistribution_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingDistributionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProbingDistributionsResponse_FieldSubPath); ok {
				selectedMask := &probing_distribution.ProbingDistribution_FieldMask{
					Paths: []probing_distribution.ProbingDistribution_FieldPath{sub.subPath.(probing_distribution.ProbingDistribution_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingDistributionsResponse_FieldSubPath{selector: ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingDistributionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingDistributionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingDistributionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingDistributionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingDistributionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) AppendPath(path ListProbingDistributionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingDistributionsResponse_FieldPath))
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) GetPaths() []ListProbingDistributionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingDistributionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Set(target, source *ListProbingDistributionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingDistributionsResponse), source.(*ListProbingDistributionsResponse))
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) Project(source *ListProbingDistributionsResponse) *ListProbingDistributionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingDistributionsResponse{}
	probingDistributionsMask := &probing_distribution.ProbingDistribution_FieldMask{}
	wholeProbingDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingDistributionsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
				result.ProbingDistributions = source.ProbingDistributions
				wholeProbingDistributionsAccepted = true
			case ListProbingDistributionsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProbingDistributionsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListProbingDistributionsResponse_FieldSubPath:
			switch tp.selector {
			case ListProbingDistributionsResponse_FieldPathSelectorProbingDistributions:
				probingDistributionsMask.AppendPath(tp.subPath.(probing_distribution.ProbingDistribution_FieldPath))
			}
		}
	}
	if wholeProbingDistributionsAccepted == false && len(probingDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingDistributions() {
			result.ProbingDistributions = append(result.ProbingDistributions, probingDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingDistributionsResponse))
}

func (fieldMask *ListProbingDistributionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingDistributionRequest_FieldMask struct {
	Paths []WatchProbingDistributionRequest_FieldPath
}

func FullWatchProbingDistributionRequest_FieldMask() *WatchProbingDistributionRequest_FieldMask {
	res := &WatchProbingDistributionRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingDistributionRequest_FieldTerminalPath{selector: WatchProbingDistributionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProbingDistributionRequest_FieldTerminalPath{selector: WatchProbingDistributionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingDistributionRequest_FieldTerminalPath{selector: WatchProbingDistributionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingDistributionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingDistributionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingDistributionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingDistributionRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Subtract(other *WatchProbingDistributionRequest_FieldMask) *WatchProbingDistributionRequest_FieldMask {
	result := &WatchProbingDistributionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingDistributionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingDistributionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingDistributionRequest_FieldMask) FilterInputFields() *WatchProbingDistributionRequest_FieldMask {
	result := &WatchProbingDistributionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingDistributionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingDistributionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingDistributionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingDistributionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingDistributionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) AppendPath(path WatchProbingDistributionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingDistributionRequest_FieldPath))
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) GetPaths() []WatchProbingDistributionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingDistributionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Set(target, source *WatchProbingDistributionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingDistributionRequest), source.(*WatchProbingDistributionRequest))
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) Project(source *WatchProbingDistributionRequest) *WatchProbingDistributionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingDistributionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingDistributionRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingDistributionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProbingDistributionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingDistributionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingDistributionRequest))
}

func (fieldMask *WatchProbingDistributionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingDistributionResponse_FieldMask struct {
	Paths []WatchProbingDistributionResponse_FieldPath
}

func FullWatchProbingDistributionResponse_FieldMask() *WatchProbingDistributionResponse_FieldMask {
	res := &WatchProbingDistributionResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingDistributionResponse_FieldTerminalPath{selector: WatchProbingDistributionResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingDistributionResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingDistributionResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingDistributionResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingDistributionResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Subtract(other *WatchProbingDistributionResponse_FieldMask) *WatchProbingDistributionResponse_FieldMask {
	result := &WatchProbingDistributionResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingDistributionResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingDistributionResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingDistributionResponse_FieldMask) FilterInputFields() *WatchProbingDistributionResponse_FieldMask {
	result := &WatchProbingDistributionResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingDistributionResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingDistributionResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingDistributionResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingDistributionResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingDistributionResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) AppendPath(path WatchProbingDistributionResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingDistributionResponse_FieldPath))
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) GetPaths() []WatchProbingDistributionResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingDistributionResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Set(target, source *WatchProbingDistributionResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingDistributionResponse), source.(*WatchProbingDistributionResponse))
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) Project(source *WatchProbingDistributionResponse) *WatchProbingDistributionResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingDistributionResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingDistributionResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingDistributionResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingDistributionResponse))
}

func (fieldMask *WatchProbingDistributionResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingDistributionsRequest_FieldMask struct {
	Paths []WatchProbingDistributionsRequest_FieldPath
}

func FullWatchProbingDistributionsRequest_FieldMask() *WatchProbingDistributionsRequest_FieldMask {
	res := &WatchProbingDistributionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProbingDistributionsRequest_FieldTerminalPath{selector: WatchProbingDistributionsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingDistributionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingDistributionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingDistributionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingDistributionsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Subtract(other *WatchProbingDistributionsRequest_FieldMask) *WatchProbingDistributionsRequest_FieldMask {
	result := &WatchProbingDistributionsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingDistributionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingDistributionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingDistributionsRequest_FieldMask) FilterInputFields() *WatchProbingDistributionsRequest_FieldMask {
	result := &WatchProbingDistributionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingDistributionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingDistributionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingDistributionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingDistributionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingDistributionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) AppendPath(path WatchProbingDistributionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingDistributionsRequest_FieldPath))
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) GetPaths() []WatchProbingDistributionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingDistributionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Set(target, source *WatchProbingDistributionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingDistributionsRequest), source.(*WatchProbingDistributionsRequest))
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) Project(source *WatchProbingDistributionsRequest) *WatchProbingDistributionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingDistributionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingDistributionsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingDistributionsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProbingDistributionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProbingDistributionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProbingDistributionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProbingDistributionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProbingDistributionsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingDistributionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProbingDistributionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingDistributionsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProbingDistributionsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingDistributionsRequest))
}

func (fieldMask *WatchProbingDistributionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingDistributionsResponse_FieldMask struct {
	Paths []WatchProbingDistributionsResponse_FieldPath
}

func FullWatchProbingDistributionsResponse_FieldMask() *WatchProbingDistributionsResponse_FieldMask {
	res := &WatchProbingDistributionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorProbingDistributionChanges})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponse_FieldTerminalPath{selector: WatchProbingDistributionsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingDistributionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingDistributionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingDistributionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingDistributionsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Subtract(other *WatchProbingDistributionsResponse_FieldMask) *WatchProbingDistributionsResponse_FieldMask {
	result := &WatchProbingDistributionsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange: &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProbingDistributionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange: &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingDistributionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProbingDistributionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProbingDistributionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange] = FullWatchProbingDistributionsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProbingDistributionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProbingDistributionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingDistributionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingDistributionsResponse_FieldMask) FilterInputFields() *WatchProbingDistributionsResponse_FieldMask {
	result := &WatchProbingDistributionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingDistributionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingDistributionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingDistributionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingDistributionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingDistributionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) AppendPath(path WatchProbingDistributionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingDistributionsResponse_FieldPath))
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) GetPaths() []WatchProbingDistributionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingDistributionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Set(target, source *WatchProbingDistributionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingDistributionsResponse), source.(*WatchProbingDistributionsResponse))
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) Project(source *WatchProbingDistributionsResponse) *WatchProbingDistributionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingDistributionsResponse{}
	pageTokenChangeMask := &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingDistributionsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingDistributionsResponse_FieldPathSelectorProbingDistributionChanges:
				result.ProbingDistributionChanges = source.ProbingDistributionChanges
			case WatchProbingDistributionsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProbingDistributionsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingDistributionsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProbingDistributionsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProbingDistributionsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProbingDistributionsResponse_FieldSubPath:
			switch tp.selector {
			case WatchProbingDistributionsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProbingDistributionsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingDistributionsResponse))
}

func (fieldMask *WatchProbingDistributionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingDistributionsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProbingDistributionsResponsePageTokenChange_FieldPath
}

func FullWatchProbingDistributionsResponse_PageTokenChange_FieldMask() *WatchProbingDistributionsResponse_PageTokenChange_FieldMask {
	res := &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingDistributionsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProbingDistributionsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingDistributionsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingDistributionsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingDistributionsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingDistributionsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Subtract(other *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) *WatchProbingDistributionsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingDistributionsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingDistributionsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProbingDistributionsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingDistributionsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingDistributionsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingDistributionsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingDistributionsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) AppendPath(path WatchProbingDistributionsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingDistributionsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) GetPaths() []WatchProbingDistributionsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingDistributionsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Set(target, source *WatchProbingDistributionsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingDistributionsResponse_PageTokenChange), source.(*WatchProbingDistributionsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) Project(source *WatchProbingDistributionsResponse_PageTokenChange) *WatchProbingDistributionsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingDistributionsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingDistributionsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingDistributionsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProbingDistributionsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingDistributionsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingDistributionsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProbingDistributionRequest_FieldMask struct {
	Paths []CreateProbingDistributionRequest_FieldPath
}

func FullCreateProbingDistributionRequest_FieldMask() *CreateProbingDistributionRequest_FieldMask {
	res := &CreateProbingDistributionRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProbingDistributionRequest_FieldTerminalPath{selector: CreateProbingDistributionRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProbingDistributionRequest_FieldTerminalPath{selector: CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution})
	return res
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProbingDistributionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProbingDistributionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProbingDistributionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProbingDistributionRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Subtract(other *CreateProbingDistributionRequest_FieldMask) *CreateProbingDistributionRequest_FieldMask {
	result := &CreateProbingDistributionRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProbingDistributionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution: &probing_distribution.ProbingDistribution_FieldMask{},
	}
	mySubMasks := map[CreateProbingDistributionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution: &probing_distribution.ProbingDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProbingDistributionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProbingDistributionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProbingDistributionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
						mySubMasks[CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution] = probing_distribution.FullProbingDistribution_FieldMask()
					}
				} else if tp, ok := path.(*CreateProbingDistributionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProbingDistributionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProbingDistributionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProbingDistributionRequest_FieldMask) FilterInputFields() *CreateProbingDistributionRequest_FieldMask {
	result := &CreateProbingDistributionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
			if _, ok := path.(*CreateProbingDistributionRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_distribution.FullProbingDistribution_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingDistributionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProbingDistributionRequest_FieldSubPath); ok {
				selectedMask := &probing_distribution.ProbingDistribution_FieldMask{
					Paths: []probing_distribution.ProbingDistribution_FieldPath{sub.subPath.(probing_distribution.ProbingDistribution_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingDistributionRequest_FieldSubPath{selector: CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProbingDistributionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProbingDistributionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProbingDistributionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProbingDistributionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProbingDistributionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) AppendPath(path CreateProbingDistributionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProbingDistributionRequest_FieldPath))
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) GetPaths() []CreateProbingDistributionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProbingDistributionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Set(target, source *CreateProbingDistributionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProbingDistributionRequest), source.(*CreateProbingDistributionRequest))
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) Project(source *CreateProbingDistributionRequest) *CreateProbingDistributionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProbingDistributionRequest{}
	probingDistributionMask := &probing_distribution.ProbingDistribution_FieldMask{}
	wholeProbingDistributionAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProbingDistributionRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProbingDistributionRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
				result.ProbingDistribution = source.ProbingDistribution
				wholeProbingDistributionAccepted = true
			}
		case *CreateProbingDistributionRequest_FieldSubPath:
			switch tp.selector {
			case CreateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
				probingDistributionMask.AppendPath(tp.subPath.(probing_distribution.ProbingDistribution_FieldPath))
			}
		}
	}
	if wholeProbingDistributionAccepted == false && len(probingDistributionMask.Paths) > 0 {
		result.ProbingDistribution = probingDistributionMask.Project(source.GetProbingDistribution())
	}
	return result
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProbingDistributionRequest))
}

func (fieldMask *CreateProbingDistributionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingDistributionRequest_FieldMask struct {
	Paths []UpdateProbingDistributionRequest_FieldPath
}

func FullUpdateProbingDistributionRequest_FieldMask() *UpdateProbingDistributionRequest_FieldMask {
	res := &UpdateProbingDistributionRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingDistributionRequest_FieldTerminalPath{selector: UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution})
	res.Paths = append(res.Paths, &UpdateProbingDistributionRequest_FieldTerminalPath{selector: UpdateProbingDistributionRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProbingDistributionRequest_FieldTerminalPath{selector: UpdateProbingDistributionRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingDistributionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingDistributionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingDistributionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingDistributionRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Subtract(other *UpdateProbingDistributionRequest_FieldMask) *UpdateProbingDistributionRequest_FieldMask {
	result := &UpdateProbingDistributionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProbingDistributionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution: &probing_distribution.ProbingDistribution_FieldMask{},
		UpdateProbingDistributionRequest_FieldPathSelectorCas:                 &UpdateProbingDistributionRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProbingDistributionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution: &probing_distribution.ProbingDistribution_FieldMask{},
		UpdateProbingDistributionRequest_FieldPathSelectorCas:                 &UpdateProbingDistributionRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingDistributionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingDistributionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingDistributionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
						mySubMasks[UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution] = probing_distribution.FullProbingDistribution_FieldMask()
					case UpdateProbingDistributionRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProbingDistributionRequest_FieldPathSelectorCas] = FullUpdateProbingDistributionRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingDistributionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingDistributionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingDistributionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingDistributionRequest_FieldMask) FilterInputFields() *UpdateProbingDistributionRequest_FieldMask {
	result := &UpdateProbingDistributionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
			if _, ok := path.(*UpdateProbingDistributionRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_distribution.FullProbingDistribution_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingDistributionRequest_FieldSubPath); ok {
				selectedMask := &probing_distribution.ProbingDistribution_FieldMask{
					Paths: []probing_distribution.ProbingDistribution_FieldPath{sub.subPath.(probing_distribution.ProbingDistribution_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequest_FieldSubPath{selector: UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution, subPath: allowedPath})
				}
			}
		case UpdateProbingDistributionRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProbingDistributionRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProbingDistributionRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingDistributionRequest_FieldSubPath); ok {
				selectedMask := &UpdateProbingDistributionRequest_CAS_FieldMask{
					Paths: []UpdateProbingDistributionRequestCAS_FieldPath{sub.subPath.(UpdateProbingDistributionRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequest_FieldSubPath{selector: UpdateProbingDistributionRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingDistributionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingDistributionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingDistributionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingDistributionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingDistributionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) AppendPath(path UpdateProbingDistributionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingDistributionRequest_FieldPath))
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) GetPaths() []UpdateProbingDistributionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingDistributionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Set(target, source *UpdateProbingDistributionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingDistributionRequest), source.(*UpdateProbingDistributionRequest))
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) Project(source *UpdateProbingDistributionRequest) *UpdateProbingDistributionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingDistributionRequest{}
	probingDistributionMask := &probing_distribution.ProbingDistribution_FieldMask{}
	wholeProbingDistributionAccepted := false
	casMask := &UpdateProbingDistributionRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingDistributionRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
				result.ProbingDistribution = source.ProbingDistribution
				wholeProbingDistributionAccepted = true
			case UpdateProbingDistributionRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProbingDistributionRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProbingDistributionRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProbingDistributionRequest_FieldPathSelectorProbingDistribution:
				probingDistributionMask.AppendPath(tp.subPath.(probing_distribution.ProbingDistribution_FieldPath))
			case UpdateProbingDistributionRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProbingDistributionRequestCAS_FieldPath))
			}
		}
	}
	if wholeProbingDistributionAccepted == false && len(probingDistributionMask.Paths) > 0 {
		result.ProbingDistribution = probingDistributionMask.Project(source.GetProbingDistribution())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingDistributionRequest))
}

func (fieldMask *UpdateProbingDistributionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingDistributionRequest_CAS_FieldMask struct {
	Paths []UpdateProbingDistributionRequestCAS_FieldPath
}

func FullUpdateProbingDistributionRequest_CAS_FieldMask() *UpdateProbingDistributionRequest_CAS_FieldMask {
	res := &UpdateProbingDistributionRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingDistributionRequestCAS_FieldTerminalPath{selector: UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProbingDistributionRequestCAS_FieldTerminalPath{selector: UpdateProbingDistributionRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingDistributionRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingDistributionRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingDistributionRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Subtract(other *UpdateProbingDistributionRequest_CAS_FieldMask) *UpdateProbingDistributionRequest_CAS_FieldMask {
	result := &UpdateProbingDistributionRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProbingDistributionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState: &probing_distribution.ProbingDistribution_FieldMask{},
	}
	mySubMasks := map[UpdateProbingDistributionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState: &probing_distribution.ProbingDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingDistributionRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingDistributionRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingDistributionRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState] = probing_distribution.FullProbingDistribution_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingDistributionRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingDistributionRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingDistributionRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) FilterInputFields() *UpdateProbingDistributionRequest_CAS_FieldMask {
	result := &UpdateProbingDistributionRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProbingDistributionRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range probing_distribution.FullProbingDistribution_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingDistributionRequestCAS_FieldSubPath); ok {
				selectedMask := &probing_distribution.ProbingDistribution_FieldMask{
					Paths: []probing_distribution.ProbingDistribution_FieldPath{sub.subPath.(probing_distribution.ProbingDistribution_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingDistributionRequestCAS_FieldSubPath{selector: UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingDistributionRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingDistributionRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingDistributionRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingDistributionRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) AppendPath(path UpdateProbingDistributionRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingDistributionRequestCAS_FieldPath))
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) GetPaths() []UpdateProbingDistributionRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingDistributionRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Set(target, source *UpdateProbingDistributionRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingDistributionRequest_CAS), source.(*UpdateProbingDistributionRequest_CAS))
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) Project(source *UpdateProbingDistributionRequest_CAS) *UpdateProbingDistributionRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingDistributionRequest_CAS{}
	conditionalStateMask := &probing_distribution.ProbingDistribution_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingDistributionRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProbingDistributionRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProbingDistributionRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProbingDistributionRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(probing_distribution.ProbingDistribution_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingDistributionRequest_CAS))
}

func (fieldMask *UpdateProbingDistributionRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProbingDistributionRequest_FieldMask struct {
	Paths []DeleteProbingDistributionRequest_FieldPath
}

func FullDeleteProbingDistributionRequest_FieldMask() *DeleteProbingDistributionRequest_FieldMask {
	res := &DeleteProbingDistributionRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProbingDistributionRequest_FieldTerminalPath{selector: DeleteProbingDistributionRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProbingDistributionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProbingDistributionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProbingDistributionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProbingDistributionRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Subtract(other *DeleteProbingDistributionRequest_FieldMask) *DeleteProbingDistributionRequest_FieldMask {
	result := &DeleteProbingDistributionRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProbingDistributionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProbingDistributionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProbingDistributionRequest_FieldMask) FilterInputFields() *DeleteProbingDistributionRequest_FieldMask {
	result := &DeleteProbingDistributionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProbingDistributionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProbingDistributionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProbingDistributionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProbingDistributionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProbingDistributionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) AppendPath(path DeleteProbingDistributionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProbingDistributionRequest_FieldPath))
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) GetPaths() []DeleteProbingDistributionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProbingDistributionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Set(target, source *DeleteProbingDistributionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProbingDistributionRequest), source.(*DeleteProbingDistributionRequest))
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) Project(source *DeleteProbingDistributionRequest) *DeleteProbingDistributionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProbingDistributionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProbingDistributionRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProbingDistributionRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProbingDistributionRequest))
}

func (fieldMask *DeleteProbingDistributionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
