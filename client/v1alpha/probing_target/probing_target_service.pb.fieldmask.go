// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha/probing_target_service.proto
// DO NOT EDIT!!!

package probing_target_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	probing_target "github.com/cloudwan/watchdog-sdk/resources/v1alpha/probing_target"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha/project"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &probing_target.ProbingTarget{}
	_ = &project.Project{}
)

type GetProbingTargetRequest_FieldMask struct {
	Paths []GetProbingTargetRequest_FieldPath
}

func FullGetProbingTargetRequest_FieldMask() *GetProbingTargetRequest_FieldMask {
	res := &GetProbingTargetRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProbingTargetRequest_FieldTerminalPath{selector: GetProbingTargetRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProbingTargetRequest_FieldTerminalPath{selector: GetProbingTargetRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProbingTargetRequest_FieldTerminalPath{selector: GetProbingTargetRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProbingTargetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProbingTargetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProbingTargetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProbingTargetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProbingTargetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProbingTargetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProbingTargetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProbingTargetRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProbingTargetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProbingTargetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProbingTargetRequest_FieldMask) Subtract(other *GetProbingTargetRequest_FieldMask) *GetProbingTargetRequest_FieldMask {
	result := &GetProbingTargetRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProbingTargetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProbingTargetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProbingTargetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProbingTargetRequest_FieldMask) FilterInputFields() *GetProbingTargetRequest_FieldMask {
	result := &GetProbingTargetRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProbingTargetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProbingTargetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProbingTargetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProbingTargetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProbingTargetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProbingTargetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingTargetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProbingTargetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProbingTargetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProbingTargetRequest_FieldMask) AppendPath(path GetProbingTargetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProbingTargetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProbingTargetRequest_FieldPath))
}

func (fieldMask *GetProbingTargetRequest_FieldMask) GetPaths() []GetProbingTargetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProbingTargetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProbingTargetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProbingTargetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProbingTargetRequest_FieldMask) Set(target, source *GetProbingTargetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProbingTargetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProbingTargetRequest), source.(*GetProbingTargetRequest))
}

func (fieldMask *GetProbingTargetRequest_FieldMask) Project(source *GetProbingTargetRequest) *GetProbingTargetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProbingTargetRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProbingTargetRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProbingTargetRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProbingTargetRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProbingTargetRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProbingTargetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProbingTargetRequest))
}

func (fieldMask *GetProbingTargetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingTargetsRequest_FieldMask struct {
	Paths []BatchGetProbingTargetsRequest_FieldPath
}

func FullBatchGetProbingTargetsRequest_FieldMask() *BatchGetProbingTargetsRequest_FieldMask {
	res := &BatchGetProbingTargetsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingTargetsRequest_FieldTerminalPath{selector: BatchGetProbingTargetsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetProbingTargetsRequest_FieldTerminalPath{selector: BatchGetProbingTargetsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProbingTargetsRequest_FieldTerminalPath{selector: BatchGetProbingTargetsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProbingTargetsRequest_FieldTerminalPath{selector: BatchGetProbingTargetsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingTargetsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingTargetsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingTargetsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Subtract(other *BatchGetProbingTargetsRequest_FieldMask) *BatchGetProbingTargetsRequest_FieldMask {
	result := &BatchGetProbingTargetsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingTargetsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingTargetsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) FilterInputFields() *BatchGetProbingTargetsRequest_FieldMask {
	result := &BatchGetProbingTargetsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingTargetsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingTargetsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingTargetsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingTargetsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) AppendPath(path BatchGetProbingTargetsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingTargetsRequest_FieldPath))
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) GetPaths() []BatchGetProbingTargetsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingTargetsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Set(target, source *BatchGetProbingTargetsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingTargetsRequest), source.(*BatchGetProbingTargetsRequest))
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) Project(source *BatchGetProbingTargetsRequest) *BatchGetProbingTargetsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingTargetsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingTargetsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingTargetsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetProbingTargetsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProbingTargetsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProbingTargetsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingTargetsRequest))
}

func (fieldMask *BatchGetProbingTargetsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProbingTargetsResponse_FieldMask struct {
	Paths []BatchGetProbingTargetsResponse_FieldPath
}

func FullBatchGetProbingTargetsResponse_FieldMask() *BatchGetProbingTargetsResponse_FieldMask {
	res := &BatchGetProbingTargetsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProbingTargetsResponse_FieldTerminalPath{selector: BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets})
	res.Paths = append(res.Paths, &BatchGetProbingTargetsResponse_FieldTerminalPath{selector: BatchGetProbingTargetsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProbingTargetsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProbingTargetsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProbingTargetsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Subtract(other *BatchGetProbingTargetsResponse_FieldMask) *BatchGetProbingTargetsResponse_FieldMask {
	result := &BatchGetProbingTargetsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets: &probing_target.ProbingTarget_FieldMask{},
	}
	mySubMasks := map[BatchGetProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets: &probing_target.ProbingTarget_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProbingTargetsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProbingTargetsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProbingTargetsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets:
						mySubMasks[BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets] = probing_target.FullProbingTarget_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProbingTargetsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProbingTargetsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProbingTargetsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) FilterInputFields() *BatchGetProbingTargetsResponse_FieldMask {
	result := &BatchGetProbingTargetsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets:
			if _, ok := path.(*BatchGetProbingTargetsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_target.FullProbingTarget_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingTargetsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProbingTargetsResponse_FieldSubPath); ok {
				selectedMask := &probing_target.ProbingTarget_FieldMask{
					Paths: []probing_target.ProbingTarget_FieldPath{sub.subPath.(probing_target.ProbingTarget_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProbingTargetsResponse_FieldSubPath{selector: BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProbingTargetsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProbingTargetsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProbingTargetsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProbingTargetsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) AppendPath(path BatchGetProbingTargetsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProbingTargetsResponse_FieldPath))
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) GetPaths() []BatchGetProbingTargetsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProbingTargetsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Set(target, source *BatchGetProbingTargetsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProbingTargetsResponse), source.(*BatchGetProbingTargetsResponse))
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) Project(source *BatchGetProbingTargetsResponse) *BatchGetProbingTargetsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProbingTargetsResponse{}
	probingTargetsMask := &probing_target.ProbingTarget_FieldMask{}
	wholeProbingTargetsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProbingTargetsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets:
				result.ProbingTargets = source.ProbingTargets
				wholeProbingTargetsAccepted = true
			case BatchGetProbingTargetsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProbingTargetsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProbingTargetsResponse_FieldPathSelectorProbingTargets:
				probingTargetsMask.AppendPath(tp.subPath.(probing_target.ProbingTarget_FieldPath))
			}
		}
	}
	if wholeProbingTargetsAccepted == false && len(probingTargetsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingTargets() {
			result.ProbingTargets = append(result.ProbingTargets, probingTargetsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProbingTargetsResponse))
}

func (fieldMask *BatchGetProbingTargetsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingTargetsRequest_FieldMask struct {
	Paths []ListProbingTargetsRequest_FieldPath
}

func FullListProbingTargetsRequest_FieldMask() *ListProbingTargetsRequest_FieldMask {
	res := &ListProbingTargetsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProbingTargetsRequest_FieldTerminalPath{selector: ListProbingTargetsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingTargetsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingTargetsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingTargetsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingTargetsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Subtract(other *ListProbingTargetsRequest_FieldMask) *ListProbingTargetsRequest_FieldMask {
	result := &ListProbingTargetsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingTargetsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingTargetsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingTargetsRequest_FieldMask) FilterInputFields() *ListProbingTargetsRequest_FieldMask {
	result := &ListProbingTargetsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingTargetsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingTargetsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingTargetsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingTargetsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingTargetsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) AppendPath(path ListProbingTargetsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingTargetsRequest_FieldPath))
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) GetPaths() []ListProbingTargetsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingTargetsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Set(target, source *ListProbingTargetsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingTargetsRequest), source.(*ListProbingTargetsRequest))
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) Project(source *ListProbingTargetsRequest) *ListProbingTargetsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingTargetsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingTargetsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProbingTargetsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProbingTargetsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProbingTargetsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProbingTargetsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProbingTargetsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProbingTargetsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProbingTargetsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingTargetsRequest))
}

func (fieldMask *ListProbingTargetsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProbingTargetsResponse_FieldMask struct {
	Paths []ListProbingTargetsResponse_FieldPath
}

func FullListProbingTargetsResponse_FieldMask() *ListProbingTargetsResponse_FieldMask {
	res := &ListProbingTargetsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProbingTargetsResponse_FieldTerminalPath{selector: ListProbingTargetsResponse_FieldPathSelectorProbingTargets})
	res.Paths = append(res.Paths, &ListProbingTargetsResponse_FieldTerminalPath{selector: ListProbingTargetsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProbingTargetsResponse_FieldTerminalPath{selector: ListProbingTargetsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProbingTargetsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProbingTargetsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProbingTargetsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProbingTargetsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Subtract(other *ListProbingTargetsResponse_FieldMask) *ListProbingTargetsResponse_FieldMask {
	result := &ListProbingTargetsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingTargetsResponse_FieldPathSelectorProbingTargets: &probing_target.ProbingTarget_FieldMask{},
	}
	mySubMasks := map[ListProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProbingTargetsResponse_FieldPathSelectorProbingTargets: &probing_target.ProbingTarget_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProbingTargetsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProbingTargetsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProbingTargetsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProbingTargetsResponse_FieldPathSelectorProbingTargets:
						mySubMasks[ListProbingTargetsResponse_FieldPathSelectorProbingTargets] = probing_target.FullProbingTarget_FieldMask()
					}
				} else if tp, ok := path.(*ListProbingTargetsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProbingTargetsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProbingTargetsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProbingTargetsResponse_FieldMask) FilterInputFields() *ListProbingTargetsResponse_FieldMask {
	result := &ListProbingTargetsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProbingTargetsResponse_FieldPathSelectorProbingTargets:
			if _, ok := path.(*ListProbingTargetsResponse_FieldTerminalPath); ok {
				for _, subpath := range probing_target.FullProbingTarget_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingTargetsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProbingTargetsResponse_FieldSubPath); ok {
				selectedMask := &probing_target.ProbingTarget_FieldMask{
					Paths: []probing_target.ProbingTarget_FieldPath{sub.subPath.(probing_target.ProbingTarget_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProbingTargetsResponse_FieldSubPath{selector: ListProbingTargetsResponse_FieldPathSelectorProbingTargets, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProbingTargetsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProbingTargetsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProbingTargetsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProbingTargetsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProbingTargetsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) AppendPath(path ListProbingTargetsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProbingTargetsResponse_FieldPath))
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) GetPaths() []ListProbingTargetsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProbingTargetsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Set(target, source *ListProbingTargetsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProbingTargetsResponse), source.(*ListProbingTargetsResponse))
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) Project(source *ListProbingTargetsResponse) *ListProbingTargetsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProbingTargetsResponse{}
	probingTargetsMask := &probing_target.ProbingTarget_FieldMask{}
	wholeProbingTargetsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProbingTargetsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProbingTargetsResponse_FieldPathSelectorProbingTargets:
				result.ProbingTargets = source.ProbingTargets
				wholeProbingTargetsAccepted = true
			case ListProbingTargetsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProbingTargetsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListProbingTargetsResponse_FieldSubPath:
			switch tp.selector {
			case ListProbingTargetsResponse_FieldPathSelectorProbingTargets:
				probingTargetsMask.AppendPath(tp.subPath.(probing_target.ProbingTarget_FieldPath))
			}
		}
	}
	if wholeProbingTargetsAccepted == false && len(probingTargetsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProbingTargets() {
			result.ProbingTargets = append(result.ProbingTargets, probingTargetsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProbingTargetsResponse))
}

func (fieldMask *ListProbingTargetsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingTargetRequest_FieldMask struct {
	Paths []WatchProbingTargetRequest_FieldPath
}

func FullWatchProbingTargetRequest_FieldMask() *WatchProbingTargetRequest_FieldMask {
	res := &WatchProbingTargetRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingTargetRequest_FieldTerminalPath{selector: WatchProbingTargetRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProbingTargetRequest_FieldTerminalPath{selector: WatchProbingTargetRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingTargetRequest_FieldTerminalPath{selector: WatchProbingTargetRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingTargetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingTargetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingTargetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingTargetRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Subtract(other *WatchProbingTargetRequest_FieldMask) *WatchProbingTargetRequest_FieldMask {
	result := &WatchProbingTargetRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingTargetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingTargetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingTargetRequest_FieldMask) FilterInputFields() *WatchProbingTargetRequest_FieldMask {
	result := &WatchProbingTargetRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingTargetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingTargetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingTargetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingTargetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingTargetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) AppendPath(path WatchProbingTargetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingTargetRequest_FieldPath))
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) GetPaths() []WatchProbingTargetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingTargetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Set(target, source *WatchProbingTargetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingTargetRequest), source.(*WatchProbingTargetRequest))
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) Project(source *WatchProbingTargetRequest) *WatchProbingTargetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingTargetRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingTargetRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingTargetRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProbingTargetRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingTargetRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingTargetRequest))
}

func (fieldMask *WatchProbingTargetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingTargetResponse_FieldMask struct {
	Paths []WatchProbingTargetResponse_FieldPath
}

func FullWatchProbingTargetResponse_FieldMask() *WatchProbingTargetResponse_FieldMask {
	res := &WatchProbingTargetResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingTargetResponse_FieldTerminalPath{selector: WatchProbingTargetResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingTargetResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingTargetResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingTargetResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingTargetResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Subtract(other *WatchProbingTargetResponse_FieldMask) *WatchProbingTargetResponse_FieldMask {
	result := &WatchProbingTargetResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingTargetResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingTargetResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingTargetResponse_FieldMask) FilterInputFields() *WatchProbingTargetResponse_FieldMask {
	result := &WatchProbingTargetResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingTargetResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingTargetResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingTargetResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingTargetResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingTargetResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) AppendPath(path WatchProbingTargetResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingTargetResponse_FieldPath))
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) GetPaths() []WatchProbingTargetResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingTargetResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Set(target, source *WatchProbingTargetResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingTargetResponse), source.(*WatchProbingTargetResponse))
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) Project(source *WatchProbingTargetResponse) *WatchProbingTargetResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingTargetResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingTargetResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingTargetResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingTargetResponse))
}

func (fieldMask *WatchProbingTargetResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingTargetsRequest_FieldMask struct {
	Paths []WatchProbingTargetsRequest_FieldPath
}

func FullWatchProbingTargetsRequest_FieldMask() *WatchProbingTargetsRequest_FieldMask {
	res := &WatchProbingTargetsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProbingTargetsRequest_FieldTerminalPath{selector: WatchProbingTargetsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingTargetsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingTargetsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingTargetsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingTargetsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Subtract(other *WatchProbingTargetsRequest_FieldMask) *WatchProbingTargetsRequest_FieldMask {
	result := &WatchProbingTargetsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingTargetsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingTargetsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingTargetsRequest_FieldMask) FilterInputFields() *WatchProbingTargetsRequest_FieldMask {
	result := &WatchProbingTargetsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingTargetsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingTargetsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingTargetsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingTargetsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingTargetsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) AppendPath(path WatchProbingTargetsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingTargetsRequest_FieldPath))
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) GetPaths() []WatchProbingTargetsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingTargetsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Set(target, source *WatchProbingTargetsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingTargetsRequest), source.(*WatchProbingTargetsRequest))
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) Project(source *WatchProbingTargetsRequest) *WatchProbingTargetsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingTargetsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingTargetsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingTargetsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProbingTargetsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProbingTargetsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProbingTargetsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProbingTargetsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProbingTargetsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingTargetsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProbingTargetsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProbingTargetsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProbingTargetsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingTargetsRequest))
}

func (fieldMask *WatchProbingTargetsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingTargetsResponse_FieldMask struct {
	Paths []WatchProbingTargetsResponse_FieldPath
}

func FullWatchProbingTargetsResponse_FieldMask() *WatchProbingTargetsResponse_FieldMask {
	res := &WatchProbingTargetsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorProbingTargetChanges})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponse_FieldTerminalPath{selector: WatchProbingTargetsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingTargetsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingTargetsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingTargetsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingTargetsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Subtract(other *WatchProbingTargetsResponse_FieldMask) *WatchProbingTargetsResponse_FieldMask {
	result := &WatchProbingTargetsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange: &WatchProbingTargetsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProbingTargetsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange: &WatchProbingTargetsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingTargetsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProbingTargetsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProbingTargetsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange] = FullWatchProbingTargetsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProbingTargetsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProbingTargetsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingTargetsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingTargetsResponse_FieldMask) FilterInputFields() *WatchProbingTargetsResponse_FieldMask {
	result := &WatchProbingTargetsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingTargetsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingTargetsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingTargetsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingTargetsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingTargetsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) AppendPath(path WatchProbingTargetsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingTargetsResponse_FieldPath))
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) GetPaths() []WatchProbingTargetsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingTargetsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Set(target, source *WatchProbingTargetsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingTargetsResponse), source.(*WatchProbingTargetsResponse))
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) Project(source *WatchProbingTargetsResponse) *WatchProbingTargetsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingTargetsResponse{}
	pageTokenChangeMask := &WatchProbingTargetsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingTargetsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingTargetsResponse_FieldPathSelectorProbingTargetChanges:
				result.ProbingTargetChanges = source.ProbingTargetChanges
			case WatchProbingTargetsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProbingTargetsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProbingTargetsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProbingTargetsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProbingTargetsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProbingTargetsResponse_FieldSubPath:
			switch tp.selector {
			case WatchProbingTargetsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProbingTargetsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingTargetsResponse))
}

func (fieldMask *WatchProbingTargetsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProbingTargetsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProbingTargetsResponsePageTokenChange_FieldPath
}

func FullWatchProbingTargetsResponse_PageTokenChange_FieldMask() *WatchProbingTargetsResponse_PageTokenChange_FieldMask {
	res := &WatchProbingTargetsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProbingTargetsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingTargetsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProbingTargetsResponsePageTokenChange_FieldTerminalPath{selector: WatchProbingTargetsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProbingTargetsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProbingTargetsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProbingTargetsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Subtract(other *WatchProbingTargetsResponse_PageTokenChange_FieldMask) *WatchProbingTargetsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingTargetsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProbingTargetsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProbingTargetsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProbingTargetsResponse_PageTokenChange_FieldMask {
	result := &WatchProbingTargetsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProbingTargetsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProbingTargetsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProbingTargetsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProbingTargetsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) AppendPath(path WatchProbingTargetsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProbingTargetsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) GetPaths() []WatchProbingTargetsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProbingTargetsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Set(target, source *WatchProbingTargetsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProbingTargetsResponse_PageTokenChange), source.(*WatchProbingTargetsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) Project(source *WatchProbingTargetsResponse_PageTokenChange) *WatchProbingTargetsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProbingTargetsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProbingTargetsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProbingTargetsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProbingTargetsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProbingTargetsResponse_PageTokenChange))
}

func (fieldMask *WatchProbingTargetsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProbingTargetRequest_FieldMask struct {
	Paths []CreateProbingTargetRequest_FieldPath
}

func FullCreateProbingTargetRequest_FieldMask() *CreateProbingTargetRequest_FieldMask {
	res := &CreateProbingTargetRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProbingTargetRequest_FieldTerminalPath{selector: CreateProbingTargetRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProbingTargetRequest_FieldTerminalPath{selector: CreateProbingTargetRequest_FieldPathSelectorProbingTarget})
	return res
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProbingTargetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProbingTargetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProbingTargetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProbingTargetRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Subtract(other *CreateProbingTargetRequest_FieldMask) *CreateProbingTargetRequest_FieldMask {
	result := &CreateProbingTargetRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProbingTargetRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingTargetRequest_FieldPathSelectorProbingTarget: &probing_target.ProbingTarget_FieldMask{},
	}
	mySubMasks := map[CreateProbingTargetRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProbingTargetRequest_FieldPathSelectorProbingTarget: &probing_target.ProbingTarget_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProbingTargetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProbingTargetRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProbingTargetRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProbingTargetRequest_FieldPathSelectorProbingTarget:
						mySubMasks[CreateProbingTargetRequest_FieldPathSelectorProbingTarget] = probing_target.FullProbingTarget_FieldMask()
					}
				} else if tp, ok := path.(*CreateProbingTargetRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProbingTargetRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProbingTargetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProbingTargetRequest_FieldMask) FilterInputFields() *CreateProbingTargetRequest_FieldMask {
	result := &CreateProbingTargetRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProbingTargetRequest_FieldPathSelectorProbingTarget:
			if _, ok := path.(*CreateProbingTargetRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_target.FullProbingTarget_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingTargetRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProbingTargetRequest_FieldSubPath); ok {
				selectedMask := &probing_target.ProbingTarget_FieldMask{
					Paths: []probing_target.ProbingTarget_FieldPath{sub.subPath.(probing_target.ProbingTarget_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProbingTargetRequest_FieldSubPath{selector: CreateProbingTargetRequest_FieldPathSelectorProbingTarget, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProbingTargetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProbingTargetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProbingTargetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProbingTargetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProbingTargetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) AppendPath(path CreateProbingTargetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProbingTargetRequest_FieldPath))
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) GetPaths() []CreateProbingTargetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProbingTargetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Set(target, source *CreateProbingTargetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProbingTargetRequest), source.(*CreateProbingTargetRequest))
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) Project(source *CreateProbingTargetRequest) *CreateProbingTargetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProbingTargetRequest{}
	probingTargetMask := &probing_target.ProbingTarget_FieldMask{}
	wholeProbingTargetAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProbingTargetRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProbingTargetRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProbingTargetRequest_FieldPathSelectorProbingTarget:
				result.ProbingTarget = source.ProbingTarget
				wholeProbingTargetAccepted = true
			}
		case *CreateProbingTargetRequest_FieldSubPath:
			switch tp.selector {
			case CreateProbingTargetRequest_FieldPathSelectorProbingTarget:
				probingTargetMask.AppendPath(tp.subPath.(probing_target.ProbingTarget_FieldPath))
			}
		}
	}
	if wholeProbingTargetAccepted == false && len(probingTargetMask.Paths) > 0 {
		result.ProbingTarget = probingTargetMask.Project(source.GetProbingTarget())
	}
	return result
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProbingTargetRequest))
}

func (fieldMask *CreateProbingTargetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingTargetRequest_FieldMask struct {
	Paths []UpdateProbingTargetRequest_FieldPath
}

func FullUpdateProbingTargetRequest_FieldMask() *UpdateProbingTargetRequest_FieldMask {
	res := &UpdateProbingTargetRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingTargetRequest_FieldTerminalPath{selector: UpdateProbingTargetRequest_FieldPathSelectorProbingTarget})
	res.Paths = append(res.Paths, &UpdateProbingTargetRequest_FieldTerminalPath{selector: UpdateProbingTargetRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProbingTargetRequest_FieldTerminalPath{selector: UpdateProbingTargetRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingTargetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingTargetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingTargetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingTargetRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Subtract(other *UpdateProbingTargetRequest_FieldMask) *UpdateProbingTargetRequest_FieldMask {
	result := &UpdateProbingTargetRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProbingTargetRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingTargetRequest_FieldPathSelectorProbingTarget: &probing_target.ProbingTarget_FieldMask{},
		UpdateProbingTargetRequest_FieldPathSelectorCas:           &UpdateProbingTargetRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProbingTargetRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingTargetRequest_FieldPathSelectorProbingTarget: &probing_target.ProbingTarget_FieldMask{},
		UpdateProbingTargetRequest_FieldPathSelectorCas:           &UpdateProbingTargetRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingTargetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingTargetRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingTargetRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingTargetRequest_FieldPathSelectorProbingTarget:
						mySubMasks[UpdateProbingTargetRequest_FieldPathSelectorProbingTarget] = probing_target.FullProbingTarget_FieldMask()
					case UpdateProbingTargetRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProbingTargetRequest_FieldPathSelectorCas] = FullUpdateProbingTargetRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingTargetRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingTargetRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingTargetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingTargetRequest_FieldMask) FilterInputFields() *UpdateProbingTargetRequest_FieldMask {
	result := &UpdateProbingTargetRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingTargetRequest_FieldPathSelectorProbingTarget:
			if _, ok := path.(*UpdateProbingTargetRequest_FieldTerminalPath); ok {
				for _, subpath := range probing_target.FullProbingTarget_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingTargetRequest_FieldSubPath); ok {
				selectedMask := &probing_target.ProbingTarget_FieldMask{
					Paths: []probing_target.ProbingTarget_FieldPath{sub.subPath.(probing_target.ProbingTarget_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequest_FieldSubPath{selector: UpdateProbingTargetRequest_FieldPathSelectorProbingTarget, subPath: allowedPath})
				}
			}
		case UpdateProbingTargetRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProbingTargetRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProbingTargetRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingTargetRequest_FieldSubPath); ok {
				selectedMask := &UpdateProbingTargetRequest_CAS_FieldMask{
					Paths: []UpdateProbingTargetRequestCAS_FieldPath{sub.subPath.(UpdateProbingTargetRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequest_FieldSubPath{selector: UpdateProbingTargetRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingTargetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingTargetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingTargetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingTargetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingTargetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) AppendPath(path UpdateProbingTargetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingTargetRequest_FieldPath))
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) GetPaths() []UpdateProbingTargetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingTargetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Set(target, source *UpdateProbingTargetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingTargetRequest), source.(*UpdateProbingTargetRequest))
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) Project(source *UpdateProbingTargetRequest) *UpdateProbingTargetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingTargetRequest{}
	probingTargetMask := &probing_target.ProbingTarget_FieldMask{}
	wholeProbingTargetAccepted := false
	casMask := &UpdateProbingTargetRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingTargetRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingTargetRequest_FieldPathSelectorProbingTarget:
				result.ProbingTarget = source.ProbingTarget
				wholeProbingTargetAccepted = true
			case UpdateProbingTargetRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProbingTargetRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProbingTargetRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProbingTargetRequest_FieldPathSelectorProbingTarget:
				probingTargetMask.AppendPath(tp.subPath.(probing_target.ProbingTarget_FieldPath))
			case UpdateProbingTargetRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProbingTargetRequestCAS_FieldPath))
			}
		}
	}
	if wholeProbingTargetAccepted == false && len(probingTargetMask.Paths) > 0 {
		result.ProbingTarget = probingTargetMask.Project(source.GetProbingTarget())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingTargetRequest))
}

func (fieldMask *UpdateProbingTargetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProbingTargetRequest_CAS_FieldMask struct {
	Paths []UpdateProbingTargetRequestCAS_FieldPath
}

func FullUpdateProbingTargetRequest_CAS_FieldMask() *UpdateProbingTargetRequest_CAS_FieldMask {
	res := &UpdateProbingTargetRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProbingTargetRequestCAS_FieldTerminalPath{selector: UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProbingTargetRequestCAS_FieldTerminalPath{selector: UpdateProbingTargetRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProbingTargetRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProbingTargetRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProbingTargetRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Subtract(other *UpdateProbingTargetRequest_CAS_FieldMask) *UpdateProbingTargetRequest_CAS_FieldMask {
	result := &UpdateProbingTargetRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProbingTargetRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState: &probing_target.ProbingTarget_FieldMask{},
	}
	mySubMasks := map[UpdateProbingTargetRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState: &probing_target.ProbingTarget_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProbingTargetRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProbingTargetRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProbingTargetRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState] = probing_target.FullProbingTarget_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProbingTargetRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProbingTargetRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProbingTargetRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) FilterInputFields() *UpdateProbingTargetRequest_CAS_FieldMask {
	result := &UpdateProbingTargetRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProbingTargetRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range probing_target.FullProbingTarget_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProbingTargetRequestCAS_FieldSubPath); ok {
				selectedMask := &probing_target.ProbingTarget_FieldMask{
					Paths: []probing_target.ProbingTarget_FieldPath{sub.subPath.(probing_target.ProbingTarget_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProbingTargetRequestCAS_FieldSubPath{selector: UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProbingTargetRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProbingTargetRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProbingTargetRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProbingTargetRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) AppendPath(path UpdateProbingTargetRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProbingTargetRequestCAS_FieldPath))
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) GetPaths() []UpdateProbingTargetRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProbingTargetRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Set(target, source *UpdateProbingTargetRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProbingTargetRequest_CAS), source.(*UpdateProbingTargetRequest_CAS))
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) Project(source *UpdateProbingTargetRequest_CAS) *UpdateProbingTargetRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProbingTargetRequest_CAS{}
	conditionalStateMask := &probing_target.ProbingTarget_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProbingTargetRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProbingTargetRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProbingTargetRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProbingTargetRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(probing_target.ProbingTarget_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProbingTargetRequest_CAS))
}

func (fieldMask *UpdateProbingTargetRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProbingTargetRequest_FieldMask struct {
	Paths []DeleteProbingTargetRequest_FieldPath
}

func FullDeleteProbingTargetRequest_FieldMask() *DeleteProbingTargetRequest_FieldMask {
	res := &DeleteProbingTargetRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProbingTargetRequest_FieldTerminalPath{selector: DeleteProbingTargetRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProbingTargetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProbingTargetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProbingTargetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProbingTargetRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Subtract(other *DeleteProbingTargetRequest_FieldMask) *DeleteProbingTargetRequest_FieldMask {
	result := &DeleteProbingTargetRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProbingTargetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProbingTargetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProbingTargetRequest_FieldMask) FilterInputFields() *DeleteProbingTargetRequest_FieldMask {
	result := &DeleteProbingTargetRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProbingTargetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProbingTargetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProbingTargetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProbingTargetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProbingTargetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) AppendPath(path DeleteProbingTargetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProbingTargetRequest_FieldPath))
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) GetPaths() []DeleteProbingTargetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProbingTargetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Set(target, source *DeleteProbingTargetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProbingTargetRequest), source.(*DeleteProbingTargetRequest))
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) Project(source *DeleteProbingTargetRequest) *DeleteProbingTargetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProbingTargetRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProbingTargetRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProbingTargetRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProbingTargetRequest))
}

func (fieldMask *DeleteProbingTargetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
