// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha/probe_hardware_custom.proto
// DO NOT EDIT!!!

package probe_hardware_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	probe "github.com/cloudwan/watchdog-sdk/resources/v1alpha/probe"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha/project"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &probe.Probe{}
	_ = &project.Project{}
)

type ProbeHardwareGetRequest_FieldMask struct {
	Paths []ProbeHardwareGetRequest_FieldPath
}

func FullProbeHardwareGetRequest_FieldMask() *ProbeHardwareGetRequest_FieldMask {
	res := &ProbeHardwareGetRequest_FieldMask{}
	res.Paths = append(res.Paths, &ProbeHardwareGetRequest_FieldTerminalPath{selector: ProbeHardwareGetRequest_FieldPathSelectorProbeName})
	res.Paths = append(res.Paths, &ProbeHardwareGetRequest_FieldTerminalPath{selector: ProbeHardwareGetRequest_FieldPathSelectorAccessToken})
	return res
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ProbeHardwareGetRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeHardwareGetRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeHardwareGetRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeHardwareGetRequest_FieldPath(raw)
	})
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Subtract(other *ProbeHardwareGetRequest_FieldMask) *ProbeHardwareGetRequest_FieldMask {
	result := &ProbeHardwareGetRequest_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeHardwareGetRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProbeHardwareGetRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProbeHardwareGetRequest_FieldMask) FilterInputFields() *ProbeHardwareGetRequest_FieldMask {
	result := &ProbeHardwareGetRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProbeHardwareGetRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeHardwareGetRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeHardwareGetRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProbeHardwareGetRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProbeHardwareGetRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) AppendPath(path ProbeHardwareGetRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeHardwareGetRequest_FieldPath))
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) GetPaths() []ProbeHardwareGetRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeHardwareGetRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Set(target, source *ProbeHardwareGetRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProbeHardwareGetRequest), source.(*ProbeHardwareGetRequest))
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) Project(source *ProbeHardwareGetRequest) *ProbeHardwareGetRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProbeHardwareGetRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeHardwareGetRequest_FieldTerminalPath:
			switch tp.selector {
			case ProbeHardwareGetRequest_FieldPathSelectorProbeName:
				result.ProbeName = source.ProbeName
			case ProbeHardwareGetRequest_FieldPathSelectorAccessToken:
				result.AccessToken = source.AccessToken
			}
		}
	}
	return result
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProbeHardwareGetRequest))
}

func (fieldMask *ProbeHardwareGetRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProbeHardwareGetResponse_FieldMask struct {
	Paths []ProbeHardwareGetResponse_FieldPath
}

func FullProbeHardwareGetResponse_FieldMask() *ProbeHardwareGetResponse_FieldMask {
	res := &ProbeHardwareGetResponse_FieldMask{}
	res.Paths = append(res.Paths, &ProbeHardwareGetResponse_FieldTerminalPath{selector: ProbeHardwareGetResponse_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &ProbeHardwareGetResponse_FieldTerminalPath{selector: ProbeHardwareGetResponse_FieldPathSelectorActivationStatus})
	res.Paths = append(res.Paths, &ProbeHardwareGetResponse_FieldTerminalPath{selector: ProbeHardwareGetResponse_FieldPathSelectorConnectionStatus})
	return res
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ProbeHardwareGetResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeHardwareGetResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeHardwareGetResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeHardwareGetResponse_FieldPath(raw)
	})
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Subtract(other *ProbeHardwareGetResponse_FieldMask) *ProbeHardwareGetResponse_FieldMask {
	result := &ProbeHardwareGetResponse_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeHardwareGetResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProbeHardwareGetResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProbeHardwareGetResponse_FieldMask) FilterInputFields() *ProbeHardwareGetResponse_FieldMask {
	result := &ProbeHardwareGetResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProbeHardwareGetResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeHardwareGetResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeHardwareGetResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProbeHardwareGetResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProbeHardwareGetResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) AppendPath(path ProbeHardwareGetResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeHardwareGetResponse_FieldPath))
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) GetPaths() []ProbeHardwareGetResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeHardwareGetResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Set(target, source *ProbeHardwareGetResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProbeHardwareGetResponse), source.(*ProbeHardwareGetResponse))
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) Project(source *ProbeHardwareGetResponse) *ProbeHardwareGetResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProbeHardwareGetResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeHardwareGetResponse_FieldTerminalPath:
			switch tp.selector {
			case ProbeHardwareGetResponse_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case ProbeHardwareGetResponse_FieldPathSelectorActivationStatus:
				result.ActivationStatus = source.ActivationStatus
			case ProbeHardwareGetResponse_FieldPathSelectorConnectionStatus:
				result.ConnectionStatus = source.ConnectionStatus
			}
		}
	}
	return result
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProbeHardwareGetResponse))
}

func (fieldMask *ProbeHardwareGetResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProbeHardwareUpdateRequest_FieldMask struct {
	Paths []ProbeHardwareUpdateRequest_FieldPath
}

func FullProbeHardwareUpdateRequest_FieldMask() *ProbeHardwareUpdateRequest_FieldMask {
	res := &ProbeHardwareUpdateRequest_FieldMask{}
	res.Paths = append(res.Paths, &ProbeHardwareUpdateRequest_FieldTerminalPath{selector: ProbeHardwareUpdateRequest_FieldPathSelectorProbeName})
	res.Paths = append(res.Paths, &ProbeHardwareUpdateRequest_FieldTerminalPath{selector: ProbeHardwareUpdateRequest_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &ProbeHardwareUpdateRequest_FieldTerminalPath{selector: ProbeHardwareUpdateRequest_FieldPathSelectorAccessToken})
	return res
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeHardwareUpdateRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeHardwareUpdateRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeHardwareUpdateRequest_FieldPath(raw)
	})
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Subtract(other *ProbeHardwareUpdateRequest_FieldMask) *ProbeHardwareUpdateRequest_FieldMask {
	result := &ProbeHardwareUpdateRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeHardwareUpdateRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProbeHardwareUpdateRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) FilterInputFields() *ProbeHardwareUpdateRequest_FieldMask {
	result := &ProbeHardwareUpdateRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeHardwareUpdateRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeHardwareUpdateRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProbeHardwareUpdateRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProbeHardwareUpdateRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) AppendPath(path ProbeHardwareUpdateRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeHardwareUpdateRequest_FieldPath))
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) GetPaths() []ProbeHardwareUpdateRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeHardwareUpdateRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Set(target, source *ProbeHardwareUpdateRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProbeHardwareUpdateRequest), source.(*ProbeHardwareUpdateRequest))
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) Project(source *ProbeHardwareUpdateRequest) *ProbeHardwareUpdateRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProbeHardwareUpdateRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeHardwareUpdateRequest_FieldTerminalPath:
			switch tp.selector {
			case ProbeHardwareUpdateRequest_FieldPathSelectorProbeName:
				result.ProbeName = source.ProbeName
			case ProbeHardwareUpdateRequest_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case ProbeHardwareUpdateRequest_FieldPathSelectorAccessToken:
				result.AccessToken = source.AccessToken
			}
		}
	}
	return result
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProbeHardwareUpdateRequest))
}

func (fieldMask *ProbeHardwareUpdateRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProbeHardwareUpdateResponse_FieldMask struct {
	Paths []ProbeHardwareUpdateResponse_FieldPath
}

func FullProbeHardwareUpdateResponse_FieldMask() *ProbeHardwareUpdateResponse_FieldMask {
	res := &ProbeHardwareUpdateResponse_FieldMask{}
	res.Paths = append(res.Paths, &ProbeHardwareUpdateResponse_FieldTerminalPath{selector: ProbeHardwareUpdateResponse_FieldPathSelectorSerialNumber})
	return res
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeHardwareUpdateResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeHardwareUpdateResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeHardwareUpdateResponse_FieldPath(raw)
	})
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Subtract(other *ProbeHardwareUpdateResponse_FieldMask) *ProbeHardwareUpdateResponse_FieldMask {
	result := &ProbeHardwareUpdateResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeHardwareUpdateResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProbeHardwareUpdateResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) FilterInputFields() *ProbeHardwareUpdateResponse_FieldMask {
	result := &ProbeHardwareUpdateResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeHardwareUpdateResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeHardwareUpdateResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProbeHardwareUpdateResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProbeHardwareUpdateResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) AppendPath(path ProbeHardwareUpdateResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeHardwareUpdateResponse_FieldPath))
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) GetPaths() []ProbeHardwareUpdateResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeHardwareUpdateResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Set(target, source *ProbeHardwareUpdateResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProbeHardwareUpdateResponse), source.(*ProbeHardwareUpdateResponse))
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) Project(source *ProbeHardwareUpdateResponse) *ProbeHardwareUpdateResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProbeHardwareUpdateResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeHardwareUpdateResponse_FieldTerminalPath:
			switch tp.selector {
			case ProbeHardwareUpdateResponse_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			}
		}
	}
	return result
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProbeHardwareUpdateResponse))
}

func (fieldMask *ProbeHardwareUpdateResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
