// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/probe.proto
// DO NOT EDIT!!!

package probe

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	ntt_memo "github.com/cloudwan/edgelq-sdk/common/types/memo"
	ntt_meta "github.com/cloudwan/edgelq-sdk/common/types/meta"
	devices_device "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/device"
	iam_service_account "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/service_account"
	common "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/common"
	probe_group "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/probe_group"
	project "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/project"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &ntt_memo.Memo{}
	_ = &ntt_meta.Meta{}
	_ = &devices_device.Device{}
	_ = &iam_service_account.ServiceAccount{}
	_ = &timestamp.Timestamp{}
	_ = &common.SoftwareVersion{}
	_ = &probe_group.ProbeGroup{}
	_ = &project.Project{}
)

type Probe_FieldMask struct {
	Paths []Probe_FieldPath
}

func FullProbe_FieldMask() *Probe_FieldMask {
	res := &Probe_FieldMask{}
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorDisplayName})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorLowerDisplayName})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorSpec})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &Probe_FieldTerminalPath{selector: Probe_FieldPathSelectorMemo})
	return res
}

func (fieldMask *Probe_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbe_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Probe_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbe_FieldPath(raw)
	})
}

func (fieldMask *Probe_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_FieldMask) Subtract(other *Probe_FieldMask) *Probe_FieldMask {
	result := &Probe_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[Probe_FieldPathSelector]gotenobject.FieldMask{
		Probe_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
		Probe_FieldPathSelectorSpec:     &Probe_Spec_FieldMask{},
		Probe_FieldPathSelectorStatus:   &Probe_Status_FieldMask{},
		Probe_FieldPathSelectorMemo:     &ntt_memo.Memo_FieldMask{},
	}
	mySubMasks := map[Probe_FieldPathSelector]gotenobject.FieldMask{
		Probe_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
		Probe_FieldPathSelectorSpec:     &Probe_Spec_FieldMask{},
		Probe_FieldPathSelectorStatus:   &Probe_Status_FieldMask{},
		Probe_FieldPathSelectorMemo:     &ntt_memo.Memo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Probe_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Probe_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Probe_FieldTerminalPath); ok {
					switch tp.selector {
					case Probe_FieldPathSelectorMetadata:
						mySubMasks[Probe_FieldPathSelectorMetadata] = ntt_meta.FullMeta_FieldMask()
					case Probe_FieldPathSelectorSpec:
						mySubMasks[Probe_FieldPathSelectorSpec] = FullProbe_Spec_FieldMask()
					case Probe_FieldPathSelectorStatus:
						mySubMasks[Probe_FieldPathSelectorStatus] = FullProbe_Status_FieldMask()
					case Probe_FieldPathSelectorMemo:
						mySubMasks[Probe_FieldPathSelectorMemo] = ntt_memo.FullMemo_FieldMask()
					}
				} else if tp, ok := path.(*Probe_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_FieldMask) FilterInputFields() *Probe_FieldMask {
	result := &Probe_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Probe_FieldPathSelectorMetadata:
			if _, ok := path.(*Probe_FieldTerminalPath); ok {
				for _, subpath := range ntt_meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Probe_FieldSubPath); ok {
				selectedMask := &ntt_meta.Meta_FieldMask{
					Paths: []ntt_meta.Meta_FieldPath{sub.subPath.(ntt_meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: Probe_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		case Probe_FieldPathSelectorSpec:
			if _, ok := path.(*Probe_FieldTerminalPath); ok {
				for _, subpath := range FullProbe_Spec_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Probe_FieldSubPath); ok {
				selectedMask := &Probe_Spec_FieldMask{
					Paths: []ProbeSpec_FieldPath{sub.subPath.(ProbeSpec_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: Probe_FieldPathSelectorSpec, subPath: allowedPath})
				}
			}
		case Probe_FieldPathSelectorMemo:
			if _, ok := path.(*Probe_FieldTerminalPath); ok {
				for _, subpath := range ntt_memo.FullMemo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Probe_FieldSubPath); ok {
				selectedMask := &ntt_memo.Memo_FieldMask{
					Paths: []ntt_memo.Memo_FieldPath{sub.subPath.(ntt_memo.Memo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Probe_FieldSubPath{selector: Probe_FieldPathSelectorMemo, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Probe_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbe_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_FieldMask) AppendPath(path Probe_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Probe_FieldPath))
}

func (fieldMask *Probe_FieldMask) GetPaths() []Probe_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbe_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_FieldMask) Set(target, source *Probe) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe), source.(*Probe))
}

func (fieldMask *Probe_FieldMask) Project(source *Probe) *Probe {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe{}
	metadataMask := &ntt_meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	specMask := &Probe_Spec_FieldMask{}
	wholeSpecAccepted := false
	statusMask := &Probe_Status_FieldMask{}
	wholeStatusAccepted := false
	memoMask := &ntt_memo.Memo_FieldMask{}
	wholeMemoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Probe_FieldTerminalPath:
			switch tp.selector {
			case Probe_FieldPathSelectorName:
				result.Name = source.Name
			case Probe_FieldPathSelectorDisplayName:
				result.DisplayName = source.DisplayName
			case Probe_FieldPathSelectorLowerDisplayName:
				result.LowerDisplayName = source.LowerDisplayName
			case Probe_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Probe_FieldPathSelectorSpec:
				result.Spec = source.Spec
				wholeSpecAccepted = true
			case Probe_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case Probe_FieldPathSelectorMemo:
				result.Memo = source.Memo
				wholeMemoAccepted = true
			}
		case *Probe_FieldSubPath:
			switch tp.selector {
			case Probe_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(ntt_meta.Meta_FieldPath))
			case Probe_FieldPathSelectorSpec:
				specMask.AppendPath(tp.subPath.(ProbeSpec_FieldPath))
			case Probe_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(ProbeStatus_FieldPath))
			case Probe_FieldPathSelectorMemo:
				memoMask.AppendPath(tp.subPath.(ntt_memo.Memo_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeSpecAccepted == false && len(specMask.Paths) > 0 {
		result.Spec = specMask.Project(source.GetSpec())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholeMemoAccepted == false && len(memoMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemo() {
			result.Memo = append(result.Memo, memoMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Probe_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe))
}

func (fieldMask *Probe_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_FieldMask struct {
	Paths []ProbeSpec_FieldPath
}

func FullProbe_Spec_FieldMask() *Probe_Spec_FieldMask {
	res := &Probe_Spec_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorProbeGroup})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorDevice})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorPrimaryLocation})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorLocationDiscovery})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorContactInfo})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorActivation})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorDisableSpeedtest})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorAccessToken})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorAgentType})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorExternalIpCheckUrl})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorTargetServers})
	res.Paths = append(res.Paths, &ProbeSpec_FieldTerminalPath{selector: ProbeSpec_FieldPathSelectorPcapSettings})
	return res
}

func (fieldMask *Probe_Spec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 13)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpec_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_FieldMask) Subtract(other *Probe_Spec_FieldMask) *Probe_Spec_FieldMask {
	result := &Probe_Spec_FieldMask{}
	removedSelectors := make([]bool, 13)
	otherSubMasks := map[ProbeSpec_FieldPathSelector]gotenobject.FieldMask{
		ProbeSpec_FieldPathSelectorPrimaryLocation:   &common.Location_FieldMask{},
		ProbeSpec_FieldPathSelectorLocationDiscovery: &common.LocationDiscoverySpec_FieldMask{},
		ProbeSpec_FieldPathSelectorContactInfo:       &common.ContactInformation_FieldMask{},
		ProbeSpec_FieldPathSelectorActivation:        &Probe_Spec_ActivationSpec_FieldMask{},
		ProbeSpec_FieldPathSelectorAccessToken:       &Probe_Spec_AccessTokenSpec_FieldMask{},
		ProbeSpec_FieldPathSelectorTargetServers:     &Probe_Spec_TargetServers_FieldMask{},
		ProbeSpec_FieldPathSelectorPcapSettings:      &Probe_Spec_PcapSettings_FieldMask{},
	}
	mySubMasks := map[ProbeSpec_FieldPathSelector]gotenobject.FieldMask{
		ProbeSpec_FieldPathSelectorPrimaryLocation:   &common.Location_FieldMask{},
		ProbeSpec_FieldPathSelectorLocationDiscovery: &common.LocationDiscoverySpec_FieldMask{},
		ProbeSpec_FieldPathSelectorContactInfo:       &common.ContactInformation_FieldMask{},
		ProbeSpec_FieldPathSelectorActivation:        &Probe_Spec_ActivationSpec_FieldMask{},
		ProbeSpec_FieldPathSelectorAccessToken:       &Probe_Spec_AccessTokenSpec_FieldMask{},
		ProbeSpec_FieldPathSelectorTargetServers:     &Probe_Spec_TargetServers_FieldMask{},
		ProbeSpec_FieldPathSelectorPcapSettings:      &Probe_Spec_PcapSettings_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProbeSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProbeSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case ProbeSpec_FieldPathSelectorPrimaryLocation:
						mySubMasks[ProbeSpec_FieldPathSelectorPrimaryLocation] = common.FullLocation_FieldMask()
					case ProbeSpec_FieldPathSelectorLocationDiscovery:
						mySubMasks[ProbeSpec_FieldPathSelectorLocationDiscovery] = common.FullLocationDiscoverySpec_FieldMask()
					case ProbeSpec_FieldPathSelectorContactInfo:
						mySubMasks[ProbeSpec_FieldPathSelectorContactInfo] = common.FullContactInformation_FieldMask()
					case ProbeSpec_FieldPathSelectorActivation:
						mySubMasks[ProbeSpec_FieldPathSelectorActivation] = FullProbe_Spec_ActivationSpec_FieldMask()
					case ProbeSpec_FieldPathSelectorAccessToken:
						mySubMasks[ProbeSpec_FieldPathSelectorAccessToken] = FullProbe_Spec_AccessTokenSpec_FieldMask()
					case ProbeSpec_FieldPathSelectorTargetServers:
						mySubMasks[ProbeSpec_FieldPathSelectorTargetServers] = FullProbe_Spec_TargetServers_FieldMask()
					case ProbeSpec_FieldPathSelectorPcapSettings:
						mySubMasks[ProbeSpec_FieldPathSelectorPcapSettings] = FullProbe_Spec_PcapSettings_FieldMask()
					}
				} else if tp, ok := path.(*ProbeSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProbeSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_FieldMask) FilterInputFields() *Probe_Spec_FieldMask {
	result := &Probe_Spec_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ProbeSpec_FieldPathSelectorActivation:
			if _, ok := path.(*ProbeSpec_FieldTerminalPath); ok {
				for _, subpath := range FullProbe_Spec_ActivationSpec_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ProbeSpec_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ProbeSpec_FieldSubPath); ok {
				selectedMask := &Probe_Spec_ActivationSpec_FieldMask{
					Paths: []ProbeSpecActivationSpec_FieldPath{sub.subPath.(ProbeSpecActivationSpec_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ProbeSpec_FieldSubPath{selector: ProbeSpec_FieldPathSelectorActivation, subPath: allowedPath})
				}
			}
		case ProbeSpec_FieldPathSelectorAccessToken:
			if _, ok := path.(*ProbeSpec_FieldTerminalPath); ok {
				for _, subpath := range FullProbe_Spec_AccessTokenSpec_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ProbeSpec_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ProbeSpec_FieldSubPath); ok {
				selectedMask := &Probe_Spec_AccessTokenSpec_FieldMask{
					Paths: []ProbeSpecAccessTokenSpec_FieldPath{sub.subPath.(ProbeSpecAccessTokenSpec_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ProbeSpec_FieldSubPath{selector: ProbeSpec_FieldPathSelectorAccessToken, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_FieldMask) AppendPath(path ProbeSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpec_FieldPath))
}

func (fieldMask *Probe_Spec_FieldMask) GetPaths() []ProbeSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_FieldMask) Set(target, source *Probe_Spec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec), source.(*Probe_Spec))
}

func (fieldMask *Probe_Spec_FieldMask) Project(source *Probe_Spec) *Probe_Spec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec{}
	primaryLocationMask := &common.Location_FieldMask{}
	wholePrimaryLocationAccepted := false
	locationDiscoveryMask := &common.LocationDiscoverySpec_FieldMask{}
	wholeLocationDiscoveryAccepted := false
	contactInfoMask := &common.ContactInformation_FieldMask{}
	wholeContactInfoAccepted := false
	activationMask := &Probe_Spec_ActivationSpec_FieldMask{}
	wholeActivationAccepted := false
	accessTokenMask := &Probe_Spec_AccessTokenSpec_FieldMask{}
	wholeAccessTokenAccepted := false
	targetServersMask := &Probe_Spec_TargetServers_FieldMask{}
	wholeTargetServersAccepted := false
	pcapSettingsMask := &Probe_Spec_PcapSettings_FieldMask{}
	wholePcapSettingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpec_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpec_FieldPathSelectorProbeGroup:
				result.ProbeGroup = source.ProbeGroup
			case ProbeSpec_FieldPathSelectorDevice:
				result.Device = source.Device
			case ProbeSpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case ProbeSpec_FieldPathSelectorPrimaryLocation:
				result.PrimaryLocation = source.PrimaryLocation
				wholePrimaryLocationAccepted = true
			case ProbeSpec_FieldPathSelectorLocationDiscovery:
				result.LocationDiscovery = source.LocationDiscovery
				wholeLocationDiscoveryAccepted = true
			case ProbeSpec_FieldPathSelectorContactInfo:
				result.ContactInfo = source.ContactInfo
				wholeContactInfoAccepted = true
			case ProbeSpec_FieldPathSelectorActivation:
				result.Activation = source.Activation
				wholeActivationAccepted = true
			case ProbeSpec_FieldPathSelectorDisableSpeedtest:
				result.DisableSpeedtest = source.DisableSpeedtest
			case ProbeSpec_FieldPathSelectorAccessToken:
				result.AccessToken = source.AccessToken
				wholeAccessTokenAccepted = true
			case ProbeSpec_FieldPathSelectorAgentType:
				result.AgentType = source.AgentType
			case ProbeSpec_FieldPathSelectorExternalIpCheckUrl:
				result.ExternalIpCheckUrl = source.ExternalIpCheckUrl
			case ProbeSpec_FieldPathSelectorTargetServers:
				result.TargetServers = source.TargetServers
				wholeTargetServersAccepted = true
			case ProbeSpec_FieldPathSelectorPcapSettings:
				result.PcapSettings = source.PcapSettings
				wholePcapSettingsAccepted = true
			}
		case *ProbeSpec_FieldSubPath:
			switch tp.selector {
			case ProbeSpec_FieldPathSelectorPrimaryLocation:
				primaryLocationMask.AppendPath(tp.subPath.(common.Location_FieldPath))
			case ProbeSpec_FieldPathSelectorLocationDiscovery:
				locationDiscoveryMask.AppendPath(tp.subPath.(common.LocationDiscoverySpec_FieldPath))
			case ProbeSpec_FieldPathSelectorContactInfo:
				contactInfoMask.AppendPath(tp.subPath.(common.ContactInformation_FieldPath))
			case ProbeSpec_FieldPathSelectorActivation:
				activationMask.AppendPath(tp.subPath.(ProbeSpecActivationSpec_FieldPath))
			case ProbeSpec_FieldPathSelectorAccessToken:
				accessTokenMask.AppendPath(tp.subPath.(ProbeSpecAccessTokenSpec_FieldPath))
			case ProbeSpec_FieldPathSelectorTargetServers:
				targetServersMask.AppendPath(tp.subPath.(ProbeSpecTargetServers_FieldPath))
			case ProbeSpec_FieldPathSelectorPcapSettings:
				pcapSettingsMask.AppendPath(tp.subPath.(ProbeSpecPcapSettings_FieldPath))
			}
		}
	}
	if wholePrimaryLocationAccepted == false && len(primaryLocationMask.Paths) > 0 {
		result.PrimaryLocation = primaryLocationMask.Project(source.GetPrimaryLocation())
	}
	if wholeLocationDiscoveryAccepted == false && len(locationDiscoveryMask.Paths) > 0 {
		result.LocationDiscovery = locationDiscoveryMask.Project(source.GetLocationDiscovery())
	}
	if wholeContactInfoAccepted == false && len(contactInfoMask.Paths) > 0 {
		result.ContactInfo = contactInfoMask.Project(source.GetContactInfo())
	}
	if wholeActivationAccepted == false && len(activationMask.Paths) > 0 {
		result.Activation = activationMask.Project(source.GetActivation())
	}
	if wholeAccessTokenAccepted == false && len(accessTokenMask.Paths) > 0 {
		result.AccessToken = accessTokenMask.Project(source.GetAccessToken())
	}
	if wholeTargetServersAccepted == false && len(targetServersMask.Paths) > 0 {
		result.TargetServers = targetServersMask.Project(source.GetTargetServers())
	}
	if wholePcapSettingsAccepted == false && len(pcapSettingsMask.Paths) > 0 {
		result.PcapSettings = pcapSettingsMask.Project(source.GetPcapSettings())
	}
	return result
}

func (fieldMask *Probe_Spec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec))
}

func (fieldMask *Probe_Spec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_FieldMask struct {
	Paths []ProbeStatus_FieldPath
}

func FullProbe_Status_FieldMask() *Probe_Status_FieldMask {
	res := &Probe_Status_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorExternalIpAddressV4})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorExternalIpAddressV6})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorExternalHostname})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorAsInfo})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorCarrier})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorActiveLocation})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorDiscoveredLocation})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorSoftwareVersion})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorSystemInfo})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorActivation})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorConnection})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorConnectionStatusChangeTime})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorBandwidth})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorNetworkInterfaces})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorAgentType})
	res.Paths = append(res.Paths, &ProbeStatus_FieldTerminalPath{selector: ProbeStatus_FieldPathSelectorProxyConfig})
	return res
}

func (fieldMask *Probe_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 16)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatus_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_FieldMask) Subtract(other *Probe_Status_FieldMask) *Probe_Status_FieldMask {
	result := &Probe_Status_FieldMask{}
	removedSelectors := make([]bool, 16)
	otherSubMasks := map[ProbeStatus_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatus_FieldPathSelectorAsInfo:             &common.ASInfo_FieldMask{},
		ProbeStatus_FieldPathSelectorCarrier:            &common.Carrier_FieldMask{},
		ProbeStatus_FieldPathSelectorActiveLocation:     &common.Location_FieldMask{},
		ProbeStatus_FieldPathSelectorDiscoveredLocation: &common.Location_FieldMask{},
		ProbeStatus_FieldPathSelectorSoftwareVersion:    &common.SoftwareVersion_FieldMask{},
		ProbeStatus_FieldPathSelectorSystemInfo:         &Probe_Status_System_FieldMask{},
		ProbeStatus_FieldPathSelectorActivation:         &Probe_Status_ActivationState_FieldMask{},
		ProbeStatus_FieldPathSelectorBandwidth:          &Probe_Status_Bandwidth_FieldMask{},
		ProbeStatus_FieldPathSelectorProxyConfig:        &Probe_Status_ProxyConfig_FieldMask{},
	}
	mySubMasks := map[ProbeStatus_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatus_FieldPathSelectorAsInfo:             &common.ASInfo_FieldMask{},
		ProbeStatus_FieldPathSelectorCarrier:            &common.Carrier_FieldMask{},
		ProbeStatus_FieldPathSelectorActiveLocation:     &common.Location_FieldMask{},
		ProbeStatus_FieldPathSelectorDiscoveredLocation: &common.Location_FieldMask{},
		ProbeStatus_FieldPathSelectorSoftwareVersion:    &common.SoftwareVersion_FieldMask{},
		ProbeStatus_FieldPathSelectorSystemInfo:         &Probe_Status_System_FieldMask{},
		ProbeStatus_FieldPathSelectorActivation:         &Probe_Status_ActivationState_FieldMask{},
		ProbeStatus_FieldPathSelectorBandwidth:          &Probe_Status_Bandwidth_FieldMask{},
		ProbeStatus_FieldPathSelectorProxyConfig:        &Probe_Status_ProxyConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProbeStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProbeStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case ProbeStatus_FieldPathSelectorAsInfo:
						mySubMasks[ProbeStatus_FieldPathSelectorAsInfo] = common.FullASInfo_FieldMask()
					case ProbeStatus_FieldPathSelectorCarrier:
						mySubMasks[ProbeStatus_FieldPathSelectorCarrier] = common.FullCarrier_FieldMask()
					case ProbeStatus_FieldPathSelectorActiveLocation:
						mySubMasks[ProbeStatus_FieldPathSelectorActiveLocation] = common.FullLocation_FieldMask()
					case ProbeStatus_FieldPathSelectorDiscoveredLocation:
						mySubMasks[ProbeStatus_FieldPathSelectorDiscoveredLocation] = common.FullLocation_FieldMask()
					case ProbeStatus_FieldPathSelectorSoftwareVersion:
						mySubMasks[ProbeStatus_FieldPathSelectorSoftwareVersion] = common.FullSoftwareVersion_FieldMask()
					case ProbeStatus_FieldPathSelectorSystemInfo:
						mySubMasks[ProbeStatus_FieldPathSelectorSystemInfo] = FullProbe_Status_System_FieldMask()
					case ProbeStatus_FieldPathSelectorActivation:
						mySubMasks[ProbeStatus_FieldPathSelectorActivation] = FullProbe_Status_ActivationState_FieldMask()
					case ProbeStatus_FieldPathSelectorBandwidth:
						mySubMasks[ProbeStatus_FieldPathSelectorBandwidth] = FullProbe_Status_Bandwidth_FieldMask()
					case ProbeStatus_FieldPathSelectorProxyConfig:
						mySubMasks[ProbeStatus_FieldPathSelectorProxyConfig] = FullProbe_Status_ProxyConfig_FieldMask()
					}
				} else if tp, ok := path.(*ProbeStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProbeStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_FieldMask) FilterInputFields() *Probe_Status_FieldMask {
	result := &Probe_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_FieldMask) AppendPath(path ProbeStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatus_FieldPath))
}

func (fieldMask *Probe_Status_FieldMask) GetPaths() []ProbeStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_FieldMask) Set(target, source *Probe_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status), source.(*Probe_Status))
}

func (fieldMask *Probe_Status_FieldMask) Project(source *Probe_Status) *Probe_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status{}
	asInfoMask := &common.ASInfo_FieldMask{}
	wholeAsInfoAccepted := false
	carrierMask := &common.Carrier_FieldMask{}
	wholeCarrierAccepted := false
	activeLocationMask := &common.Location_FieldMask{}
	wholeActiveLocationAccepted := false
	discoveredLocationMask := &common.Location_FieldMask{}
	wholeDiscoveredLocationAccepted := false
	softwareVersionMask := &common.SoftwareVersion_FieldMask{}
	wholeSoftwareVersionAccepted := false
	systemInfoMask := &Probe_Status_System_FieldMask{}
	wholeSystemInfoAccepted := false
	activationMask := &Probe_Status_ActivationState_FieldMask{}
	wholeActivationAccepted := false
	bandwidthMask := &Probe_Status_Bandwidth_FieldMask{}
	wholeBandwidthAccepted := false
	proxyConfigMask := &Probe_Status_ProxyConfig_FieldMask{}
	wholeProxyConfigAccepted := false
	var networkInterfacesMapKeys []string
	wholeNetworkInterfacesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatus_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatus_FieldPathSelectorExternalIpAddressV4:
				result.ExternalIpAddressV4 = source.ExternalIpAddressV4
			case ProbeStatus_FieldPathSelectorExternalIpAddressV6:
				result.ExternalIpAddressV6 = source.ExternalIpAddressV6
			case ProbeStatus_FieldPathSelectorExternalHostname:
				result.ExternalHostname = source.ExternalHostname
			case ProbeStatus_FieldPathSelectorAsInfo:
				result.AsInfo = source.AsInfo
				wholeAsInfoAccepted = true
			case ProbeStatus_FieldPathSelectorCarrier:
				result.Carrier = source.Carrier
				wholeCarrierAccepted = true
			case ProbeStatus_FieldPathSelectorActiveLocation:
				result.ActiveLocation = source.ActiveLocation
				wholeActiveLocationAccepted = true
			case ProbeStatus_FieldPathSelectorDiscoveredLocation:
				result.DiscoveredLocation = source.DiscoveredLocation
				wholeDiscoveredLocationAccepted = true
			case ProbeStatus_FieldPathSelectorSoftwareVersion:
				result.SoftwareVersion = source.SoftwareVersion
				wholeSoftwareVersionAccepted = true
			case ProbeStatus_FieldPathSelectorSystemInfo:
				result.SystemInfo = source.SystemInfo
				wholeSystemInfoAccepted = true
			case ProbeStatus_FieldPathSelectorActivation:
				result.Activation = source.Activation
				wholeActivationAccepted = true
			case ProbeStatus_FieldPathSelectorConnection:
				result.Connection = source.Connection
			case ProbeStatus_FieldPathSelectorConnectionStatusChangeTime:
				result.ConnectionStatusChangeTime = source.ConnectionStatusChangeTime
			case ProbeStatus_FieldPathSelectorBandwidth:
				result.Bandwidth = source.Bandwidth
				wholeBandwidthAccepted = true
			case ProbeStatus_FieldPathSelectorNetworkInterfaces:
				result.NetworkInterfaces = source.NetworkInterfaces
				wholeNetworkInterfacesAccepted = true
			case ProbeStatus_FieldPathSelectorAgentType:
				result.AgentType = source.AgentType
			case ProbeStatus_FieldPathSelectorProxyConfig:
				result.ProxyConfig = source.ProxyConfig
				wholeProxyConfigAccepted = true
			}
		case *ProbeStatus_FieldSubPath:
			switch tp.selector {
			case ProbeStatus_FieldPathSelectorAsInfo:
				asInfoMask.AppendPath(tp.subPath.(common.ASInfo_FieldPath))
			case ProbeStatus_FieldPathSelectorCarrier:
				carrierMask.AppendPath(tp.subPath.(common.Carrier_FieldPath))
			case ProbeStatus_FieldPathSelectorActiveLocation:
				activeLocationMask.AppendPath(tp.subPath.(common.Location_FieldPath))
			case ProbeStatus_FieldPathSelectorDiscoveredLocation:
				discoveredLocationMask.AppendPath(tp.subPath.(common.Location_FieldPath))
			case ProbeStatus_FieldPathSelectorSoftwareVersion:
				softwareVersionMask.AppendPath(tp.subPath.(common.SoftwareVersion_FieldPath))
			case ProbeStatus_FieldPathSelectorSystemInfo:
				systemInfoMask.AppendPath(tp.subPath.(ProbeStatusSystem_FieldPath))
			case ProbeStatus_FieldPathSelectorActivation:
				activationMask.AppendPath(tp.subPath.(ProbeStatusActivationState_FieldPath))
			case ProbeStatus_FieldPathSelectorBandwidth:
				bandwidthMask.AppendPath(tp.subPath.(ProbeStatusBandwidth_FieldPath))
			case ProbeStatus_FieldPathSelectorProxyConfig:
				proxyConfigMask.AppendPath(tp.subPath.(ProbeStatusProxyConfig_FieldPath))
			}
		case *ProbeStatus_FieldPathMap:
			switch tp.selector {
			case ProbeStatus_FieldPathSelectorNetworkInterfaces:
				networkInterfacesMapKeys = append(networkInterfacesMapKeys, tp.key)
			}
		}
	}
	if wholeAsInfoAccepted == false && len(asInfoMask.Paths) > 0 {
		result.AsInfo = asInfoMask.Project(source.GetAsInfo())
	}
	if wholeCarrierAccepted == false && len(carrierMask.Paths) > 0 {
		result.Carrier = carrierMask.Project(source.GetCarrier())
	}
	if wholeActiveLocationAccepted == false && len(activeLocationMask.Paths) > 0 {
		result.ActiveLocation = activeLocationMask.Project(source.GetActiveLocation())
	}
	if wholeDiscoveredLocationAccepted == false && len(discoveredLocationMask.Paths) > 0 {
		result.DiscoveredLocation = discoveredLocationMask.Project(source.GetDiscoveredLocation())
	}
	if wholeSoftwareVersionAccepted == false && len(softwareVersionMask.Paths) > 0 {
		result.SoftwareVersion = softwareVersionMask.Project(source.GetSoftwareVersion())
	}
	if wholeSystemInfoAccepted == false && len(systemInfoMask.Paths) > 0 {
		result.SystemInfo = systemInfoMask.Project(source.GetSystemInfo())
	}
	if wholeActivationAccepted == false && len(activationMask.Paths) > 0 {
		result.Activation = activationMask.Project(source.GetActivation())
	}
	if wholeBandwidthAccepted == false && len(bandwidthMask.Paths) > 0 {
		result.Bandwidth = bandwidthMask.Project(source.GetBandwidth())
	}
	if wholeNetworkInterfacesAccepted == false && len(networkInterfacesMapKeys) > 0 && source.GetNetworkInterfaces() != nil {
		copiedMap := map[string]*Probe_Status_NetworkInterface{}
		sourceMap := source.GetNetworkInterfaces()
		for _, key := range networkInterfacesMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.NetworkInterfaces = copiedMap
	}
	if wholeProxyConfigAccepted == false && len(proxyConfigMask.Paths) > 0 {
		result.ProxyConfig = proxyConfigMask.Project(source.GetProxyConfig())
	}
	return result
}

func (fieldMask *Probe_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status))
}

func (fieldMask *Probe_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_ActivationSpec_FieldMask struct {
	Paths []ProbeSpecActivationSpec_FieldPath
}

func FullProbe_Spec_ActivationSpec_FieldMask() *Probe_Spec_ActivationSpec_FieldMask {
	res := &Probe_Spec_ActivationSpec_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecActivationSpec_FieldTerminalPath{selector: ProbeSpecActivationSpec_FieldPathSelectorType})
	res.Paths = append(res.Paths, &ProbeSpecActivationSpec_FieldTerminalPath{selector: ProbeSpecActivationSpec_FieldPathSelectorToken})
	res.Paths = append(res.Paths, &ProbeSpecActivationSpec_FieldTerminalPath{selector: ProbeSpecActivationSpec_FieldPathSelectorSendInvitationOnCreate})
	res.Paths = append(res.Paths, &ProbeSpecActivationSpec_FieldTerminalPath{selector: ProbeSpecActivationSpec_FieldPathSelectorInvitationExtras})
	res.Paths = append(res.Paths, &ProbeSpecActivationSpec_FieldTerminalPath{selector: ProbeSpecActivationSpec_FieldPathSelectorReusableToken})
	return res
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecActivationSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecActivationSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecActivationSpec_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Subtract(other *Probe_Spec_ActivationSpec_FieldMask) *Probe_Spec_ActivationSpec_FieldMask {
	result := &Probe_Spec_ActivationSpec_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecActivationSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_ActivationSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) FilterInputFields() *Probe_Spec_ActivationSpec_FieldMask {
	result := &Probe_Spec_ActivationSpec_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ProbeSpecActivationSpec_FieldPathSelectorToken:
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecActivationSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecActivationSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_ActivationSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_ActivationSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) AppendPath(path ProbeSpecActivationSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecActivationSpec_FieldPath))
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) GetPaths() []ProbeSpecActivationSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecActivationSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Set(target, source *Probe_Spec_ActivationSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_ActivationSpec), source.(*Probe_Spec_ActivationSpec))
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) Project(source *Probe_Spec_ActivationSpec) *Probe_Spec_ActivationSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_ActivationSpec{}
	var invitationExtrasMapKeys []string
	wholeInvitationExtrasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecActivationSpec_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecActivationSpec_FieldPathSelectorType:
				result.Type = source.Type
			case ProbeSpecActivationSpec_FieldPathSelectorToken:
				result.Token = source.Token
			case ProbeSpecActivationSpec_FieldPathSelectorSendInvitationOnCreate:
				result.SendInvitationOnCreate = source.SendInvitationOnCreate
			case ProbeSpecActivationSpec_FieldPathSelectorInvitationExtras:
				result.InvitationExtras = source.InvitationExtras
				wholeInvitationExtrasAccepted = true
			case ProbeSpecActivationSpec_FieldPathSelectorReusableToken:
				result.ReusableToken = source.ReusableToken
			}
		case *ProbeSpecActivationSpec_FieldPathMap:
			switch tp.selector {
			case ProbeSpecActivationSpec_FieldPathSelectorInvitationExtras:
				invitationExtrasMapKeys = append(invitationExtrasMapKeys, tp.key)
			}
		}
	}
	if wholeInvitationExtrasAccepted == false && len(invitationExtrasMapKeys) > 0 && source.GetInvitationExtras() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetInvitationExtras()
		for _, key := range invitationExtrasMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.InvitationExtras = copiedMap
	}
	return result
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_ActivationSpec))
}

func (fieldMask *Probe_Spec_ActivationSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_AccessTokenSpec_FieldMask struct {
	Paths []ProbeSpecAccessTokenSpec_FieldPath
}

func FullProbe_Spec_AccessTokenSpec_FieldMask() *Probe_Spec_AccessTokenSpec_FieldMask {
	res := &Probe_Spec_AccessTokenSpec_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecAccessTokenSpec_FieldTerminalPath{selector: ProbeSpecAccessTokenSpec_FieldPathSelectorEnable})
	res.Paths = append(res.Paths, &ProbeSpecAccessTokenSpec_FieldTerminalPath{selector: ProbeSpecAccessTokenSpec_FieldPathSelectorAccessToken})
	return res
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecAccessTokenSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecAccessTokenSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecAccessTokenSpec_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Subtract(other *Probe_Spec_AccessTokenSpec_FieldMask) *Probe_Spec_AccessTokenSpec_FieldMask {
	result := &Probe_Spec_AccessTokenSpec_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecAccessTokenSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_AccessTokenSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) FilterInputFields() *Probe_Spec_AccessTokenSpec_FieldMask {
	result := &Probe_Spec_AccessTokenSpec_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ProbeSpecAccessTokenSpec_FieldPathSelectorAccessToken:
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecAccessTokenSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecAccessTokenSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_AccessTokenSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_AccessTokenSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) AppendPath(path ProbeSpecAccessTokenSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecAccessTokenSpec_FieldPath))
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) GetPaths() []ProbeSpecAccessTokenSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecAccessTokenSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Set(target, source *Probe_Spec_AccessTokenSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_AccessTokenSpec), source.(*Probe_Spec_AccessTokenSpec))
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) Project(source *Probe_Spec_AccessTokenSpec) *Probe_Spec_AccessTokenSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_AccessTokenSpec{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecAccessTokenSpec_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecAccessTokenSpec_FieldPathSelectorEnable:
				result.Enable = source.Enable
			case ProbeSpecAccessTokenSpec_FieldPathSelectorAccessToken:
				result.AccessToken = source.AccessToken
			}
		}
	}
	return result
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_AccessTokenSpec))
}

func (fieldMask *Probe_Spec_AccessTokenSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_TargetServers_FieldMask struct {
	Paths []ProbeSpecTargetServers_FieldPath
}

func FullProbe_Spec_TargetServers_FieldMask() *Probe_Spec_TargetServers_FieldMask {
	res := &Probe_Spec_TargetServers_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecTargetServers_FieldTerminalPath{selector: ProbeSpecTargetServers_FieldPathSelectorIcmpTarget})
	res.Paths = append(res.Paths, &ProbeSpecTargetServers_FieldTerminalPath{selector: ProbeSpecTargetServers_FieldPathSelectorUdpTarget})
	res.Paths = append(res.Paths, &ProbeSpecTargetServers_FieldTerminalPath{selector: ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget})
	res.Paths = append(res.Paths, &ProbeSpecTargetServers_FieldTerminalPath{selector: ProbeSpecTargetServers_FieldPathSelectorTargetAddressType})
	res.Paths = append(res.Paths, &ProbeSpecTargetServers_FieldTerminalPath{selector: ProbeSpecTargetServers_FieldPathSelectorTargetIpVersion})
	return res
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_TargetServers_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecTargetServers_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecTargetServers_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecTargetServers_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Subtract(other *Probe_Spec_TargetServers_FieldMask) *Probe_Spec_TargetServers_FieldMask {
	result := &Probe_Spec_TargetServers_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ProbeSpecTargetServers_FieldPathSelector]gotenobject.FieldMask{
		ProbeSpecTargetServers_FieldPathSelectorIcmpTarget:      &Probe_Spec_TargetServers_IcmpTarget_FieldMask{},
		ProbeSpecTargetServers_FieldPathSelectorUdpTarget:       &Probe_Spec_TargetServers_UdpTarget_FieldMask{},
		ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget: &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{},
	}
	mySubMasks := map[ProbeSpecTargetServers_FieldPathSelector]gotenobject.FieldMask{
		ProbeSpecTargetServers_FieldPathSelectorIcmpTarget:      &Probe_Spec_TargetServers_IcmpTarget_FieldMask{},
		ProbeSpecTargetServers_FieldPathSelectorUdpTarget:       &Probe_Spec_TargetServers_UdpTarget_FieldMask{},
		ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget: &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecTargetServers_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProbeSpecTargetServers_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProbeSpecTargetServers_FieldTerminalPath); ok {
					switch tp.selector {
					case ProbeSpecTargetServers_FieldPathSelectorIcmpTarget:
						mySubMasks[ProbeSpecTargetServers_FieldPathSelectorIcmpTarget] = FullProbe_Spec_TargetServers_IcmpTarget_FieldMask()
					case ProbeSpecTargetServers_FieldPathSelectorUdpTarget:
						mySubMasks[ProbeSpecTargetServers_FieldPathSelectorUdpTarget] = FullProbe_Spec_TargetServers_UdpTarget_FieldMask()
					case ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget:
						mySubMasks[ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget] = FullProbe_Spec_TargetServers_SpeedTestTarget_FieldMask()
					}
				} else if tp, ok := path.(*ProbeSpecTargetServers_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProbeSpecTargetServers_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_TargetServers_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_TargetServers_FieldMask) FilterInputFields() *Probe_Spec_TargetServers_FieldMask {
	result := &Probe_Spec_TargetServers_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_TargetServers_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecTargetServers_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecTargetServers_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_TargetServers_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_TargetServers_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) AppendPath(path ProbeSpecTargetServers_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecTargetServers_FieldPath))
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) GetPaths() []ProbeSpecTargetServers_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecTargetServers_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Set(target, source *Probe_Spec_TargetServers) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_TargetServers), source.(*Probe_Spec_TargetServers))
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) Project(source *Probe_Spec_TargetServers) *Probe_Spec_TargetServers {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_TargetServers{}
	icmpTargetMask := &Probe_Spec_TargetServers_IcmpTarget_FieldMask{}
	wholeIcmpTargetAccepted := false
	udpTargetMask := &Probe_Spec_TargetServers_UdpTarget_FieldMask{}
	wholeUdpTargetAccepted := false
	speedTestTargetMask := &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{}
	wholeSpeedTestTargetAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecTargetServers_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecTargetServers_FieldPathSelectorIcmpTarget:
				result.IcmpTarget = source.IcmpTarget
				wholeIcmpTargetAccepted = true
			case ProbeSpecTargetServers_FieldPathSelectorUdpTarget:
				result.UdpTarget = source.UdpTarget
				wholeUdpTargetAccepted = true
			case ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget:
				result.SpeedTestTarget = source.SpeedTestTarget
				wholeSpeedTestTargetAccepted = true
			case ProbeSpecTargetServers_FieldPathSelectorTargetAddressType:
				result.TargetAddressType = source.TargetAddressType
			case ProbeSpecTargetServers_FieldPathSelectorTargetIpVersion:
				result.TargetIpVersion = source.TargetIpVersion
			}
		case *ProbeSpecTargetServers_FieldSubPath:
			switch tp.selector {
			case ProbeSpecTargetServers_FieldPathSelectorIcmpTarget:
				icmpTargetMask.AppendPath(tp.subPath.(ProbeSpecTargetServersIcmpTarget_FieldPath))
			case ProbeSpecTargetServers_FieldPathSelectorUdpTarget:
				udpTargetMask.AppendPath(tp.subPath.(ProbeSpecTargetServersUdpTarget_FieldPath))
			case ProbeSpecTargetServers_FieldPathSelectorSpeedTestTarget:
				speedTestTargetMask.AppendPath(tp.subPath.(ProbeSpecTargetServersSpeedTestTarget_FieldPath))
			}
		}
	}
	if wholeIcmpTargetAccepted == false && len(icmpTargetMask.Paths) > 0 {
		result.IcmpTarget = icmpTargetMask.Project(source.GetIcmpTarget())
	}
	if wholeUdpTargetAccepted == false && len(udpTargetMask.Paths) > 0 {
		result.UdpTarget = udpTargetMask.Project(source.GetUdpTarget())
	}
	if wholeSpeedTestTargetAccepted == false && len(speedTestTargetMask.Paths) > 0 {
		result.SpeedTestTarget = speedTestTargetMask.Project(source.GetSpeedTestTarget())
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_TargetServers))
}

func (fieldMask *Probe_Spec_TargetServers_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_PcapSettings_FieldMask struct {
	Paths []ProbeSpecPcapSettings_FieldPath
}

func FullProbe_Spec_PcapSettings_FieldMask() *Probe_Spec_PcapSettings_FieldMask {
	res := &Probe_Spec_PcapSettings_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecPcapSettings_FieldTerminalPath{selector: ProbeSpecPcapSettings_FieldPathSelectorEnable})
	res.Paths = append(res.Paths, &ProbeSpecPcapSettings_FieldTerminalPath{selector: ProbeSpecPcapSettings_FieldPathSelectorCaptureFullPacket})
	res.Paths = append(res.Paths, &ProbeSpecPcapSettings_FieldTerminalPath{selector: ProbeSpecPcapSettings_FieldPathSelectorCaptureAllPackets})
	res.Paths = append(res.Paths, &ProbeSpecPcapSettings_FieldTerminalPath{selector: ProbeSpecPcapSettings_FieldPathSelectorStopCaptureAllPacketsBy})
	return res
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_PcapSettings_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecPcapSettings_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecPcapSettings_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecPcapSettings_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Subtract(other *Probe_Spec_PcapSettings_FieldMask) *Probe_Spec_PcapSettings_FieldMask {
	result := &Probe_Spec_PcapSettings_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecPcapSettings_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_PcapSettings_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_PcapSettings_FieldMask) FilterInputFields() *Probe_Spec_PcapSettings_FieldMask {
	result := &Probe_Spec_PcapSettings_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_PcapSettings_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecPcapSettings_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecPcapSettings_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_PcapSettings_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_PcapSettings_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) AppendPath(path ProbeSpecPcapSettings_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecPcapSettings_FieldPath))
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) GetPaths() []ProbeSpecPcapSettings_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecPcapSettings_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Set(target, source *Probe_Spec_PcapSettings) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_PcapSettings), source.(*Probe_Spec_PcapSettings))
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) Project(source *Probe_Spec_PcapSettings) *Probe_Spec_PcapSettings {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_PcapSettings{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecPcapSettings_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecPcapSettings_FieldPathSelectorEnable:
				result.Enable = source.Enable
			case ProbeSpecPcapSettings_FieldPathSelectorCaptureFullPacket:
				result.CaptureFullPacket = source.CaptureFullPacket
			case ProbeSpecPcapSettings_FieldPathSelectorCaptureAllPackets:
				result.CaptureAllPackets = source.CaptureAllPackets
			case ProbeSpecPcapSettings_FieldPathSelectorStopCaptureAllPacketsBy:
				result.StopCaptureAllPacketsBy = source.StopCaptureAllPacketsBy
			}
		}
	}
	return result
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_PcapSettings))
}

func (fieldMask *Probe_Spec_PcapSettings_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_TargetServers_IcmpTarget_FieldMask struct {
	Paths []ProbeSpecTargetServersIcmpTarget_FieldPath
}

func FullProbe_Spec_TargetServers_IcmpTarget_FieldMask() *Probe_Spec_TargetServers_IcmpTarget_FieldMask {
	res := &Probe_Spec_TargetServers_IcmpTarget_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecTargetServersIcmpTarget_FieldTerminalPath{selector: ProbeSpecTargetServersIcmpTarget_FieldPathSelectorEnabled})
	return res
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecTargetServersIcmpTarget_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecTargetServersIcmpTarget_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecTargetServersIcmpTarget_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Subtract(other *Probe_Spec_TargetServers_IcmpTarget_FieldMask) *Probe_Spec_TargetServers_IcmpTarget_FieldMask {
	result := &Probe_Spec_TargetServers_IcmpTarget_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecTargetServersIcmpTarget_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_TargetServers_IcmpTarget_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) FilterInputFields() *Probe_Spec_TargetServers_IcmpTarget_FieldMask {
	result := &Probe_Spec_TargetServers_IcmpTarget_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecTargetServersIcmpTarget_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecTargetServersIcmpTarget_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_TargetServers_IcmpTarget_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_TargetServers_IcmpTarget_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) AppendPath(path ProbeSpecTargetServersIcmpTarget_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecTargetServersIcmpTarget_FieldPath))
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) GetPaths() []ProbeSpecTargetServersIcmpTarget_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecTargetServersIcmpTarget_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Set(target, source *Probe_Spec_TargetServers_IcmpTarget) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_TargetServers_IcmpTarget), source.(*Probe_Spec_TargetServers_IcmpTarget))
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) Project(source *Probe_Spec_TargetServers_IcmpTarget) *Probe_Spec_TargetServers_IcmpTarget {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_TargetServers_IcmpTarget{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecTargetServersIcmpTarget_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecTargetServersIcmpTarget_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			}
		}
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_TargetServers_IcmpTarget))
}

func (fieldMask *Probe_Spec_TargetServers_IcmpTarget_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_TargetServers_UdpTarget_FieldMask struct {
	Paths []ProbeSpecTargetServersUdpTarget_FieldPath
}

func FullProbe_Spec_TargetServers_UdpTarget_FieldMask() *Probe_Spec_TargetServers_UdpTarget_FieldMask {
	res := &Probe_Spec_TargetServers_UdpTarget_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecTargetServersUdpTarget_FieldTerminalPath{selector: ProbeSpecTargetServersUdpTarget_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &ProbeSpecTargetServersUdpTarget_FieldTerminalPath{selector: ProbeSpecTargetServersUdpTarget_FieldPathSelectorPort})
	return res
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecTargetServersUdpTarget_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecTargetServersUdpTarget_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecTargetServersUdpTarget_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Subtract(other *Probe_Spec_TargetServers_UdpTarget_FieldMask) *Probe_Spec_TargetServers_UdpTarget_FieldMask {
	result := &Probe_Spec_TargetServers_UdpTarget_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecTargetServersUdpTarget_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_TargetServers_UdpTarget_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) FilterInputFields() *Probe_Spec_TargetServers_UdpTarget_FieldMask {
	result := &Probe_Spec_TargetServers_UdpTarget_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecTargetServersUdpTarget_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecTargetServersUdpTarget_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_TargetServers_UdpTarget_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_TargetServers_UdpTarget_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) AppendPath(path ProbeSpecTargetServersUdpTarget_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecTargetServersUdpTarget_FieldPath))
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) GetPaths() []ProbeSpecTargetServersUdpTarget_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecTargetServersUdpTarget_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Set(target, source *Probe_Spec_TargetServers_UdpTarget) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_TargetServers_UdpTarget), source.(*Probe_Spec_TargetServers_UdpTarget))
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) Project(source *Probe_Spec_TargetServers_UdpTarget) *Probe_Spec_TargetServers_UdpTarget {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_TargetServers_UdpTarget{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecTargetServersUdpTarget_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecTargetServersUdpTarget_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case ProbeSpecTargetServersUdpTarget_FieldPathSelectorPort:
				result.Port = source.Port
			}
		}
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_TargetServers_UdpTarget))
}

func (fieldMask *Probe_Spec_TargetServers_UdpTarget_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Spec_TargetServers_SpeedTestTarget_FieldMask struct {
	Paths []ProbeSpecTargetServersSpeedTestTarget_FieldPath
}

func FullProbe_Spec_TargetServers_SpeedTestTarget_FieldMask() *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask {
	res := &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{}
	res.Paths = append(res.Paths, &ProbeSpecTargetServersSpeedTestTarget_FieldTerminalPath{selector: ProbeSpecTargetServersSpeedTestTarget_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &ProbeSpecTargetServersSpeedTestTarget_FieldTerminalPath{selector: ProbeSpecTargetServersSpeedTestTarget_FieldPathSelectorTcpPort})
	return res
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeSpecTargetServersSpeedTestTarget_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeSpecTargetServersSpeedTestTarget_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeSpecTargetServersSpeedTestTarget_FieldPath(raw)
	})
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Subtract(other *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask {
	result := &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeSpecTargetServersSpeedTestTarget_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Spec_TargetServers_SpeedTestTarget_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) FilterInputFields() *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask {
	result := &Probe_Spec_TargetServers_SpeedTestTarget_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeSpecTargetServersSpeedTestTarget_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeSpecTargetServersSpeedTestTarget_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) AppendPath(path ProbeSpecTargetServersSpeedTestTarget_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeSpecTargetServersSpeedTestTarget_FieldPath))
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) GetPaths() []ProbeSpecTargetServersSpeedTestTarget_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeSpecTargetServersSpeedTestTarget_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Set(target, source *Probe_Spec_TargetServers_SpeedTestTarget) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Spec_TargetServers_SpeedTestTarget), source.(*Probe_Spec_TargetServers_SpeedTestTarget))
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) Project(source *Probe_Spec_TargetServers_SpeedTestTarget) *Probe_Spec_TargetServers_SpeedTestTarget {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Spec_TargetServers_SpeedTestTarget{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeSpecTargetServersSpeedTestTarget_FieldTerminalPath:
			switch tp.selector {
			case ProbeSpecTargetServersSpeedTestTarget_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case ProbeSpecTargetServersSpeedTestTarget_FieldPathSelectorTcpPort:
				result.TcpPort = source.TcpPort
			}
		}
	}
	return result
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Spec_TargetServers_SpeedTestTarget))
}

func (fieldMask *Probe_Spec_TargetServers_SpeedTestTarget_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_System_FieldMask struct {
	Paths []ProbeStatusSystem_FieldPath
}

func FullProbe_Status_System_FieldMask() *Probe_Status_System_FieldMask {
	res := &Probe_Status_System_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorSku})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorFamily})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorPlatform})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorArchitecture})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorOs})
	res.Paths = append(res.Paths, &ProbeStatusSystem_FieldTerminalPath{selector: ProbeStatusSystem_FieldPathSelectorHostName})
	return res
}

func (fieldMask *Probe_Status_System_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_System_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_System_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusSystem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_System_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusSystem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_System_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusSystem_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_System_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_System_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_System_FieldMask) Subtract(other *Probe_Status_System_FieldMask) *Probe_Status_System_FieldMask {
	result := &Probe_Status_System_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[ProbeStatusSystem_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatusSystem_FieldPathSelectorOs: &Probe_Status_System_OS_FieldMask{},
	}
	mySubMasks := map[ProbeStatusSystem_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatusSystem_FieldPathSelectorOs: &Probe_Status_System_OS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusSystem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProbeStatusSystem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProbeStatusSystem_FieldTerminalPath); ok {
					switch tp.selector {
					case ProbeStatusSystem_FieldPathSelectorOs:
						mySubMasks[ProbeStatusSystem_FieldPathSelectorOs] = FullProbe_Status_System_OS_FieldMask()
					}
				} else if tp, ok := path.(*ProbeStatusSystem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProbeStatusSystem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_System_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_System_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_System_FieldMask) FilterInputFields() *Probe_Status_System_FieldMask {
	result := &Probe_Status_System_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_System_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_System_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusSystem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusSystem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_System_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_System_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_System_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_System_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_System_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_System_FieldMask) AppendPath(path ProbeStatusSystem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_System_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusSystem_FieldPath))
}

func (fieldMask *Probe_Status_System_FieldMask) GetPaths() []ProbeStatusSystem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_System_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_System_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusSystem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_System_FieldMask) Set(target, source *Probe_Status_System) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_System_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_System), source.(*Probe_Status_System))
}

func (fieldMask *Probe_Status_System_FieldMask) Project(source *Probe_Status_System) *Probe_Status_System {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_System{}
	osMask := &Probe_Status_System_OS_FieldMask{}
	wholeOsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusSystem_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusSystem_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case ProbeStatusSystem_FieldPathSelectorModel:
				result.Model = source.Model
			case ProbeStatusSystem_FieldPathSelectorSku:
				result.Sku = source.Sku
			case ProbeStatusSystem_FieldPathSelectorFamily:
				result.Family = source.Family
			case ProbeStatusSystem_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case ProbeStatusSystem_FieldPathSelectorPlatform:
				result.Platform = source.Platform
			case ProbeStatusSystem_FieldPathSelectorArchitecture:
				result.Architecture = source.Architecture
			case ProbeStatusSystem_FieldPathSelectorOs:
				result.Os = source.Os
				wholeOsAccepted = true
			case ProbeStatusSystem_FieldPathSelectorHostName:
				result.HostName = source.HostName
			}
		case *ProbeStatusSystem_FieldSubPath:
			switch tp.selector {
			case ProbeStatusSystem_FieldPathSelectorOs:
				osMask.AppendPath(tp.subPath.(ProbeStatusSystemOS_FieldPath))
			}
		}
	}
	if wholeOsAccepted == false && len(osMask.Paths) > 0 {
		result.Os = osMask.Project(source.GetOs())
	}
	return result
}

func (fieldMask *Probe_Status_System_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_System))
}

func (fieldMask *Probe_Status_System_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_ActivationState_FieldMask struct {
	Paths []ProbeStatusActivationState_FieldPath
}

func FullProbe_Status_ActivationState_FieldMask() *Probe_Status_ActivationState_FieldMask {
	res := &Probe_Status_ActivationState_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusActivationState_FieldTerminalPath{selector: ProbeStatusActivationState_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &ProbeStatusActivationState_FieldTerminalPath{selector: ProbeStatusActivationState_FieldPathSelectorCurrentSession})
	res.Paths = append(res.Paths, &ProbeStatusActivationState_FieldTerminalPath{selector: ProbeStatusActivationState_FieldPathSelectorServiceAccount})
	res.Paths = append(res.Paths, &ProbeStatusActivationState_FieldTerminalPath{selector: ProbeStatusActivationState_FieldPathSelectorLastInvitation})
	return res
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_ActivationState_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusActivationState_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusActivationState_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusActivationState_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Subtract(other *Probe_Status_ActivationState_FieldMask) *Probe_Status_ActivationState_FieldMask {
	result := &Probe_Status_ActivationState_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ProbeStatusActivationState_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatusActivationState_FieldPathSelectorCurrentSession: &Probe_Status_ActivationState_Session_FieldMask{},
		ProbeStatusActivationState_FieldPathSelectorLastInvitation: &Probe_Status_ActivationState_InvitationState_FieldMask{},
	}
	mySubMasks := map[ProbeStatusActivationState_FieldPathSelector]gotenobject.FieldMask{
		ProbeStatusActivationState_FieldPathSelectorCurrentSession: &Probe_Status_ActivationState_Session_FieldMask{},
		ProbeStatusActivationState_FieldPathSelectorLastInvitation: &Probe_Status_ActivationState_InvitationState_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusActivationState_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProbeStatusActivationState_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProbeStatusActivationState_FieldTerminalPath); ok {
					switch tp.selector {
					case ProbeStatusActivationState_FieldPathSelectorCurrentSession:
						mySubMasks[ProbeStatusActivationState_FieldPathSelectorCurrentSession] = FullProbe_Status_ActivationState_Session_FieldMask()
					case ProbeStatusActivationState_FieldPathSelectorLastInvitation:
						mySubMasks[ProbeStatusActivationState_FieldPathSelectorLastInvitation] = FullProbe_Status_ActivationState_InvitationState_FieldMask()
					}
				} else if tp, ok := path.(*ProbeStatusActivationState_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProbeStatusActivationState_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_ActivationState_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_ActivationState_FieldMask) FilterInputFields() *Probe_Status_ActivationState_FieldMask {
	result := &Probe_Status_ActivationState_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_ActivationState_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusActivationState_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusActivationState_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_ActivationState_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_ActivationState_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) AppendPath(path ProbeStatusActivationState_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusActivationState_FieldPath))
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) GetPaths() []ProbeStatusActivationState_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusActivationState_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Set(target, source *Probe_Status_ActivationState) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_ActivationState), source.(*Probe_Status_ActivationState))
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) Project(source *Probe_Status_ActivationState) *Probe_Status_ActivationState {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_ActivationState{}
	currentSessionMask := &Probe_Status_ActivationState_Session_FieldMask{}
	wholeCurrentSessionAccepted := false
	lastInvitationMask := &Probe_Status_ActivationState_InvitationState_FieldMask{}
	wholeLastInvitationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusActivationState_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusActivationState_FieldPathSelectorStatus:
				result.Status = source.Status
			case ProbeStatusActivationState_FieldPathSelectorCurrentSession:
				result.CurrentSession = source.CurrentSession
				wholeCurrentSessionAccepted = true
			case ProbeStatusActivationState_FieldPathSelectorServiceAccount:
				result.ServiceAccount = source.ServiceAccount
			case ProbeStatusActivationState_FieldPathSelectorLastInvitation:
				result.LastInvitation = source.LastInvitation
				wholeLastInvitationAccepted = true
			}
		case *ProbeStatusActivationState_FieldSubPath:
			switch tp.selector {
			case ProbeStatusActivationState_FieldPathSelectorCurrentSession:
				currentSessionMask.AppendPath(tp.subPath.(ProbeStatusActivationStateSession_FieldPath))
			case ProbeStatusActivationState_FieldPathSelectorLastInvitation:
				lastInvitationMask.AppendPath(tp.subPath.(ProbeStatusActivationStateInvitationState_FieldPath))
			}
		}
	}
	if wholeCurrentSessionAccepted == false && len(currentSessionMask.Paths) > 0 {
		result.CurrentSession = currentSessionMask.Project(source.GetCurrentSession())
	}
	if wholeLastInvitationAccepted == false && len(lastInvitationMask.Paths) > 0 {
		result.LastInvitation = lastInvitationMask.Project(source.GetLastInvitation())
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_ActivationState))
}

func (fieldMask *Probe_Status_ActivationState_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_Bandwidth_FieldMask struct {
	Paths []ProbeStatusBandwidth_FieldPath
}

func FullProbe_Status_Bandwidth_FieldMask() *Probe_Status_Bandwidth_FieldMask {
	res := &Probe_Status_Bandwidth_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusBandwidth_FieldTerminalPath{selector: ProbeStatusBandwidth_FieldPathSelectorUploadMbps})
	res.Paths = append(res.Paths, &ProbeStatusBandwidth_FieldTerminalPath{selector: ProbeStatusBandwidth_FieldPathSelectorDownloadMbps})
	res.Paths = append(res.Paths, &ProbeStatusBandwidth_FieldTerminalPath{selector: ProbeStatusBandwidth_FieldPathSelectorTestServer})
	res.Paths = append(res.Paths, &ProbeStatusBandwidth_FieldTerminalPath{selector: ProbeStatusBandwidth_FieldPathSelectorServerIpAddress})
	res.Paths = append(res.Paths, &ProbeStatusBandwidth_FieldTerminalPath{selector: ProbeStatusBandwidth_FieldPathSelectorLastReported})
	return res
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_Bandwidth_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusBandwidth_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusBandwidth_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusBandwidth_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Subtract(other *Probe_Status_Bandwidth_FieldMask) *Probe_Status_Bandwidth_FieldMask {
	result := &Probe_Status_Bandwidth_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusBandwidth_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_Bandwidth_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_Bandwidth_FieldMask) FilterInputFields() *Probe_Status_Bandwidth_FieldMask {
	result := &Probe_Status_Bandwidth_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_Bandwidth_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusBandwidth_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusBandwidth_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_Bandwidth_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_Bandwidth_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) AppendPath(path ProbeStatusBandwidth_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusBandwidth_FieldPath))
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) GetPaths() []ProbeStatusBandwidth_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusBandwidth_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Set(target, source *Probe_Status_Bandwidth) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_Bandwidth), source.(*Probe_Status_Bandwidth))
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) Project(source *Probe_Status_Bandwidth) *Probe_Status_Bandwidth {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_Bandwidth{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusBandwidth_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusBandwidth_FieldPathSelectorUploadMbps:
				result.UploadMbps = source.UploadMbps
			case ProbeStatusBandwidth_FieldPathSelectorDownloadMbps:
				result.DownloadMbps = source.DownloadMbps
			case ProbeStatusBandwidth_FieldPathSelectorTestServer:
				result.TestServer = source.TestServer
			case ProbeStatusBandwidth_FieldPathSelectorServerIpAddress:
				result.ServerIpAddress = source.ServerIpAddress
			case ProbeStatusBandwidth_FieldPathSelectorLastReported:
				result.LastReported = source.LastReported
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_Bandwidth))
}

func (fieldMask *Probe_Status_Bandwidth_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_NetworkInterface_FieldMask struct {
	Paths []ProbeStatusNetworkInterface_FieldPath
}

func FullProbe_Status_NetworkInterface_FieldMask() *Probe_Status_NetworkInterface_FieldMask {
	res := &Probe_Status_NetworkInterface_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusNetworkInterface_FieldTerminalPath{selector: ProbeStatusNetworkInterface_FieldPathSelectorInterfaceName})
	res.Paths = append(res.Paths, &ProbeStatusNetworkInterface_FieldTerminalPath{selector: ProbeStatusNetworkInterface_FieldPathSelectorIpAddressV4})
	res.Paths = append(res.Paths, &ProbeStatusNetworkInterface_FieldTerminalPath{selector: ProbeStatusNetworkInterface_FieldPathSelectorExternalIpAddressV4})
	res.Paths = append(res.Paths, &ProbeStatusNetworkInterface_FieldTerminalPath{selector: ProbeStatusNetworkInterface_FieldPathSelectorIpAddressV6})
	res.Paths = append(res.Paths, &ProbeStatusNetworkInterface_FieldTerminalPath{selector: ProbeStatusNetworkInterface_FieldPathSelectorExternalIpAddressV6})
	return res
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_NetworkInterface_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusNetworkInterface_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusNetworkInterface_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusNetworkInterface_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Subtract(other *Probe_Status_NetworkInterface_FieldMask) *Probe_Status_NetworkInterface_FieldMask {
	result := &Probe_Status_NetworkInterface_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusNetworkInterface_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_NetworkInterface_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_NetworkInterface_FieldMask) FilterInputFields() *Probe_Status_NetworkInterface_FieldMask {
	result := &Probe_Status_NetworkInterface_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_NetworkInterface_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusNetworkInterface_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusNetworkInterface_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_NetworkInterface_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_NetworkInterface_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) AppendPath(path ProbeStatusNetworkInterface_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusNetworkInterface_FieldPath))
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) GetPaths() []ProbeStatusNetworkInterface_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusNetworkInterface_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Set(target, source *Probe_Status_NetworkInterface) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_NetworkInterface), source.(*Probe_Status_NetworkInterface))
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) Project(source *Probe_Status_NetworkInterface) *Probe_Status_NetworkInterface {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_NetworkInterface{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusNetworkInterface_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusNetworkInterface_FieldPathSelectorInterfaceName:
				result.InterfaceName = source.InterfaceName
			case ProbeStatusNetworkInterface_FieldPathSelectorIpAddressV4:
				result.IpAddressV4 = source.IpAddressV4
			case ProbeStatusNetworkInterface_FieldPathSelectorExternalIpAddressV4:
				result.ExternalIpAddressV4 = source.ExternalIpAddressV4
			case ProbeStatusNetworkInterface_FieldPathSelectorIpAddressV6:
				result.IpAddressV6 = source.IpAddressV6
			case ProbeStatusNetworkInterface_FieldPathSelectorExternalIpAddressV6:
				result.ExternalIpAddressV6 = source.ExternalIpAddressV6
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_NetworkInterface))
}

func (fieldMask *Probe_Status_NetworkInterface_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_ProxyConfig_FieldMask struct {
	Paths []ProbeStatusProxyConfig_FieldPath
}

func FullProbe_Status_ProxyConfig_FieldMask() *Probe_Status_ProxyConfig_FieldMask {
	res := &Probe_Status_ProxyConfig_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusProxyConfig_FieldTerminalPath{selector: ProbeStatusProxyConfig_FieldPathSelectorHttpProxy})
	res.Paths = append(res.Paths, &ProbeStatusProxyConfig_FieldTerminalPath{selector: ProbeStatusProxyConfig_FieldPathSelectorHttpsProxy})
	res.Paths = append(res.Paths, &ProbeStatusProxyConfig_FieldTerminalPath{selector: ProbeStatusProxyConfig_FieldPathSelectorNoProxy})
	return res
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_ProxyConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusProxyConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusProxyConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusProxyConfig_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Subtract(other *Probe_Status_ProxyConfig_FieldMask) *Probe_Status_ProxyConfig_FieldMask {
	result := &Probe_Status_ProxyConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusProxyConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_ProxyConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_ProxyConfig_FieldMask) FilterInputFields() *Probe_Status_ProxyConfig_FieldMask {
	result := &Probe_Status_ProxyConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_ProxyConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusProxyConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusProxyConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_ProxyConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_ProxyConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) AppendPath(path ProbeStatusProxyConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusProxyConfig_FieldPath))
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) GetPaths() []ProbeStatusProxyConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusProxyConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Set(target, source *Probe_Status_ProxyConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_ProxyConfig), source.(*Probe_Status_ProxyConfig))
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) Project(source *Probe_Status_ProxyConfig) *Probe_Status_ProxyConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_ProxyConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusProxyConfig_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusProxyConfig_FieldPathSelectorHttpProxy:
				result.HttpProxy = source.HttpProxy
			case ProbeStatusProxyConfig_FieldPathSelectorHttpsProxy:
				result.HttpsProxy = source.HttpsProxy
			case ProbeStatusProxyConfig_FieldPathSelectorNoProxy:
				result.NoProxy = source.NoProxy
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_ProxyConfig))
}

func (fieldMask *Probe_Status_ProxyConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_System_OS_FieldMask struct {
	Paths []ProbeStatusSystemOS_FieldPath
}

func FullProbe_Status_System_OS_FieldMask() *Probe_Status_System_OS_FieldMask {
	res := &Probe_Status_System_OS_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusSystemOS_FieldTerminalPath{selector: ProbeStatusSystemOS_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ProbeStatusSystemOS_FieldTerminalPath{selector: ProbeStatusSystemOS_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &ProbeStatusSystemOS_FieldTerminalPath{selector: ProbeStatusSystemOS_FieldPathSelectorBuildVersion})
	res.Paths = append(res.Paths, &ProbeStatusSystemOS_FieldTerminalPath{selector: ProbeStatusSystemOS_FieldPathSelectorKernel})
	return res
}

func (fieldMask *Probe_Status_System_OS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_System_OS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_System_OS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusSystemOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_System_OS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusSystemOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_System_OS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusSystemOS_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_System_OS_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_System_OS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_System_OS_FieldMask) Subtract(other *Probe_Status_System_OS_FieldMask) *Probe_Status_System_OS_FieldMask {
	result := &Probe_Status_System_OS_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusSystemOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_System_OS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_System_OS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_System_OS_FieldMask) FilterInputFields() *Probe_Status_System_OS_FieldMask {
	result := &Probe_Status_System_OS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_System_OS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_System_OS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusSystemOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusSystemOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_System_OS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_System_OS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_System_OS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_System_OS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_System_OS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_System_OS_FieldMask) AppendPath(path ProbeStatusSystemOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_System_OS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusSystemOS_FieldPath))
}

func (fieldMask *Probe_Status_System_OS_FieldMask) GetPaths() []ProbeStatusSystemOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_System_OS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_System_OS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusSystemOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_System_OS_FieldMask) Set(target, source *Probe_Status_System_OS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_System_OS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_System_OS), source.(*Probe_Status_System_OS))
}

func (fieldMask *Probe_Status_System_OS_FieldMask) Project(source *Probe_Status_System_OS) *Probe_Status_System_OS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_System_OS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusSystemOS_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusSystemOS_FieldPathSelectorName:
				result.Name = source.Name
			case ProbeStatusSystemOS_FieldPathSelectorVersion:
				result.Version = source.Version
			case ProbeStatusSystemOS_FieldPathSelectorBuildVersion:
				result.BuildVersion = source.BuildVersion
			case ProbeStatusSystemOS_FieldPathSelectorKernel:
				result.Kernel = source.Kernel
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_System_OS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_System_OS))
}

func (fieldMask *Probe_Status_System_OS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_ActivationState_Session_FieldMask struct {
	Paths []ProbeStatusActivationStateSession_FieldPath
}

func FullProbe_Status_ActivationState_Session_FieldMask() *Probe_Status_ActivationState_Session_FieldMask {
	res := &Probe_Status_ActivationState_Session_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusActivationStateSession_FieldTerminalPath{selector: ProbeStatusActivationStateSession_FieldPathSelectorClientCookie})
	res.Paths = append(res.Paths, &ProbeStatusActivationStateSession_FieldTerminalPath{selector: ProbeStatusActivationStateSession_FieldPathSelectorLockDeadline})
	return res
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusActivationStateSession_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusActivationStateSession_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusActivationStateSession_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Subtract(other *Probe_Status_ActivationState_Session_FieldMask) *Probe_Status_ActivationState_Session_FieldMask {
	result := &Probe_Status_ActivationState_Session_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusActivationStateSession_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_ActivationState_Session_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) FilterInputFields() *Probe_Status_ActivationState_Session_FieldMask {
	result := &Probe_Status_ActivationState_Session_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusActivationStateSession_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusActivationStateSession_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_ActivationState_Session_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_ActivationState_Session_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) AppendPath(path ProbeStatusActivationStateSession_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusActivationStateSession_FieldPath))
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) GetPaths() []ProbeStatusActivationStateSession_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusActivationStateSession_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Set(target, source *Probe_Status_ActivationState_Session) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_ActivationState_Session), source.(*Probe_Status_ActivationState_Session))
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) Project(source *Probe_Status_ActivationState_Session) *Probe_Status_ActivationState_Session {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_ActivationState_Session{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusActivationStateSession_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusActivationStateSession_FieldPathSelectorClientCookie:
				result.ClientCookie = source.ClientCookie
			case ProbeStatusActivationStateSession_FieldPathSelectorLockDeadline:
				result.LockDeadline = source.LockDeadline
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_ActivationState_Session))
}

func (fieldMask *Probe_Status_ActivationState_Session_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Probe_Status_ActivationState_InvitationState_FieldMask struct {
	Paths []ProbeStatusActivationStateInvitationState_FieldPath
}

func FullProbe_Status_ActivationState_InvitationState_FieldMask() *Probe_Status_ActivationState_InvitationState_FieldMask {
	res := &Probe_Status_ActivationState_InvitationState_FieldMask{}
	res.Paths = append(res.Paths, &ProbeStatusActivationStateInvitationState_FieldTerminalPath{selector: ProbeStatusActivationStateInvitationState_FieldPathSelectorSentDate})
	res.Paths = append(res.Paths, &ProbeStatusActivationStateInvitationState_FieldTerminalPath{selector: ProbeStatusActivationStateInvitationState_FieldPathSelectorSender})
	return res
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseProbeStatusActivationStateInvitationState_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProbeStatusActivationStateInvitationState_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProbeStatusActivationStateInvitationState_FieldPath(raw)
	})
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) ProtoMessage() {}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Subtract(other *Probe_Status_ActivationState_InvitationState_FieldMask) *Probe_Status_ActivationState_InvitationState_FieldMask {
	result := &Probe_Status_ActivationState_InvitationState_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProbeStatusActivationStateInvitationState_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Probe_Status_ActivationState_InvitationState_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) FilterInputFields() *Probe_Status_ActivationState_InvitationState_FieldMask {
	result := &Probe_Status_ActivationState_InvitationState_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProbeStatusActivationStateInvitationState_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProbeStatusActivationStateInvitationState_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Probe_Status_ActivationState_InvitationState_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Probe_Status_ActivationState_InvitationState_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) AppendPath(path ProbeStatusActivationStateInvitationState_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProbeStatusActivationStateInvitationState_FieldPath))
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) GetPaths() []ProbeStatusActivationStateInvitationState_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProbeStatusActivationStateInvitationState_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Set(target, source *Probe_Status_ActivationState_InvitationState) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Probe_Status_ActivationState_InvitationState), source.(*Probe_Status_ActivationState_InvitationState))
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) Project(source *Probe_Status_ActivationState_InvitationState) *Probe_Status_ActivationState_InvitationState {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Probe_Status_ActivationState_InvitationState{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProbeStatusActivationStateInvitationState_FieldTerminalPath:
			switch tp.selector {
			case ProbeStatusActivationStateInvitationState_FieldPathSelectorSentDate:
				result.SentDate = source.SentDate
			case ProbeStatusActivationStateInvitationState_FieldPathSelectorSender:
				result.Sender = source.Sender
			}
		}
	}
	return result
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Probe_Status_ActivationState_InvitationState))
}

func (fieldMask *Probe_Status_ActivationState_InvitationState_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
