// Code generated by protoc-gen-goten-object
// File: watchdog/proto/v1alpha2/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	admin_area "github.com/cloudwan/watchdog-sdk/resources/v1alpha2/admin_area"
	duration "github.com/golang/protobuf/ptypes/duration"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	latlng "google.golang.org/genproto/googleapis/type/latlng"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = fmt.Stringer(nil)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = proto.Message(nil)
	_ = protoregistry.GlobalTypes
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldPath(nil)
)

// make sure we're using proto imports
var (
	_ = &duration.Duration{}
	_ = &wrappers.DoubleValue{}
	_ = &latlng.LatLng{}
	_ = &admin_area.BBox{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SoftwareVersion_FieldPath interface {
	gotenobject.FieldPath
	Selector() SoftwareVersion_FieldPathSelector
	Get(source *SoftwareVersion) []interface{}
	GetSingle(source *SoftwareVersion) (interface{}, bool)
	ClearValue(item *SoftwareVersion)

	// Those methods build corresponding SoftwareVersion_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SoftwareVersion_FieldPathValue
	WithIArrayOfValues(values interface{}) SoftwareVersion_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SoftwareVersion_FieldPathArrayItemValue
}

type SoftwareVersion_FieldPathSelector int32

const (
	SoftwareVersion_FieldPathSelectorVersion   SoftwareVersion_FieldPathSelector = 0
	SoftwareVersion_FieldPathSelectorCommitId  SoftwareVersion_FieldPathSelector = 1
	SoftwareVersion_FieldPathSelectorBuildDate SoftwareVersion_FieldPathSelector = 2
)

func (s SoftwareVersion_FieldPathSelector) String() string {
	switch s {
	case SoftwareVersion_FieldPathSelectorVersion:
		return "version"
	case SoftwareVersion_FieldPathSelectorCommitId:
		return "commit_id"
	case SoftwareVersion_FieldPathSelectorBuildDate:
		return "build_date"
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", s))
	}
}

func BuildSoftwareVersion_FieldPath(fp gotenobject.RawFieldPath) (SoftwareVersion_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SoftwareVersion")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "version":
			return &SoftwareVersion_FieldTerminalPath{selector: SoftwareVersion_FieldPathSelectorVersion}, nil
		case "commit_id", "commitId", "commit-id":
			return &SoftwareVersion_FieldTerminalPath{selector: SoftwareVersion_FieldPathSelectorCommitId}, nil
		case "build_date", "buildDate", "build-date":
			return &SoftwareVersion_FieldTerminalPath{selector: SoftwareVersion_FieldPathSelectorBuildDate}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SoftwareVersion", fp)
}

func ParseSoftwareVersion_FieldPath(rawField string) (SoftwareVersion_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSoftwareVersion_FieldPath(fp)
}

func MustParseSoftwareVersion_FieldPath(rawField string) SoftwareVersion_FieldPath {
	fp, err := ParseSoftwareVersion_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SoftwareVersion_FieldTerminalPath struct {
	selector SoftwareVersion_FieldPathSelector
}

var _ SoftwareVersion_FieldPath = (*SoftwareVersion_FieldTerminalPath)(nil)

func (fp *SoftwareVersion_FieldTerminalPath) Selector() SoftwareVersion_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SoftwareVersion_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SoftwareVersion_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SoftwareVersion
func (fp *SoftwareVersion_FieldTerminalPath) Get(source *SoftwareVersion) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SoftwareVersion_FieldPathSelectorVersion:
			values = append(values, source.Version)
		case SoftwareVersion_FieldPathSelectorCommitId:
			values = append(values, source.CommitId)
		case SoftwareVersion_FieldPathSelectorBuildDate:
			values = append(values, source.BuildDate)
		default:
			panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
		}
	}
	return
}

func (fp *SoftwareVersion_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SoftwareVersion))
}

// GetSingle returns value pointed by specific field of from source SoftwareVersion
func (fp *SoftwareVersion_FieldTerminalPath) GetSingle(source *SoftwareVersion) (interface{}, bool) {
	switch fp.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		return source.GetVersion(), source != nil
	case SoftwareVersion_FieldPathSelectorCommitId:
		return source.GetCommitId(), source != nil
	case SoftwareVersion_FieldPathSelectorBuildDate:
		return source.GetBuildDate(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
	}
}

func (fp *SoftwareVersion_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SoftwareVersion))
}

// GetDefault returns a default value of the field type
func (fp *SoftwareVersion_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		return ""
	case SoftwareVersion_FieldPathSelectorCommitId:
		return ""
	case SoftwareVersion_FieldPathSelectorBuildDate:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
	}
}

func (fp *SoftwareVersion_FieldTerminalPath) ClearValue(item *SoftwareVersion) {
	if item != nil {
		switch fp.selector {
		case SoftwareVersion_FieldPathSelectorVersion:
			item.Version = ""
		case SoftwareVersion_FieldPathSelectorCommitId:
			item.CommitId = ""
		case SoftwareVersion_FieldPathSelectorBuildDate:
			item.BuildDate = ""
		default:
			panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
		}
	}
}

func (fp *SoftwareVersion_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SoftwareVersion))
}

// IsLeaf - whether field path is holds simple value
func (fp *SoftwareVersion_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SoftwareVersion_FieldPathSelectorVersion ||
		fp.selector == SoftwareVersion_FieldPathSelectorCommitId ||
		fp.selector == SoftwareVersion_FieldPathSelectorBuildDate
}

func (fp *SoftwareVersion_FieldTerminalPath) WithIValue(value interface{}) SoftwareVersion_FieldPathValue {
	switch fp.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		return &SoftwareVersion_FieldTerminalPathValue{SoftwareVersion_FieldTerminalPath: *fp, value: value.(string)}
	case SoftwareVersion_FieldPathSelectorCommitId:
		return &SoftwareVersion_FieldTerminalPathValue{SoftwareVersion_FieldTerminalPath: *fp, value: value.(string)}
	case SoftwareVersion_FieldPathSelectorBuildDate:
		return &SoftwareVersion_FieldTerminalPathValue{SoftwareVersion_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
	}
}

func (fp *SoftwareVersion_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SoftwareVersion_FieldTerminalPath) WithIArrayOfValues(values interface{}) SoftwareVersion_FieldPathArrayOfValues {
	fpaov := &SoftwareVersion_FieldTerminalPathArrayOfValues{SoftwareVersion_FieldTerminalPath: *fp}
	switch fp.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		return &SoftwareVersion_FieldTerminalPathArrayOfValues{SoftwareVersion_FieldTerminalPath: *fp, values: values.([]string)}
	case SoftwareVersion_FieldPathSelectorCommitId:
		return &SoftwareVersion_FieldTerminalPathArrayOfValues{SoftwareVersion_FieldTerminalPath: *fp, values: values.([]string)}
	case SoftwareVersion_FieldPathSelectorBuildDate:
		return &SoftwareVersion_FieldTerminalPathArrayOfValues{SoftwareVersion_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
	}
	return fpaov
}

func (fp *SoftwareVersion_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SoftwareVersion_FieldTerminalPath) WithIArrayItemValue(value interface{}) SoftwareVersion_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fp.selector))
	}
}

func (fp *SoftwareVersion_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SoftwareVersion_FieldPathValue allows storing values for SoftwareVersion fields according to their type
type SoftwareVersion_FieldPathValue interface {
	SoftwareVersion_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SoftwareVersion)
	CompareWith(*SoftwareVersion) (cmp int, comparable bool)
}

func ParseSoftwareVersion_FieldPathValue(pathStr, valueStr string) (SoftwareVersion_FieldPathValue, error) {
	fp, err := ParseSoftwareVersion_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SoftwareVersion field path value from %s: %v", valueStr, err)
	}
	return fpv.(SoftwareVersion_FieldPathValue), nil
}

func MustParseSoftwareVersion_FieldPathValue(pathStr, valueStr string) SoftwareVersion_FieldPathValue {
	fpv, err := ParseSoftwareVersion_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SoftwareVersion_FieldTerminalPathValue struct {
	SoftwareVersion_FieldTerminalPath
	value interface{}
}

var _ SoftwareVersion_FieldPathValue = (*SoftwareVersion_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SoftwareVersion' as interface{}
func (fpv *SoftwareVersion_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SoftwareVersion_FieldTerminalPathValue) AsVersionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SoftwareVersion_FieldTerminalPathValue) AsCommitIdValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SoftwareVersion_FieldTerminalPathValue) AsBuildDateValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object SoftwareVersion
func (fpv *SoftwareVersion_FieldTerminalPathValue) SetTo(target **SoftwareVersion) {
	if *target == nil {
		*target = new(SoftwareVersion)
	}
	switch fpv.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		(*target).Version = fpv.value.(string)
	case SoftwareVersion_FieldPathSelectorCommitId:
		(*target).CommitId = fpv.value.(string)
	case SoftwareVersion_FieldPathSelectorBuildDate:
		(*target).BuildDate = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fpv.selector))
	}
}

func (fpv *SoftwareVersion_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SoftwareVersion)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SoftwareVersion_FieldTerminalPathValue' with the value under path in 'SoftwareVersion'.
func (fpv *SoftwareVersion_FieldTerminalPathValue) CompareWith(source *SoftwareVersion) (int, bool) {
	switch fpv.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		leftValue := fpv.value.(string)
		rightValue := source.GetVersion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SoftwareVersion_FieldPathSelectorCommitId:
		leftValue := fpv.value.(string)
		rightValue := source.GetCommitId()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SoftwareVersion_FieldPathSelectorBuildDate:
		leftValue := fpv.value.(string)
		rightValue := source.GetBuildDate()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SoftwareVersion: %d", fpv.selector))
	}
}

func (fpv *SoftwareVersion_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SoftwareVersion))
}

// SoftwareVersion_FieldPathArrayItemValue allows storing single item in Path-specific values for SoftwareVersion according to their type
// Present only for array (repeated) types.
type SoftwareVersion_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SoftwareVersion_FieldPath
	ContainsValue(*SoftwareVersion) bool
}

// ParseSoftwareVersion_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSoftwareVersion_FieldPathArrayItemValue(pathStr, valueStr string) (SoftwareVersion_FieldPathArrayItemValue, error) {
	fp, err := ParseSoftwareVersion_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SoftwareVersion field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SoftwareVersion_FieldPathArrayItemValue), nil
}

func MustParseSoftwareVersion_FieldPathArrayItemValue(pathStr, valueStr string) SoftwareVersion_FieldPathArrayItemValue {
	fpaiv, err := ParseSoftwareVersion_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SoftwareVersion_FieldTerminalPathArrayItemValue struct {
	SoftwareVersion_FieldTerminalPath
	value interface{}
}

var _ SoftwareVersion_FieldPathArrayItemValue = (*SoftwareVersion_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SoftwareVersion as interface{}
func (fpaiv *SoftwareVersion_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *SoftwareVersion_FieldTerminalPathArrayItemValue) GetSingle(source *SoftwareVersion) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SoftwareVersion_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SoftwareVersion))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SoftwareVersion'
func (fpaiv *SoftwareVersion_FieldTerminalPathArrayItemValue) ContainsValue(source *SoftwareVersion) bool {
	slice := fpaiv.SoftwareVersion_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SoftwareVersion_FieldPathArrayOfValues allows storing slice of values for SoftwareVersion fields according to their type
type SoftwareVersion_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SoftwareVersion_FieldPath
}

func ParseSoftwareVersion_FieldPathArrayOfValues(pathStr, valuesStr string) (SoftwareVersion_FieldPathArrayOfValues, error) {
	fp, err := ParseSoftwareVersion_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SoftwareVersion field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SoftwareVersion_FieldPathArrayOfValues), nil
}

func MustParseSoftwareVersion_FieldPathArrayOfValues(pathStr, valuesStr string) SoftwareVersion_FieldPathArrayOfValues {
	fpaov, err := ParseSoftwareVersion_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SoftwareVersion_FieldTerminalPathArrayOfValues struct {
	SoftwareVersion_FieldTerminalPath
	values interface{}
}

var _ SoftwareVersion_FieldPathArrayOfValues = (*SoftwareVersion_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SoftwareVersion_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SoftwareVersion_FieldPathSelectorVersion:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SoftwareVersion_FieldPathSelectorCommitId:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SoftwareVersion_FieldPathSelectorBuildDate:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SoftwareVersion_FieldTerminalPathArrayOfValues) AsVersionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SoftwareVersion_FieldTerminalPathArrayOfValues) AsCommitIdArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SoftwareVersion_FieldTerminalPathArrayOfValues) AsBuildDateArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ContactInformation_FieldPath interface {
	gotenobject.FieldPath
	Selector() ContactInformation_FieldPathSelector
	Get(source *ContactInformation) []interface{}
	GetSingle(source *ContactInformation) (interface{}, bool)
	ClearValue(item *ContactInformation)

	// Those methods build corresponding ContactInformation_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ContactInformation_FieldPathValue
	WithIArrayOfValues(values interface{}) ContactInformation_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ContactInformation_FieldPathArrayItemValue
}

type ContactInformation_FieldPathSelector int32

const (
	ContactInformation_FieldPathSelectorFullName ContactInformation_FieldPathSelector = 0
	ContactInformation_FieldPathSelectorEmail    ContactInformation_FieldPathSelector = 1
	ContactInformation_FieldPathSelectorPhones   ContactInformation_FieldPathSelector = 2
)

func (s ContactInformation_FieldPathSelector) String() string {
	switch s {
	case ContactInformation_FieldPathSelectorFullName:
		return "full_name"
	case ContactInformation_FieldPathSelectorEmail:
		return "email"
	case ContactInformation_FieldPathSelectorPhones:
		return "phones"
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", s))
	}
}

func BuildContactInformation_FieldPath(fp gotenobject.RawFieldPath) (ContactInformation_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ContactInformation")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "full_name", "fullName", "full-name":
			return &ContactInformation_FieldTerminalPath{selector: ContactInformation_FieldPathSelectorFullName}, nil
		case "email":
			return &ContactInformation_FieldTerminalPath{selector: ContactInformation_FieldPathSelectorEmail}, nil
		case "phones":
			return &ContactInformation_FieldTerminalPath{selector: ContactInformation_FieldPathSelectorPhones}, nil
		}
	} else {
		switch fp[0] {
		case "phones":
			if subpath, err := BuildContactInformationPhoneNumber_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ContactInformation_FieldSubPath{selector: ContactInformation_FieldPathSelectorPhones, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ContactInformation", fp)
}

func ParseContactInformation_FieldPath(rawField string) (ContactInformation_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildContactInformation_FieldPath(fp)
}

func MustParseContactInformation_FieldPath(rawField string) ContactInformation_FieldPath {
	fp, err := ParseContactInformation_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ContactInformation_FieldTerminalPath struct {
	selector ContactInformation_FieldPathSelector
}

var _ ContactInformation_FieldPath = (*ContactInformation_FieldTerminalPath)(nil)

func (fp *ContactInformation_FieldTerminalPath) Selector() ContactInformation_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ContactInformation_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ContactInformation_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ContactInformation
func (fp *ContactInformation_FieldTerminalPath) Get(source *ContactInformation) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ContactInformation_FieldPathSelectorFullName:
			values = append(values, source.FullName)
		case ContactInformation_FieldPathSelectorEmail:
			values = append(values, source.Email)
		case ContactInformation_FieldPathSelectorPhones:
			for _, value := range source.GetPhones() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
		}
	}
	return
}

func (fp *ContactInformation_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ContactInformation))
}

// GetSingle returns value pointed by specific field of from source ContactInformation
func (fp *ContactInformation_FieldTerminalPath) GetSingle(source *ContactInformation) (interface{}, bool) {
	switch fp.selector {
	case ContactInformation_FieldPathSelectorFullName:
		return source.GetFullName(), source != nil
	case ContactInformation_FieldPathSelectorEmail:
		return source.GetEmail(), source != nil
	case ContactInformation_FieldPathSelectorPhones:
		res := source.GetPhones()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
	}
}

func (fp *ContactInformation_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ContactInformation))
}

// GetDefault returns a default value of the field type
func (fp *ContactInformation_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ContactInformation_FieldPathSelectorFullName:
		return ""
	case ContactInformation_FieldPathSelectorEmail:
		return ""
	case ContactInformation_FieldPathSelectorPhones:
		return ([]*ContactInformation_PhoneNumber)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
	}
}

func (fp *ContactInformation_FieldTerminalPath) ClearValue(item *ContactInformation) {
	if item != nil {
		switch fp.selector {
		case ContactInformation_FieldPathSelectorFullName:
			item.FullName = ""
		case ContactInformation_FieldPathSelectorEmail:
			item.Email = ""
		case ContactInformation_FieldPathSelectorPhones:
			item.Phones = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
		}
	}
}

func (fp *ContactInformation_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ContactInformation))
}

// IsLeaf - whether field path is holds simple value
func (fp *ContactInformation_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ContactInformation_FieldPathSelectorFullName ||
		fp.selector == ContactInformation_FieldPathSelectorEmail
}

func (fp *ContactInformation_FieldTerminalPath) WithIValue(value interface{}) ContactInformation_FieldPathValue {
	switch fp.selector {
	case ContactInformation_FieldPathSelectorFullName:
		return &ContactInformation_FieldTerminalPathValue{ContactInformation_FieldTerminalPath: *fp, value: value.(string)}
	case ContactInformation_FieldPathSelectorEmail:
		return &ContactInformation_FieldTerminalPathValue{ContactInformation_FieldTerminalPath: *fp, value: value.(string)}
	case ContactInformation_FieldPathSelectorPhones:
		return &ContactInformation_FieldTerminalPathValue{ContactInformation_FieldTerminalPath: *fp, value: value.([]*ContactInformation_PhoneNumber)}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
	}
}

func (fp *ContactInformation_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ContactInformation_FieldTerminalPath) WithIArrayOfValues(values interface{}) ContactInformation_FieldPathArrayOfValues {
	fpaov := &ContactInformation_FieldTerminalPathArrayOfValues{ContactInformation_FieldTerminalPath: *fp}
	switch fp.selector {
	case ContactInformation_FieldPathSelectorFullName:
		return &ContactInformation_FieldTerminalPathArrayOfValues{ContactInformation_FieldTerminalPath: *fp, values: values.([]string)}
	case ContactInformation_FieldPathSelectorEmail:
		return &ContactInformation_FieldTerminalPathArrayOfValues{ContactInformation_FieldTerminalPath: *fp, values: values.([]string)}
	case ContactInformation_FieldPathSelectorPhones:
		return &ContactInformation_FieldTerminalPathArrayOfValues{ContactInformation_FieldTerminalPath: *fp, values: values.([][]*ContactInformation_PhoneNumber)}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
	}
	return fpaov
}

func (fp *ContactInformation_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ContactInformation_FieldTerminalPath) WithIArrayItemValue(value interface{}) ContactInformation_FieldPathArrayItemValue {
	switch fp.selector {
	case ContactInformation_FieldPathSelectorPhones:
		return &ContactInformation_FieldTerminalPathArrayItemValue{ContactInformation_FieldTerminalPath: *fp, value: value.(*ContactInformation_PhoneNumber)}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fp.selector))
	}
}

func (fp *ContactInformation_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ContactInformation_FieldSubPath struct {
	selector ContactInformation_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ContactInformation_FieldPath = (*ContactInformation_FieldSubPath)(nil)

func (fps *ContactInformation_FieldSubPath) Selector() ContactInformation_FieldPathSelector {
	return fps.selector
}
func (fps *ContactInformation_FieldSubPath) AsPhonesSubPath() (ContactInformationPhoneNumber_FieldPath, bool) {
	res, ok := fps.subPath.(ContactInformationPhoneNumber_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ContactInformation_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ContactInformation_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ContactInformation
func (fps *ContactInformation_FieldSubPath) Get(source *ContactInformation) (values []interface{}) {
	if asPhoneNumberFieldPath, ok := fps.AsPhonesSubPath(); ok {
		for _, item := range source.GetPhones() {
			values = append(values, asPhoneNumberFieldPath.Get(item)...)
		}
	} else {
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fps.selector))
	}
	return
}

func (fps *ContactInformation_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ContactInformation))
}

// GetSingle returns value of selected field from source ContactInformation
func (fps *ContactInformation_FieldSubPath) GetSingle(source *ContactInformation) (interface{}, bool) {
	switch fps.selector {
	case ContactInformation_FieldPathSelectorPhones:
		if len(source.GetPhones()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPhones()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fps.selector))
	}
}

func (fps *ContactInformation_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ContactInformation))
}

// GetDefault returns a default value of the field type
func (fps *ContactInformation_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ContactInformation_FieldSubPath) ClearValue(item *ContactInformation) {
	if item != nil {
		switch fps.selector {
		case ContactInformation_FieldPathSelectorPhones:
			for _, subItem := range item.Phones {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fps.selector))
		}
	}
}

func (fps *ContactInformation_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ContactInformation))
}

// IsLeaf - whether field path is holds simple value
func (fps *ContactInformation_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ContactInformation_FieldSubPath) WithIValue(value interface{}) ContactInformation_FieldPathValue {
	return &ContactInformation_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ContactInformation_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ContactInformation_FieldSubPath) WithIArrayOfValues(values interface{}) ContactInformation_FieldPathArrayOfValues {
	return &ContactInformation_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ContactInformation_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ContactInformation_FieldSubPath) WithIArrayItemValue(value interface{}) ContactInformation_FieldPathArrayItemValue {
	return &ContactInformation_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ContactInformation_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ContactInformation_FieldPathValue allows storing values for ContactInformation fields according to their type
type ContactInformation_FieldPathValue interface {
	ContactInformation_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ContactInformation)
	CompareWith(*ContactInformation) (cmp int, comparable bool)
}

func ParseContactInformation_FieldPathValue(pathStr, valueStr string) (ContactInformation_FieldPathValue, error) {
	fp, err := ParseContactInformation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ContactInformation field path value from %s: %v", valueStr, err)
	}
	return fpv.(ContactInformation_FieldPathValue), nil
}

func MustParseContactInformation_FieldPathValue(pathStr, valueStr string) ContactInformation_FieldPathValue {
	fpv, err := ParseContactInformation_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ContactInformation_FieldTerminalPathValue struct {
	ContactInformation_FieldTerminalPath
	value interface{}
}

var _ ContactInformation_FieldPathValue = (*ContactInformation_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ContactInformation' as interface{}
func (fpv *ContactInformation_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ContactInformation_FieldTerminalPathValue) AsFullNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ContactInformation_FieldTerminalPathValue) AsEmailValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ContactInformation_FieldTerminalPathValue) AsPhonesValue() ([]*ContactInformation_PhoneNumber, bool) {
	res, ok := fpv.value.([]*ContactInformation_PhoneNumber)
	return res, ok
}

// SetTo stores value for selected field for object ContactInformation
func (fpv *ContactInformation_FieldTerminalPathValue) SetTo(target **ContactInformation) {
	if *target == nil {
		*target = new(ContactInformation)
	}
	switch fpv.selector {
	case ContactInformation_FieldPathSelectorFullName:
		(*target).FullName = fpv.value.(string)
	case ContactInformation_FieldPathSelectorEmail:
		(*target).Email = fpv.value.(string)
	case ContactInformation_FieldPathSelectorPhones:
		(*target).Phones = fpv.value.([]*ContactInformation_PhoneNumber)
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fpv.selector))
	}
}

func (fpv *ContactInformation_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ContactInformation)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ContactInformation_FieldTerminalPathValue' with the value under path in 'ContactInformation'.
func (fpv *ContactInformation_FieldTerminalPathValue) CompareWith(source *ContactInformation) (int, bool) {
	switch fpv.selector {
	case ContactInformation_FieldPathSelectorFullName:
		leftValue := fpv.value.(string)
		rightValue := source.GetFullName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ContactInformation_FieldPathSelectorEmail:
		leftValue := fpv.value.(string)
		rightValue := source.GetEmail()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ContactInformation_FieldPathSelectorPhones:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fpv.selector))
	}
}

func (fpv *ContactInformation_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ContactInformation))
}

type ContactInformation_FieldSubPathValue struct {
	ContactInformation_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ContactInformation_FieldPathValue = (*ContactInformation_FieldSubPathValue)(nil)

func (fpvs *ContactInformation_FieldSubPathValue) AsPhonesPathValue() (ContactInformationPhoneNumber_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ContactInformationPhoneNumber_FieldPathValue)
	return res, ok
}

func (fpvs *ContactInformation_FieldSubPathValue) SetTo(target **ContactInformation) {
	if *target == nil {
		*target = new(ContactInformation)
	}
	switch fpvs.Selector() {
	case ContactInformation_FieldPathSelectorPhones:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fpvs.Selector()))
	}
}

func (fpvs *ContactInformation_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ContactInformation)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ContactInformation_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ContactInformation_FieldSubPathValue) CompareWith(source *ContactInformation) (int, bool) {
	switch fpvs.Selector() {
	case ContactInformation_FieldPathSelectorPhones:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fpvs.Selector()))
	}
}

func (fpvs *ContactInformation_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ContactInformation))
}

// ContactInformation_FieldPathArrayItemValue allows storing single item in Path-specific values for ContactInformation according to their type
// Present only for array (repeated) types.
type ContactInformation_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ContactInformation_FieldPath
	ContainsValue(*ContactInformation) bool
}

// ParseContactInformation_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseContactInformation_FieldPathArrayItemValue(pathStr, valueStr string) (ContactInformation_FieldPathArrayItemValue, error) {
	fp, err := ParseContactInformation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ContactInformation field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ContactInformation_FieldPathArrayItemValue), nil
}

func MustParseContactInformation_FieldPathArrayItemValue(pathStr, valueStr string) ContactInformation_FieldPathArrayItemValue {
	fpaiv, err := ParseContactInformation_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ContactInformation_FieldTerminalPathArrayItemValue struct {
	ContactInformation_FieldTerminalPath
	value interface{}
}

var _ ContactInformation_FieldPathArrayItemValue = (*ContactInformation_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ContactInformation as interface{}
func (fpaiv *ContactInformation_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ContactInformation_FieldTerminalPathArrayItemValue) AsPhonesItemValue() (*ContactInformation_PhoneNumber, bool) {
	res, ok := fpaiv.value.(*ContactInformation_PhoneNumber)
	return res, ok
}

func (fpaiv *ContactInformation_FieldTerminalPathArrayItemValue) GetSingle(source *ContactInformation) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ContactInformation_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ContactInformation))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ContactInformation'
func (fpaiv *ContactInformation_FieldTerminalPathArrayItemValue) ContainsValue(source *ContactInformation) bool {
	slice := fpaiv.ContactInformation_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ContactInformation_FieldSubPathArrayItemValue struct {
	ContactInformation_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ContactInformation_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ContactInformation_FieldSubPathArrayItemValue) AsPhonesPathItemValue() (ContactInformationPhoneNumber_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ContactInformationPhoneNumber_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ContactInformation'
func (fpaivs *ContactInformation_FieldSubPathArrayItemValue) ContainsValue(source *ContactInformation) bool {
	switch fpaivs.Selector() {
	case ContactInformation_FieldPathSelectorPhones:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation: %d", fpaivs.Selector()))
	}
}

// ContactInformation_FieldPathArrayOfValues allows storing slice of values for ContactInformation fields according to their type
type ContactInformation_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ContactInformation_FieldPath
}

func ParseContactInformation_FieldPathArrayOfValues(pathStr, valuesStr string) (ContactInformation_FieldPathArrayOfValues, error) {
	fp, err := ParseContactInformation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ContactInformation field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ContactInformation_FieldPathArrayOfValues), nil
}

func MustParseContactInformation_FieldPathArrayOfValues(pathStr, valuesStr string) ContactInformation_FieldPathArrayOfValues {
	fpaov, err := ParseContactInformation_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ContactInformation_FieldTerminalPathArrayOfValues struct {
	ContactInformation_FieldTerminalPath
	values interface{}
}

var _ ContactInformation_FieldPathArrayOfValues = (*ContactInformation_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ContactInformation_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ContactInformation_FieldPathSelectorFullName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ContactInformation_FieldPathSelectorEmail:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ContactInformation_FieldPathSelectorPhones:
		for _, v := range fpaov.values.([][]*ContactInformation_PhoneNumber) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ContactInformation_FieldTerminalPathArrayOfValues) AsFullNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ContactInformation_FieldTerminalPathArrayOfValues) AsEmailArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ContactInformation_FieldTerminalPathArrayOfValues) AsPhonesArrayOfValues() ([][]*ContactInformation_PhoneNumber, bool) {
	res, ok := fpaov.values.([][]*ContactInformation_PhoneNumber)
	return res, ok
}

type ContactInformation_FieldSubPathArrayOfValues struct {
	ContactInformation_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ContactInformation_FieldPathArrayOfValues = (*ContactInformation_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ContactInformation_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ContactInformation_FieldSubPathArrayOfValues) AsPhonesPathArrayOfValues() (ContactInformationPhoneNumber_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ContactInformationPhoneNumber_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ContactInformationPhoneNumber_FieldPath interface {
	gotenobject.FieldPath
	Selector() ContactInformationPhoneNumber_FieldPathSelector
	Get(source *ContactInformation_PhoneNumber) []interface{}
	GetSingle(source *ContactInformation_PhoneNumber) (interface{}, bool)
	ClearValue(item *ContactInformation_PhoneNumber)

	// Those methods build corresponding ContactInformationPhoneNumber_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ContactInformationPhoneNumber_FieldPathValue
	WithIArrayOfValues(values interface{}) ContactInformationPhoneNumber_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ContactInformationPhoneNumber_FieldPathArrayItemValue
}

type ContactInformationPhoneNumber_FieldPathSelector int32

const (
	ContactInformationPhoneNumber_FieldPathSelectorNumber ContactInformationPhoneNumber_FieldPathSelector = 0
	ContactInformationPhoneNumber_FieldPathSelectorType   ContactInformationPhoneNumber_FieldPathSelector = 1
)

func (s ContactInformationPhoneNumber_FieldPathSelector) String() string {
	switch s {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		return "number"
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		return "type"
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", s))
	}
}

func BuildContactInformationPhoneNumber_FieldPath(fp gotenobject.RawFieldPath) (ContactInformationPhoneNumber_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ContactInformation_PhoneNumber")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "number":
			return &ContactInformationPhoneNumber_FieldTerminalPath{selector: ContactInformationPhoneNumber_FieldPathSelectorNumber}, nil
		case "type":
			return &ContactInformationPhoneNumber_FieldTerminalPath{selector: ContactInformationPhoneNumber_FieldPathSelectorType}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ContactInformation_PhoneNumber", fp)
}

func ParseContactInformationPhoneNumber_FieldPath(rawField string) (ContactInformationPhoneNumber_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildContactInformationPhoneNumber_FieldPath(fp)
}

func MustParseContactInformationPhoneNumber_FieldPath(rawField string) ContactInformationPhoneNumber_FieldPath {
	fp, err := ParseContactInformationPhoneNumber_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ContactInformationPhoneNumber_FieldTerminalPath struct {
	selector ContactInformationPhoneNumber_FieldPathSelector
}

var _ ContactInformationPhoneNumber_FieldPath = (*ContactInformationPhoneNumber_FieldTerminalPath)(nil)

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) Selector() ContactInformationPhoneNumber_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ContactInformation_PhoneNumber
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) Get(source *ContactInformation_PhoneNumber) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ContactInformationPhoneNumber_FieldPathSelectorNumber:
			values = append(values, source.Number)
		case ContactInformationPhoneNumber_FieldPathSelectorType:
			values = append(values, source.Type)
		default:
			panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
		}
	}
	return
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ContactInformation_PhoneNumber))
}

// GetSingle returns value pointed by specific field of from source ContactInformation_PhoneNumber
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) GetSingle(source *ContactInformation_PhoneNumber) (interface{}, bool) {
	switch fp.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		return source.GetNumber(), source != nil
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		return source.GetType(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
	}
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ContactInformation_PhoneNumber))
}

// GetDefault returns a default value of the field type
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		return ""
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		return ContactInformation_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
	}
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) ClearValue(item *ContactInformation_PhoneNumber) {
	if item != nil {
		switch fp.selector {
		case ContactInformationPhoneNumber_FieldPathSelectorNumber:
			item.Number = ""
		case ContactInformationPhoneNumber_FieldPathSelectorType:
			item.Type = ContactInformation_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
		}
	}
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ContactInformation_PhoneNumber))
}

// IsLeaf - whether field path is holds simple value
func (fp *ContactInformationPhoneNumber_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ContactInformationPhoneNumber_FieldPathSelectorNumber ||
		fp.selector == ContactInformationPhoneNumber_FieldPathSelectorType
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithIValue(value interface{}) ContactInformationPhoneNumber_FieldPathValue {
	switch fp.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		return &ContactInformationPhoneNumber_FieldTerminalPathValue{ContactInformationPhoneNumber_FieldTerminalPath: *fp, value: value.(string)}
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		return &ContactInformationPhoneNumber_FieldTerminalPathValue{ContactInformationPhoneNumber_FieldTerminalPath: *fp, value: value.(ContactInformation_PhoneType)}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
	}
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithIArrayOfValues(values interface{}) ContactInformationPhoneNumber_FieldPathArrayOfValues {
	fpaov := &ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues{ContactInformationPhoneNumber_FieldTerminalPath: *fp}
	switch fp.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		return &ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues{ContactInformationPhoneNumber_FieldTerminalPath: *fp, values: values.([]string)}
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		return &ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues{ContactInformationPhoneNumber_FieldTerminalPath: *fp, values: values.([]ContactInformation_PhoneType)}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
	}
	return fpaov
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithIArrayItemValue(value interface{}) ContactInformationPhoneNumber_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fp.selector))
	}
}

func (fp *ContactInformationPhoneNumber_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ContactInformationPhoneNumber_FieldPathValue allows storing values for PhoneNumber fields according to their type
type ContactInformationPhoneNumber_FieldPathValue interface {
	ContactInformationPhoneNumber_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ContactInformation_PhoneNumber)
	CompareWith(*ContactInformation_PhoneNumber) (cmp int, comparable bool)
}

func ParseContactInformationPhoneNumber_FieldPathValue(pathStr, valueStr string) (ContactInformationPhoneNumber_FieldPathValue, error) {
	fp, err := ParseContactInformationPhoneNumber_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PhoneNumber field path value from %s: %v", valueStr, err)
	}
	return fpv.(ContactInformationPhoneNumber_FieldPathValue), nil
}

func MustParseContactInformationPhoneNumber_FieldPathValue(pathStr, valueStr string) ContactInformationPhoneNumber_FieldPathValue {
	fpv, err := ParseContactInformationPhoneNumber_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ContactInformationPhoneNumber_FieldTerminalPathValue struct {
	ContactInformationPhoneNumber_FieldTerminalPath
	value interface{}
}

var _ ContactInformationPhoneNumber_FieldPathValue = (*ContactInformationPhoneNumber_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PhoneNumber' as interface{}
func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) AsNumberValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) AsTypeValue() (ContactInformation_PhoneType, bool) {
	res, ok := fpv.value.(ContactInformation_PhoneType)
	return res, ok
}

// SetTo stores value for selected field for object PhoneNumber
func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) SetTo(target **ContactInformation_PhoneNumber) {
	if *target == nil {
		*target = new(ContactInformation_PhoneNumber)
	}
	switch fpv.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		(*target).Number = fpv.value.(string)
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		(*target).Type = fpv.value.(ContactInformation_PhoneType)
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fpv.selector))
	}
}

func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ContactInformation_PhoneNumber)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ContactInformationPhoneNumber_FieldTerminalPathValue' with the value under path in 'ContactInformation_PhoneNumber'.
func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) CompareWith(source *ContactInformation_PhoneNumber) (int, bool) {
	switch fpv.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		leftValue := fpv.value.(string)
		rightValue := source.GetNumber()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		leftValue := fpv.value.(ContactInformation_PhoneType)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ContactInformation_PhoneNumber: %d", fpv.selector))
	}
}

func (fpv *ContactInformationPhoneNumber_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ContactInformation_PhoneNumber))
}

// ContactInformationPhoneNumber_FieldPathArrayItemValue allows storing single item in Path-specific values for PhoneNumber according to their type
// Present only for array (repeated) types.
type ContactInformationPhoneNumber_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ContactInformationPhoneNumber_FieldPath
	ContainsValue(*ContactInformation_PhoneNumber) bool
}

// ParseContactInformationPhoneNumber_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseContactInformationPhoneNumber_FieldPathArrayItemValue(pathStr, valueStr string) (ContactInformationPhoneNumber_FieldPathArrayItemValue, error) {
	fp, err := ParseContactInformationPhoneNumber_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PhoneNumber field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ContactInformationPhoneNumber_FieldPathArrayItemValue), nil
}

func MustParseContactInformationPhoneNumber_FieldPathArrayItemValue(pathStr, valueStr string) ContactInformationPhoneNumber_FieldPathArrayItemValue {
	fpaiv, err := ParseContactInformationPhoneNumber_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue struct {
	ContactInformationPhoneNumber_FieldTerminalPath
	value interface{}
}

var _ ContactInformationPhoneNumber_FieldPathArrayItemValue = (*ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ContactInformation_PhoneNumber as interface{}
func (fpaiv *ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue) GetSingle(source *ContactInformation_PhoneNumber) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ContactInformation_PhoneNumber))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PhoneNumber'
func (fpaiv *ContactInformationPhoneNumber_FieldTerminalPathArrayItemValue) ContainsValue(source *ContactInformation_PhoneNumber) bool {
	slice := fpaiv.ContactInformationPhoneNumber_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ContactInformationPhoneNumber_FieldPathArrayOfValues allows storing slice of values for PhoneNumber fields according to their type
type ContactInformationPhoneNumber_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ContactInformationPhoneNumber_FieldPath
}

func ParseContactInformationPhoneNumber_FieldPathArrayOfValues(pathStr, valuesStr string) (ContactInformationPhoneNumber_FieldPathArrayOfValues, error) {
	fp, err := ParseContactInformationPhoneNumber_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PhoneNumber field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ContactInformationPhoneNumber_FieldPathArrayOfValues), nil
}

func MustParseContactInformationPhoneNumber_FieldPathArrayOfValues(pathStr, valuesStr string) ContactInformationPhoneNumber_FieldPathArrayOfValues {
	fpaov, err := ParseContactInformationPhoneNumber_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues struct {
	ContactInformationPhoneNumber_FieldTerminalPath
	values interface{}
}

var _ ContactInformationPhoneNumber_FieldPathArrayOfValues = (*ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ContactInformationPhoneNumber_FieldPathSelectorNumber:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ContactInformationPhoneNumber_FieldPathSelectorType:
		for _, v := range fpaov.values.([]ContactInformation_PhoneType) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues) AsNumberArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ContactInformationPhoneNumber_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]ContactInformation_PhoneType, bool) {
	res, ok := fpaov.values.([]ContactInformation_PhoneType)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Address_FieldPath interface {
	gotenobject.FieldPath
	Selector() Address_FieldPathSelector
	Get(source *Address) []interface{}
	GetSingle(source *Address) (interface{}, bool)
	ClearValue(item *Address)

	// Those methods build corresponding Address_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Address_FieldPathValue
	WithIArrayOfValues(values interface{}) Address_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Address_FieldPathArrayItemValue
}

type Address_FieldPathSelector int32

const (
	Address_FieldPathSelectorPostalCode    Address_FieldPathSelector = 0
	Address_FieldPathSelectorCountryCode   Address_FieldPathSelector = 1
	Address_FieldPathSelectorContinent     Address_FieldPathSelector = 2
	Address_FieldPathSelectorCountry       Address_FieldPathSelector = 3
	Address_FieldPathSelectorAdminArea1    Address_FieldPathSelector = 4
	Address_FieldPathSelectorAdminArea2    Address_FieldPathSelector = 5
	Address_FieldPathSelectorAdminArea3    Address_FieldPathSelector = 6
	Address_FieldPathSelectorAdminArea4    Address_FieldPathSelector = 7
	Address_FieldPathSelectorStreetAddress Address_FieldPathSelector = 8
)

func (s Address_FieldPathSelector) String() string {
	switch s {
	case Address_FieldPathSelectorPostalCode:
		return "postal_code"
	case Address_FieldPathSelectorCountryCode:
		return "country_code"
	case Address_FieldPathSelectorContinent:
		return "continent"
	case Address_FieldPathSelectorCountry:
		return "country"
	case Address_FieldPathSelectorAdminArea1:
		return "admin_area1"
	case Address_FieldPathSelectorAdminArea2:
		return "admin_area2"
	case Address_FieldPathSelectorAdminArea3:
		return "admin_area3"
	case Address_FieldPathSelectorAdminArea4:
		return "admin_area4"
	case Address_FieldPathSelectorStreetAddress:
		return "street_address"
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", s))
	}
}

func BuildAddress_FieldPath(fp gotenobject.RawFieldPath) (Address_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Address")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "postal_code", "postalCode", "postal-code":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorPostalCode}, nil
		case "country_code", "countryCode", "country-code":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorCountryCode}, nil
		case "continent":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorContinent}, nil
		case "country":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorCountry}, nil
		case "admin_area1", "adminArea1", "admin-area1":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorAdminArea1}, nil
		case "admin_area2", "adminArea2", "admin-area2":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorAdminArea2}, nil
		case "admin_area3", "adminArea3", "admin-area3":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorAdminArea3}, nil
		case "admin_area4", "adminArea4", "admin-area4":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorAdminArea4}, nil
		case "street_address", "streetAddress", "street-address":
			return &Address_FieldTerminalPath{selector: Address_FieldPathSelectorStreetAddress}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Address", fp)
}

func ParseAddress_FieldPath(rawField string) (Address_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildAddress_FieldPath(fp)
}

func MustParseAddress_FieldPath(rawField string) Address_FieldPath {
	fp, err := ParseAddress_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Address_FieldTerminalPath struct {
	selector Address_FieldPathSelector
}

var _ Address_FieldPath = (*Address_FieldTerminalPath)(nil)

func (fp *Address_FieldTerminalPath) Selector() Address_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Address_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Address_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Address
func (fp *Address_FieldTerminalPath) Get(source *Address) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Address_FieldPathSelectorPostalCode:
			values = append(values, source.PostalCode)
		case Address_FieldPathSelectorCountryCode:
			values = append(values, source.CountryCode)
		case Address_FieldPathSelectorContinent:
			values = append(values, source.Continent)
		case Address_FieldPathSelectorCountry:
			values = append(values, source.Country)
		case Address_FieldPathSelectorAdminArea1:
			values = append(values, source.AdminArea1)
		case Address_FieldPathSelectorAdminArea2:
			values = append(values, source.AdminArea2)
		case Address_FieldPathSelectorAdminArea3:
			values = append(values, source.AdminArea3)
		case Address_FieldPathSelectorAdminArea4:
			values = append(values, source.AdminArea4)
		case Address_FieldPathSelectorStreetAddress:
			values = append(values, source.StreetAddress)
		default:
			panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
		}
	}
	return
}

func (fp *Address_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Address))
}

// GetSingle returns value pointed by specific field of from source Address
func (fp *Address_FieldTerminalPath) GetSingle(source *Address) (interface{}, bool) {
	switch fp.selector {
	case Address_FieldPathSelectorPostalCode:
		return source.GetPostalCode(), source != nil
	case Address_FieldPathSelectorCountryCode:
		return source.GetCountryCode(), source != nil
	case Address_FieldPathSelectorContinent:
		return source.GetContinent(), source != nil
	case Address_FieldPathSelectorCountry:
		return source.GetCountry(), source != nil
	case Address_FieldPathSelectorAdminArea1:
		return source.GetAdminArea1(), source != nil
	case Address_FieldPathSelectorAdminArea2:
		return source.GetAdminArea2(), source != nil
	case Address_FieldPathSelectorAdminArea3:
		return source.GetAdminArea3(), source != nil
	case Address_FieldPathSelectorAdminArea4:
		return source.GetAdminArea4(), source != nil
	case Address_FieldPathSelectorStreetAddress:
		return source.GetStreetAddress(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
	}
}

func (fp *Address_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Address))
}

// GetDefault returns a default value of the field type
func (fp *Address_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Address_FieldPathSelectorPostalCode:
		return ""
	case Address_FieldPathSelectorCountryCode:
		return ""
	case Address_FieldPathSelectorContinent:
		return ""
	case Address_FieldPathSelectorCountry:
		return ""
	case Address_FieldPathSelectorAdminArea1:
		return ""
	case Address_FieldPathSelectorAdminArea2:
		return ""
	case Address_FieldPathSelectorAdminArea3:
		return ""
	case Address_FieldPathSelectorAdminArea4:
		return ""
	case Address_FieldPathSelectorStreetAddress:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
	}
}

func (fp *Address_FieldTerminalPath) ClearValue(item *Address) {
	if item != nil {
		switch fp.selector {
		case Address_FieldPathSelectorPostalCode:
			item.PostalCode = ""
		case Address_FieldPathSelectorCountryCode:
			item.CountryCode = ""
		case Address_FieldPathSelectorContinent:
			item.Continent = ""
		case Address_FieldPathSelectorCountry:
			item.Country = ""
		case Address_FieldPathSelectorAdminArea1:
			item.AdminArea1 = ""
		case Address_FieldPathSelectorAdminArea2:
			item.AdminArea2 = ""
		case Address_FieldPathSelectorAdminArea3:
			item.AdminArea3 = ""
		case Address_FieldPathSelectorAdminArea4:
			item.AdminArea4 = ""
		case Address_FieldPathSelectorStreetAddress:
			item.StreetAddress = ""
		default:
			panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
		}
	}
}

func (fp *Address_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Address))
}

// IsLeaf - whether field path is holds simple value
func (fp *Address_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Address_FieldPathSelectorPostalCode ||
		fp.selector == Address_FieldPathSelectorCountryCode ||
		fp.selector == Address_FieldPathSelectorContinent ||
		fp.selector == Address_FieldPathSelectorCountry ||
		fp.selector == Address_FieldPathSelectorAdminArea1 ||
		fp.selector == Address_FieldPathSelectorAdminArea2 ||
		fp.selector == Address_FieldPathSelectorAdminArea3 ||
		fp.selector == Address_FieldPathSelectorAdminArea4 ||
		fp.selector == Address_FieldPathSelectorStreetAddress
}

func (fp *Address_FieldTerminalPath) WithIValue(value interface{}) Address_FieldPathValue {
	switch fp.selector {
	case Address_FieldPathSelectorPostalCode:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorCountryCode:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorContinent:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorCountry:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorAdminArea1:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorAdminArea2:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorAdminArea3:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorAdminArea4:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	case Address_FieldPathSelectorStreetAddress:
		return &Address_FieldTerminalPathValue{Address_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
	}
}

func (fp *Address_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Address_FieldTerminalPath) WithIArrayOfValues(values interface{}) Address_FieldPathArrayOfValues {
	fpaov := &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp}
	switch fp.selector {
	case Address_FieldPathSelectorPostalCode:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorCountryCode:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorContinent:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorCountry:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorAdminArea1:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorAdminArea2:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorAdminArea3:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorAdminArea4:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	case Address_FieldPathSelectorStreetAddress:
		return &Address_FieldTerminalPathArrayOfValues{Address_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
	}
	return fpaov
}

func (fp *Address_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Address_FieldTerminalPath) WithIArrayItemValue(value interface{}) Address_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fp.selector))
	}
}

func (fp *Address_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Address_FieldPathValue allows storing values for Address fields according to their type
type Address_FieldPathValue interface {
	Address_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Address)
	CompareWith(*Address) (cmp int, comparable bool)
}

func ParseAddress_FieldPathValue(pathStr, valueStr string) (Address_FieldPathValue, error) {
	fp, err := ParseAddress_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Address field path value from %s: %v", valueStr, err)
	}
	return fpv.(Address_FieldPathValue), nil
}

func MustParseAddress_FieldPathValue(pathStr, valueStr string) Address_FieldPathValue {
	fpv, err := ParseAddress_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Address_FieldTerminalPathValue struct {
	Address_FieldTerminalPath
	value interface{}
}

var _ Address_FieldPathValue = (*Address_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Address' as interface{}
func (fpv *Address_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Address_FieldTerminalPathValue) AsPostalCodeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsCountryCodeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsContinentValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsCountryValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsAdminArea1Value() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsAdminArea2Value() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsAdminArea3Value() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsAdminArea4Value() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Address_FieldTerminalPathValue) AsStreetAddressValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object Address
func (fpv *Address_FieldTerminalPathValue) SetTo(target **Address) {
	if *target == nil {
		*target = new(Address)
	}
	switch fpv.selector {
	case Address_FieldPathSelectorPostalCode:
		(*target).PostalCode = fpv.value.(string)
	case Address_FieldPathSelectorCountryCode:
		(*target).CountryCode = fpv.value.(string)
	case Address_FieldPathSelectorContinent:
		(*target).Continent = fpv.value.(string)
	case Address_FieldPathSelectorCountry:
		(*target).Country = fpv.value.(string)
	case Address_FieldPathSelectorAdminArea1:
		(*target).AdminArea1 = fpv.value.(string)
	case Address_FieldPathSelectorAdminArea2:
		(*target).AdminArea2 = fpv.value.(string)
	case Address_FieldPathSelectorAdminArea3:
		(*target).AdminArea3 = fpv.value.(string)
	case Address_FieldPathSelectorAdminArea4:
		(*target).AdminArea4 = fpv.value.(string)
	case Address_FieldPathSelectorStreetAddress:
		(*target).StreetAddress = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fpv.selector))
	}
}

func (fpv *Address_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Address)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Address_FieldTerminalPathValue' with the value under path in 'Address'.
func (fpv *Address_FieldTerminalPathValue) CompareWith(source *Address) (int, bool) {
	switch fpv.selector {
	case Address_FieldPathSelectorPostalCode:
		leftValue := fpv.value.(string)
		rightValue := source.GetPostalCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorCountryCode:
		leftValue := fpv.value.(string)
		rightValue := source.GetCountryCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorContinent:
		leftValue := fpv.value.(string)
		rightValue := source.GetContinent()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorCountry:
		leftValue := fpv.value.(string)
		rightValue := source.GetCountry()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorAdminArea1:
		leftValue := fpv.value.(string)
		rightValue := source.GetAdminArea1()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorAdminArea2:
		leftValue := fpv.value.(string)
		rightValue := source.GetAdminArea2()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorAdminArea3:
		leftValue := fpv.value.(string)
		rightValue := source.GetAdminArea3()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorAdminArea4:
		leftValue := fpv.value.(string)
		rightValue := source.GetAdminArea4()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Address_FieldPathSelectorStreetAddress:
		leftValue := fpv.value.(string)
		rightValue := source.GetStreetAddress()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Address: %d", fpv.selector))
	}
}

func (fpv *Address_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Address))
}

// Address_FieldPathArrayItemValue allows storing single item in Path-specific values for Address according to their type
// Present only for array (repeated) types.
type Address_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Address_FieldPath
	ContainsValue(*Address) bool
}

// ParseAddress_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseAddress_FieldPathArrayItemValue(pathStr, valueStr string) (Address_FieldPathArrayItemValue, error) {
	fp, err := ParseAddress_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Address field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Address_FieldPathArrayItemValue), nil
}

func MustParseAddress_FieldPathArrayItemValue(pathStr, valueStr string) Address_FieldPathArrayItemValue {
	fpaiv, err := ParseAddress_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Address_FieldTerminalPathArrayItemValue struct {
	Address_FieldTerminalPath
	value interface{}
}

var _ Address_FieldPathArrayItemValue = (*Address_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Address as interface{}
func (fpaiv *Address_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Address_FieldTerminalPathArrayItemValue) GetSingle(source *Address) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Address_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Address))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Address'
func (fpaiv *Address_FieldTerminalPathArrayItemValue) ContainsValue(source *Address) bool {
	slice := fpaiv.Address_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Address_FieldPathArrayOfValues allows storing slice of values for Address fields according to their type
type Address_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Address_FieldPath
}

func ParseAddress_FieldPathArrayOfValues(pathStr, valuesStr string) (Address_FieldPathArrayOfValues, error) {
	fp, err := ParseAddress_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Address field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Address_FieldPathArrayOfValues), nil
}

func MustParseAddress_FieldPathArrayOfValues(pathStr, valuesStr string) Address_FieldPathArrayOfValues {
	fpaov, err := ParseAddress_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Address_FieldTerminalPathArrayOfValues struct {
	Address_FieldTerminalPath
	values interface{}
}

var _ Address_FieldPathArrayOfValues = (*Address_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Address_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Address_FieldPathSelectorPostalCode:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorCountryCode:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorContinent:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorCountry:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorAdminArea1:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorAdminArea2:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorAdminArea3:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorAdminArea4:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Address_FieldPathSelectorStreetAddress:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsPostalCodeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsCountryCodeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsContinentArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsCountryArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsAdminArea1ArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsAdminArea2ArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsAdminArea3ArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsAdminArea4ArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Address_FieldTerminalPathArrayOfValues) AsStreetAddressArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Location_FieldPath interface {
	gotenobject.FieldPath
	Selector() Location_FieldPathSelector
	Get(source *Location) []interface{}
	GetSingle(source *Location) (interface{}, bool)
	ClearValue(item *Location)

	// Those methods build corresponding Location_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Location_FieldPathValue
	WithIArrayOfValues(values interface{}) Location_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Location_FieldPathArrayItemValue
}

type Location_FieldPathSelector int32

const (
	Location_FieldPathSelectorAddress        Location_FieldPathSelector = 0
	Location_FieldPathSelectorAdminHierarchy Location_FieldPathSelector = 1
	Location_FieldPathSelectorCoordinates    Location_FieldPathSelector = 2
	Location_FieldPathSelectorAccuracy       Location_FieldPathSelector = 3
)

func (s Location_FieldPathSelector) String() string {
	switch s {
	case Location_FieldPathSelectorAddress:
		return "address"
	case Location_FieldPathSelectorAdminHierarchy:
		return "admin_hierarchy"
	case Location_FieldPathSelectorCoordinates:
		return "coordinates"
	case Location_FieldPathSelectorAccuracy:
		return "accuracy"
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", s))
	}
}

func BuildLocation_FieldPath(fp gotenobject.RawFieldPath) (Location_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Location")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "address":
			return &Location_FieldTerminalPath{selector: Location_FieldPathSelectorAddress}, nil
		case "admin_hierarchy", "adminHierarchy", "admin-hierarchy":
			return &Location_FieldTerminalPath{selector: Location_FieldPathSelectorAdminHierarchy}, nil
		case "coordinates":
			return &Location_FieldTerminalPath{selector: Location_FieldPathSelectorCoordinates}, nil
		case "accuracy":
			return &Location_FieldTerminalPath{selector: Location_FieldPathSelectorAccuracy}, nil
		}
	} else {
		switch fp[0] {
		case "address":
			if subpath, err := BuildAddress_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Location_FieldSubPath{selector: Location_FieldPathSelectorAddress, subPath: subpath}, nil
			}
		case "admin_hierarchy", "adminHierarchy", "admin-hierarchy":
			if subpath, err := admin_area.BuildAdminHierarchy_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Location_FieldSubPath{selector: Location_FieldPathSelectorAdminHierarchy, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Location", fp)
}

func ParseLocation_FieldPath(rawField string) (Location_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLocation_FieldPath(fp)
}

func MustParseLocation_FieldPath(rawField string) Location_FieldPath {
	fp, err := ParseLocation_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Location_FieldTerminalPath struct {
	selector Location_FieldPathSelector
}

var _ Location_FieldPath = (*Location_FieldTerminalPath)(nil)

func (fp *Location_FieldTerminalPath) Selector() Location_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Location_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Location_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Location
func (fp *Location_FieldTerminalPath) Get(source *Location) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Location_FieldPathSelectorAddress:
			if source.Address != nil {
				values = append(values, source.Address)
			}
		case Location_FieldPathSelectorAdminHierarchy:
			if source.AdminHierarchy != nil {
				values = append(values, source.AdminHierarchy)
			}
		case Location_FieldPathSelectorCoordinates:
			if source.Coordinates != nil {
				values = append(values, source.Coordinates)
			}
		case Location_FieldPathSelectorAccuracy:
			values = append(values, source.Accuracy)
		default:
			panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
		}
	}
	return
}

func (fp *Location_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Location))
}

// GetSingle returns value pointed by specific field of from source Location
func (fp *Location_FieldTerminalPath) GetSingle(source *Location) (interface{}, bool) {
	switch fp.selector {
	case Location_FieldPathSelectorAddress:
		res := source.GetAddress()
		return res, res != nil
	case Location_FieldPathSelectorAdminHierarchy:
		res := source.GetAdminHierarchy()
		return res, res != nil
	case Location_FieldPathSelectorCoordinates:
		res := source.GetCoordinates()
		return res, res != nil
	case Location_FieldPathSelectorAccuracy:
		return source.GetAccuracy(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
	}
}

func (fp *Location_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Location))
}

// GetDefault returns a default value of the field type
func (fp *Location_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Location_FieldPathSelectorAddress:
		return (*Address)(nil)
	case Location_FieldPathSelectorAdminHierarchy:
		return (*admin_area.AdminHierarchy)(nil)
	case Location_FieldPathSelectorCoordinates:
		return (*latlng.LatLng)(nil)
	case Location_FieldPathSelectorAccuracy:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
	}
}

func (fp *Location_FieldTerminalPath) ClearValue(item *Location) {
	if item != nil {
		switch fp.selector {
		case Location_FieldPathSelectorAddress:
			item.Address = nil
		case Location_FieldPathSelectorAdminHierarchy:
			item.AdminHierarchy = nil
		case Location_FieldPathSelectorCoordinates:
			item.Coordinates = nil
		case Location_FieldPathSelectorAccuracy:
			item.Accuracy = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
		}
	}
}

func (fp *Location_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Location))
}

// IsLeaf - whether field path is holds simple value
func (fp *Location_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Location_FieldPathSelectorCoordinates ||
		fp.selector == Location_FieldPathSelectorAccuracy
}

func (fp *Location_FieldTerminalPath) WithIValue(value interface{}) Location_FieldPathValue {
	switch fp.selector {
	case Location_FieldPathSelectorAddress:
		return &Location_FieldTerminalPathValue{Location_FieldTerminalPath: *fp, value: value.(*Address)}
	case Location_FieldPathSelectorAdminHierarchy:
		return &Location_FieldTerminalPathValue{Location_FieldTerminalPath: *fp, value: value.(*admin_area.AdminHierarchy)}
	case Location_FieldPathSelectorCoordinates:
		return &Location_FieldTerminalPathValue{Location_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	case Location_FieldPathSelectorAccuracy:
		return &Location_FieldTerminalPathValue{Location_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
	}
}

func (fp *Location_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Location_FieldTerminalPath) WithIArrayOfValues(values interface{}) Location_FieldPathArrayOfValues {
	fpaov := &Location_FieldTerminalPathArrayOfValues{Location_FieldTerminalPath: *fp}
	switch fp.selector {
	case Location_FieldPathSelectorAddress:
		return &Location_FieldTerminalPathArrayOfValues{Location_FieldTerminalPath: *fp, values: values.([]*Address)}
	case Location_FieldPathSelectorAdminHierarchy:
		return &Location_FieldTerminalPathArrayOfValues{Location_FieldTerminalPath: *fp, values: values.([]*admin_area.AdminHierarchy)}
	case Location_FieldPathSelectorCoordinates:
		return &Location_FieldTerminalPathArrayOfValues{Location_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	case Location_FieldPathSelectorAccuracy:
		return &Location_FieldTerminalPathArrayOfValues{Location_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
	}
	return fpaov
}

func (fp *Location_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Location_FieldTerminalPath) WithIArrayItemValue(value interface{}) Location_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fp.selector))
	}
}

func (fp *Location_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type Location_FieldSubPath struct {
	selector Location_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Location_FieldPath = (*Location_FieldSubPath)(nil)

func (fps *Location_FieldSubPath) Selector() Location_FieldPathSelector {
	return fps.selector
}
func (fps *Location_FieldSubPath) AsAddressSubPath() (Address_FieldPath, bool) {
	res, ok := fps.subPath.(Address_FieldPath)
	return res, ok
}
func (fps *Location_FieldSubPath) AsAdminHierarchySubPath() (admin_area.AdminHierarchy_FieldPath, bool) {
	res, ok := fps.subPath.(admin_area.AdminHierarchy_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Location_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Location_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Location
func (fps *Location_FieldSubPath) Get(source *Location) (values []interface{}) {
	if asAddressFieldPath, ok := fps.AsAddressSubPath(); ok {
		values = append(values, asAddressFieldPath.Get(source.GetAddress())...)
	} else if asAdminHierarchyFieldPath, ok := fps.AsAdminHierarchySubPath(); ok {
		values = append(values, asAdminHierarchyFieldPath.Get(source.GetAdminHierarchy())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for Location: %d", fps.selector))
	}
	return
}

func (fps *Location_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Location))
}

// GetSingle returns value of selected field from source Location
func (fps *Location_FieldSubPath) GetSingle(source *Location) (interface{}, bool) {
	switch fps.selector {
	case Location_FieldPathSelectorAddress:
		if source.GetAddress() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetAddress())
	case Location_FieldPathSelectorAdminHierarchy:
		if source.GetAdminHierarchy() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetAdminHierarchy())
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fps.selector))
	}
}

func (fps *Location_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Location))
}

// GetDefault returns a default value of the field type
func (fps *Location_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Location_FieldSubPath) ClearValue(item *Location) {
	if item != nil {
		switch fps.selector {
		case Location_FieldPathSelectorAddress:
			fps.subPath.ClearValueRaw(item.Address)
		case Location_FieldPathSelectorAdminHierarchy:
			fps.subPath.ClearValueRaw(item.AdminHierarchy)
		default:
			panic(fmt.Sprintf("Invalid selector for Location: %d", fps.selector))
		}
	}
}

func (fps *Location_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Location))
}

// IsLeaf - whether field path is holds simple value
func (fps *Location_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Location_FieldSubPath) WithIValue(value interface{}) Location_FieldPathValue {
	return &Location_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Location_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Location_FieldSubPath) WithIArrayOfValues(values interface{}) Location_FieldPathArrayOfValues {
	return &Location_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Location_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Location_FieldSubPath) WithIArrayItemValue(value interface{}) Location_FieldPathArrayItemValue {
	return &Location_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Location_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Location_FieldPathValue allows storing values for Location fields according to their type
type Location_FieldPathValue interface {
	Location_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Location)
	CompareWith(*Location) (cmp int, comparable bool)
}

func ParseLocation_FieldPathValue(pathStr, valueStr string) (Location_FieldPathValue, error) {
	fp, err := ParseLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Location field path value from %s: %v", valueStr, err)
	}
	return fpv.(Location_FieldPathValue), nil
}

func MustParseLocation_FieldPathValue(pathStr, valueStr string) Location_FieldPathValue {
	fpv, err := ParseLocation_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Location_FieldTerminalPathValue struct {
	Location_FieldTerminalPath
	value interface{}
}

var _ Location_FieldPathValue = (*Location_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Location' as interface{}
func (fpv *Location_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Location_FieldTerminalPathValue) AsAddressValue() (*Address, bool) {
	res, ok := fpv.value.(*Address)
	return res, ok
}
func (fpv *Location_FieldTerminalPathValue) AsAdminHierarchyValue() (*admin_area.AdminHierarchy, bool) {
	res, ok := fpv.value.(*admin_area.AdminHierarchy)
	return res, ok
}
func (fpv *Location_FieldTerminalPathValue) AsCoordinatesValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}
func (fpv *Location_FieldTerminalPathValue) AsAccuracyValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Location
func (fpv *Location_FieldTerminalPathValue) SetTo(target **Location) {
	if *target == nil {
		*target = new(Location)
	}
	switch fpv.selector {
	case Location_FieldPathSelectorAddress:
		(*target).Address = fpv.value.(*Address)
	case Location_FieldPathSelectorAdminHierarchy:
		(*target).AdminHierarchy = fpv.value.(*admin_area.AdminHierarchy)
	case Location_FieldPathSelectorCoordinates:
		(*target).Coordinates = fpv.value.(*latlng.LatLng)
	case Location_FieldPathSelectorAccuracy:
		(*target).Accuracy = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fpv.selector))
	}
}

func (fpv *Location_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Location)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Location_FieldTerminalPathValue' with the value under path in 'Location'.
func (fpv *Location_FieldTerminalPathValue) CompareWith(source *Location) (int, bool) {
	switch fpv.selector {
	case Location_FieldPathSelectorAddress:
		return 0, false
	case Location_FieldPathSelectorAdminHierarchy:
		return 0, false
	case Location_FieldPathSelectorCoordinates:
		return 0, false
	case Location_FieldPathSelectorAccuracy:
		leftValue := fpv.value.(float64)
		rightValue := source.GetAccuracy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fpv.selector))
	}
}

func (fpv *Location_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Location))
}

type Location_FieldSubPathValue struct {
	Location_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Location_FieldPathValue = (*Location_FieldSubPathValue)(nil)

func (fpvs *Location_FieldSubPathValue) AsAddressPathValue() (Address_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Address_FieldPathValue)
	return res, ok
}
func (fpvs *Location_FieldSubPathValue) AsAdminHierarchyPathValue() (admin_area.AdminHierarchy_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(admin_area.AdminHierarchy_FieldPathValue)
	return res, ok
}

func (fpvs *Location_FieldSubPathValue) SetTo(target **Location) {
	if *target == nil {
		*target = new(Location)
	}
	switch fpvs.Selector() {
	case Location_FieldPathSelectorAddress:
		fpvs.subPathValue.(Address_FieldPathValue).SetTo(&(*target).Address)
	case Location_FieldPathSelectorAdminHierarchy:
		fpvs.subPathValue.(admin_area.AdminHierarchy_FieldPathValue).SetTo(&(*target).AdminHierarchy)
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fpvs.Selector()))
	}
}

func (fpvs *Location_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Location)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Location_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Location_FieldSubPathValue) CompareWith(source *Location) (int, bool) {
	switch fpvs.Selector() {
	case Location_FieldPathSelectorAddress:
		return fpvs.subPathValue.(Address_FieldPathValue).CompareWith(source.GetAddress())
	case Location_FieldPathSelectorAdminHierarchy:
		return fpvs.subPathValue.(admin_area.AdminHierarchy_FieldPathValue).CompareWith(source.GetAdminHierarchy())
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fpvs.Selector()))
	}
}

func (fpvs *Location_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Location))
}

// Location_FieldPathArrayItemValue allows storing single item in Path-specific values for Location according to their type
// Present only for array (repeated) types.
type Location_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Location_FieldPath
	ContainsValue(*Location) bool
}

// ParseLocation_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLocation_FieldPathArrayItemValue(pathStr, valueStr string) (Location_FieldPathArrayItemValue, error) {
	fp, err := ParseLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Location field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Location_FieldPathArrayItemValue), nil
}

func MustParseLocation_FieldPathArrayItemValue(pathStr, valueStr string) Location_FieldPathArrayItemValue {
	fpaiv, err := ParseLocation_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Location_FieldTerminalPathArrayItemValue struct {
	Location_FieldTerminalPath
	value interface{}
}

var _ Location_FieldPathArrayItemValue = (*Location_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Location as interface{}
func (fpaiv *Location_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Location_FieldTerminalPathArrayItemValue) GetSingle(source *Location) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Location_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Location))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Location'
func (fpaiv *Location_FieldTerminalPathArrayItemValue) ContainsValue(source *Location) bool {
	slice := fpaiv.Location_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Location_FieldSubPathArrayItemValue struct {
	Location_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Location_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Location_FieldSubPathArrayItemValue) AsAddressPathItemValue() (Address_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Address_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Location_FieldSubPathArrayItemValue) AsAdminHierarchyPathItemValue() (admin_area.AdminHierarchy_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(admin_area.AdminHierarchy_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Location'
func (fpaivs *Location_FieldSubPathArrayItemValue) ContainsValue(source *Location) bool {
	switch fpaivs.Selector() {
	case Location_FieldPathSelectorAddress:
		return fpaivs.subPathItemValue.(Address_FieldPathArrayItemValue).ContainsValue(source.GetAddress())
	case Location_FieldPathSelectorAdminHierarchy:
		return fpaivs.subPathItemValue.(admin_area.AdminHierarchy_FieldPathArrayItemValue).ContainsValue(source.GetAdminHierarchy())
	default:
		panic(fmt.Sprintf("Invalid selector for Location: %d", fpaivs.Selector()))
	}
}

// Location_FieldPathArrayOfValues allows storing slice of values for Location fields according to their type
type Location_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Location_FieldPath
}

func ParseLocation_FieldPathArrayOfValues(pathStr, valuesStr string) (Location_FieldPathArrayOfValues, error) {
	fp, err := ParseLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Location field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Location_FieldPathArrayOfValues), nil
}

func MustParseLocation_FieldPathArrayOfValues(pathStr, valuesStr string) Location_FieldPathArrayOfValues {
	fpaov, err := ParseLocation_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Location_FieldTerminalPathArrayOfValues struct {
	Location_FieldTerminalPath
	values interface{}
}

var _ Location_FieldPathArrayOfValues = (*Location_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Location_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Location_FieldPathSelectorAddress:
		for _, v := range fpaov.values.([]*Address) {
			values = append(values, v)
		}
	case Location_FieldPathSelectorAdminHierarchy:
		for _, v := range fpaov.values.([]*admin_area.AdminHierarchy) {
			values = append(values, v)
		}
	case Location_FieldPathSelectorCoordinates:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	case Location_FieldPathSelectorAccuracy:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Location_FieldTerminalPathArrayOfValues) AsAddressArrayOfValues() ([]*Address, bool) {
	res, ok := fpaov.values.([]*Address)
	return res, ok
}
func (fpaov *Location_FieldTerminalPathArrayOfValues) AsAdminHierarchyArrayOfValues() ([]*admin_area.AdminHierarchy, bool) {
	res, ok := fpaov.values.([]*admin_area.AdminHierarchy)
	return res, ok
}
func (fpaov *Location_FieldTerminalPathArrayOfValues) AsCoordinatesArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}
func (fpaov *Location_FieldTerminalPathArrayOfValues) AsAccuracyArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

type Location_FieldSubPathArrayOfValues struct {
	Location_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Location_FieldPathArrayOfValues = (*Location_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Location_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Location_FieldSubPathArrayOfValues) AsAddressPathArrayOfValues() (Address_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Address_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Location_FieldSubPathArrayOfValues) AsAdminHierarchyPathArrayOfValues() (admin_area.AdminHierarchy_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(admin_area.AdminHierarchy_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ASInfo_FieldPath interface {
	gotenobject.FieldPath
	Selector() ASInfo_FieldPathSelector
	Get(source *ASInfo) []interface{}
	GetSingle(source *ASInfo) (interface{}, bool)
	ClearValue(item *ASInfo)

	// Those methods build corresponding ASInfo_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ASInfo_FieldPathValue
	WithIArrayOfValues(values interface{}) ASInfo_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ASInfo_FieldPathArrayItemValue
}

type ASInfo_FieldPathSelector int32

const (
	ASInfo_FieldPathSelectorAsn     ASInfo_FieldPathSelector = 0
	ASInfo_FieldPathSelectorName    ASInfo_FieldPathSelector = 1
	ASInfo_FieldPathSelectorDomain  ASInfo_FieldPathSelector = 2
	ASInfo_FieldPathSelectorRoutes  ASInfo_FieldPathSelector = 3
	ASInfo_FieldPathSelectorAsnType ASInfo_FieldPathSelector = 4
)

func (s ASInfo_FieldPathSelector) String() string {
	switch s {
	case ASInfo_FieldPathSelectorAsn:
		return "asn"
	case ASInfo_FieldPathSelectorName:
		return "name"
	case ASInfo_FieldPathSelectorDomain:
		return "domain"
	case ASInfo_FieldPathSelectorRoutes:
		return "routes"
	case ASInfo_FieldPathSelectorAsnType:
		return "asn_type"
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", s))
	}
}

func BuildASInfo_FieldPath(fp gotenobject.RawFieldPath) (ASInfo_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ASInfo")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "asn":
			return &ASInfo_FieldTerminalPath{selector: ASInfo_FieldPathSelectorAsn}, nil
		case "name":
			return &ASInfo_FieldTerminalPath{selector: ASInfo_FieldPathSelectorName}, nil
		case "domain":
			return &ASInfo_FieldTerminalPath{selector: ASInfo_FieldPathSelectorDomain}, nil
		case "routes":
			return &ASInfo_FieldTerminalPath{selector: ASInfo_FieldPathSelectorRoutes}, nil
		case "asn_type", "asnType", "asn-type":
			return &ASInfo_FieldTerminalPath{selector: ASInfo_FieldPathSelectorAsnType}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ASInfo", fp)
}

func ParseASInfo_FieldPath(rawField string) (ASInfo_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildASInfo_FieldPath(fp)
}

func MustParseASInfo_FieldPath(rawField string) ASInfo_FieldPath {
	fp, err := ParseASInfo_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ASInfo_FieldTerminalPath struct {
	selector ASInfo_FieldPathSelector
}

var _ ASInfo_FieldPath = (*ASInfo_FieldTerminalPath)(nil)

func (fp *ASInfo_FieldTerminalPath) Selector() ASInfo_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ASInfo_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ASInfo_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ASInfo
func (fp *ASInfo_FieldTerminalPath) Get(source *ASInfo) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ASInfo_FieldPathSelectorAsn:
			values = append(values, source.Asn)
		case ASInfo_FieldPathSelectorName:
			values = append(values, source.Name)
		case ASInfo_FieldPathSelectorDomain:
			values = append(values, source.Domain)
		case ASInfo_FieldPathSelectorRoutes:
			for _, value := range source.GetRoutes() {
				values = append(values, value)
			}
		case ASInfo_FieldPathSelectorAsnType:
			values = append(values, source.AsnType)
		default:
			panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
		}
	}
	return
}

func (fp *ASInfo_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ASInfo))
}

// GetSingle returns value pointed by specific field of from source ASInfo
func (fp *ASInfo_FieldTerminalPath) GetSingle(source *ASInfo) (interface{}, bool) {
	switch fp.selector {
	case ASInfo_FieldPathSelectorAsn:
		return source.GetAsn(), source != nil
	case ASInfo_FieldPathSelectorName:
		return source.GetName(), source != nil
	case ASInfo_FieldPathSelectorDomain:
		return source.GetDomain(), source != nil
	case ASInfo_FieldPathSelectorRoutes:
		res := source.GetRoutes()
		return res, res != nil
	case ASInfo_FieldPathSelectorAsnType:
		return source.GetAsnType(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
	}
}

func (fp *ASInfo_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ASInfo))
}

// GetDefault returns a default value of the field type
func (fp *ASInfo_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ASInfo_FieldPathSelectorAsn:
		return ""
	case ASInfo_FieldPathSelectorName:
		return ""
	case ASInfo_FieldPathSelectorDomain:
		return ""
	case ASInfo_FieldPathSelectorRoutes:
		return ([]string)(nil)
	case ASInfo_FieldPathSelectorAsnType:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
	}
}

func (fp *ASInfo_FieldTerminalPath) ClearValue(item *ASInfo) {
	if item != nil {
		switch fp.selector {
		case ASInfo_FieldPathSelectorAsn:
			item.Asn = ""
		case ASInfo_FieldPathSelectorName:
			item.Name = ""
		case ASInfo_FieldPathSelectorDomain:
			item.Domain = ""
		case ASInfo_FieldPathSelectorRoutes:
			item.Routes = nil
		case ASInfo_FieldPathSelectorAsnType:
			item.AsnType = ""
		default:
			panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
		}
	}
}

func (fp *ASInfo_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ASInfo))
}

// IsLeaf - whether field path is holds simple value
func (fp *ASInfo_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ASInfo_FieldPathSelectorAsn ||
		fp.selector == ASInfo_FieldPathSelectorName ||
		fp.selector == ASInfo_FieldPathSelectorDomain ||
		fp.selector == ASInfo_FieldPathSelectorRoutes ||
		fp.selector == ASInfo_FieldPathSelectorAsnType
}

func (fp *ASInfo_FieldTerminalPath) WithIValue(value interface{}) ASInfo_FieldPathValue {
	switch fp.selector {
	case ASInfo_FieldPathSelectorAsn:
		return &ASInfo_FieldTerminalPathValue{ASInfo_FieldTerminalPath: *fp, value: value.(string)}
	case ASInfo_FieldPathSelectorName:
		return &ASInfo_FieldTerminalPathValue{ASInfo_FieldTerminalPath: *fp, value: value.(string)}
	case ASInfo_FieldPathSelectorDomain:
		return &ASInfo_FieldTerminalPathValue{ASInfo_FieldTerminalPath: *fp, value: value.(string)}
	case ASInfo_FieldPathSelectorRoutes:
		return &ASInfo_FieldTerminalPathValue{ASInfo_FieldTerminalPath: *fp, value: value.([]string)}
	case ASInfo_FieldPathSelectorAsnType:
		return &ASInfo_FieldTerminalPathValue{ASInfo_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
	}
}

func (fp *ASInfo_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ASInfo_FieldTerminalPath) WithIArrayOfValues(values interface{}) ASInfo_FieldPathArrayOfValues {
	fpaov := &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp}
	switch fp.selector {
	case ASInfo_FieldPathSelectorAsn:
		return &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp, values: values.([]string)}
	case ASInfo_FieldPathSelectorName:
		return &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp, values: values.([]string)}
	case ASInfo_FieldPathSelectorDomain:
		return &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp, values: values.([]string)}
	case ASInfo_FieldPathSelectorRoutes:
		return &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp, values: values.([][]string)}
	case ASInfo_FieldPathSelectorAsnType:
		return &ASInfo_FieldTerminalPathArrayOfValues{ASInfo_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
	}
	return fpaov
}

func (fp *ASInfo_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ASInfo_FieldTerminalPath) WithIArrayItemValue(value interface{}) ASInfo_FieldPathArrayItemValue {
	switch fp.selector {
	case ASInfo_FieldPathSelectorRoutes:
		return &ASInfo_FieldTerminalPathArrayItemValue{ASInfo_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fp.selector))
	}
}

func (fp *ASInfo_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ASInfo_FieldPathValue allows storing values for ASInfo fields according to their type
type ASInfo_FieldPathValue interface {
	ASInfo_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ASInfo)
	CompareWith(*ASInfo) (cmp int, comparable bool)
}

func ParseASInfo_FieldPathValue(pathStr, valueStr string) (ASInfo_FieldPathValue, error) {
	fp, err := ParseASInfo_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ASInfo field path value from %s: %v", valueStr, err)
	}
	return fpv.(ASInfo_FieldPathValue), nil
}

func MustParseASInfo_FieldPathValue(pathStr, valueStr string) ASInfo_FieldPathValue {
	fpv, err := ParseASInfo_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ASInfo_FieldTerminalPathValue struct {
	ASInfo_FieldTerminalPath
	value interface{}
}

var _ ASInfo_FieldPathValue = (*ASInfo_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ASInfo' as interface{}
func (fpv *ASInfo_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ASInfo_FieldTerminalPathValue) AsAsnValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ASInfo_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ASInfo_FieldTerminalPathValue) AsDomainValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ASInfo_FieldTerminalPathValue) AsRoutesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *ASInfo_FieldTerminalPathValue) AsAsnTypeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object ASInfo
func (fpv *ASInfo_FieldTerminalPathValue) SetTo(target **ASInfo) {
	if *target == nil {
		*target = new(ASInfo)
	}
	switch fpv.selector {
	case ASInfo_FieldPathSelectorAsn:
		(*target).Asn = fpv.value.(string)
	case ASInfo_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case ASInfo_FieldPathSelectorDomain:
		(*target).Domain = fpv.value.(string)
	case ASInfo_FieldPathSelectorRoutes:
		(*target).Routes = fpv.value.([]string)
	case ASInfo_FieldPathSelectorAsnType:
		(*target).AsnType = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fpv.selector))
	}
}

func (fpv *ASInfo_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ASInfo)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ASInfo_FieldTerminalPathValue' with the value under path in 'ASInfo'.
func (fpv *ASInfo_FieldTerminalPathValue) CompareWith(source *ASInfo) (int, bool) {
	switch fpv.selector {
	case ASInfo_FieldPathSelectorAsn:
		leftValue := fpv.value.(string)
		rightValue := source.GetAsn()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ASInfo_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ASInfo_FieldPathSelectorDomain:
		leftValue := fpv.value.(string)
		rightValue := source.GetDomain()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ASInfo_FieldPathSelectorRoutes:
		return 0, false
	case ASInfo_FieldPathSelectorAsnType:
		leftValue := fpv.value.(string)
		rightValue := source.GetAsnType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ASInfo: %d", fpv.selector))
	}
}

func (fpv *ASInfo_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ASInfo))
}

// ASInfo_FieldPathArrayItemValue allows storing single item in Path-specific values for ASInfo according to their type
// Present only for array (repeated) types.
type ASInfo_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ASInfo_FieldPath
	ContainsValue(*ASInfo) bool
}

// ParseASInfo_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseASInfo_FieldPathArrayItemValue(pathStr, valueStr string) (ASInfo_FieldPathArrayItemValue, error) {
	fp, err := ParseASInfo_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ASInfo field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ASInfo_FieldPathArrayItemValue), nil
}

func MustParseASInfo_FieldPathArrayItemValue(pathStr, valueStr string) ASInfo_FieldPathArrayItemValue {
	fpaiv, err := ParseASInfo_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ASInfo_FieldTerminalPathArrayItemValue struct {
	ASInfo_FieldTerminalPath
	value interface{}
}

var _ ASInfo_FieldPathArrayItemValue = (*ASInfo_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ASInfo as interface{}
func (fpaiv *ASInfo_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ASInfo_FieldTerminalPathArrayItemValue) AsRoutesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *ASInfo_FieldTerminalPathArrayItemValue) GetSingle(source *ASInfo) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ASInfo_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ASInfo))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ASInfo'
func (fpaiv *ASInfo_FieldTerminalPathArrayItemValue) ContainsValue(source *ASInfo) bool {
	slice := fpaiv.ASInfo_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ASInfo_FieldPathArrayOfValues allows storing slice of values for ASInfo fields according to their type
type ASInfo_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ASInfo_FieldPath
}

func ParseASInfo_FieldPathArrayOfValues(pathStr, valuesStr string) (ASInfo_FieldPathArrayOfValues, error) {
	fp, err := ParseASInfo_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ASInfo field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ASInfo_FieldPathArrayOfValues), nil
}

func MustParseASInfo_FieldPathArrayOfValues(pathStr, valuesStr string) ASInfo_FieldPathArrayOfValues {
	fpaov, err := ParseASInfo_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ASInfo_FieldTerminalPathArrayOfValues struct {
	ASInfo_FieldTerminalPath
	values interface{}
}

var _ ASInfo_FieldPathArrayOfValues = (*ASInfo_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ASInfo_FieldPathSelectorAsn:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ASInfo_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ASInfo_FieldPathSelectorDomain:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ASInfo_FieldPathSelectorRoutes:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case ASInfo_FieldPathSelectorAsnType:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) AsAsnArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) AsDomainArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) AsRoutesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *ASInfo_FieldTerminalPathArrayOfValues) AsAsnTypeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Carrier_FieldPath interface {
	gotenobject.FieldPath
	Selector() Carrier_FieldPathSelector
	Get(source *Carrier) []interface{}
	GetSingle(source *Carrier) (interface{}, bool)
	ClearValue(item *Carrier)

	// Those methods build corresponding Carrier_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Carrier_FieldPathValue
	WithIArrayOfValues(values interface{}) Carrier_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Carrier_FieldPathArrayItemValue
}

type Carrier_FieldPathSelector int32

const (
	Carrier_FieldPathSelectorName              Carrier_FieldPathSelector = 0
	Carrier_FieldPathSelectorMobileCountryCode Carrier_FieldPathSelector = 1
	Carrier_FieldPathSelectorMobileNetworkCode Carrier_FieldPathSelector = 2
	Carrier_FieldPathSelectorLocationAreaCode  Carrier_FieldPathSelector = 3
)

func (s Carrier_FieldPathSelector) String() string {
	switch s {
	case Carrier_FieldPathSelectorName:
		return "name"
	case Carrier_FieldPathSelectorMobileCountryCode:
		return "mobile_country_code"
	case Carrier_FieldPathSelectorMobileNetworkCode:
		return "mobile_network_code"
	case Carrier_FieldPathSelectorLocationAreaCode:
		return "location_area_code"
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", s))
	}
}

func BuildCarrier_FieldPath(fp gotenobject.RawFieldPath) (Carrier_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Carrier")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &Carrier_FieldTerminalPath{selector: Carrier_FieldPathSelectorName}, nil
		case "mobile_country_code", "mobileCountryCode", "mobile-country-code":
			return &Carrier_FieldTerminalPath{selector: Carrier_FieldPathSelectorMobileCountryCode}, nil
		case "mobile_network_code", "mobileNetworkCode", "mobile-network-code":
			return &Carrier_FieldTerminalPath{selector: Carrier_FieldPathSelectorMobileNetworkCode}, nil
		case "location_area_code", "locationAreaCode", "location-area-code":
			return &Carrier_FieldTerminalPath{selector: Carrier_FieldPathSelectorLocationAreaCode}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Carrier", fp)
}

func ParseCarrier_FieldPath(rawField string) (Carrier_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildCarrier_FieldPath(fp)
}

func MustParseCarrier_FieldPath(rawField string) Carrier_FieldPath {
	fp, err := ParseCarrier_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Carrier_FieldTerminalPath struct {
	selector Carrier_FieldPathSelector
}

var _ Carrier_FieldPath = (*Carrier_FieldTerminalPath)(nil)

func (fp *Carrier_FieldTerminalPath) Selector() Carrier_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Carrier_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Carrier_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Carrier
func (fp *Carrier_FieldTerminalPath) Get(source *Carrier) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Carrier_FieldPathSelectorName:
			values = append(values, source.Name)
		case Carrier_FieldPathSelectorMobileCountryCode:
			values = append(values, source.MobileCountryCode)
		case Carrier_FieldPathSelectorMobileNetworkCode:
			values = append(values, source.MobileNetworkCode)
		case Carrier_FieldPathSelectorLocationAreaCode:
			values = append(values, source.LocationAreaCode)
		default:
			panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
		}
	}
	return
}

func (fp *Carrier_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Carrier))
}

// GetSingle returns value pointed by specific field of from source Carrier
func (fp *Carrier_FieldTerminalPath) GetSingle(source *Carrier) (interface{}, bool) {
	switch fp.selector {
	case Carrier_FieldPathSelectorName:
		return source.GetName(), source != nil
	case Carrier_FieldPathSelectorMobileCountryCode:
		return source.GetMobileCountryCode(), source != nil
	case Carrier_FieldPathSelectorMobileNetworkCode:
		return source.GetMobileNetworkCode(), source != nil
	case Carrier_FieldPathSelectorLocationAreaCode:
		return source.GetLocationAreaCode(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
	}
}

func (fp *Carrier_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Carrier))
}

// GetDefault returns a default value of the field type
func (fp *Carrier_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Carrier_FieldPathSelectorName:
		return ""
	case Carrier_FieldPathSelectorMobileCountryCode:
		return ""
	case Carrier_FieldPathSelectorMobileNetworkCode:
		return ""
	case Carrier_FieldPathSelectorLocationAreaCode:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
	}
}

func (fp *Carrier_FieldTerminalPath) ClearValue(item *Carrier) {
	if item != nil {
		switch fp.selector {
		case Carrier_FieldPathSelectorName:
			item.Name = ""
		case Carrier_FieldPathSelectorMobileCountryCode:
			item.MobileCountryCode = ""
		case Carrier_FieldPathSelectorMobileNetworkCode:
			item.MobileNetworkCode = ""
		case Carrier_FieldPathSelectorLocationAreaCode:
			item.LocationAreaCode = ""
		default:
			panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
		}
	}
}

func (fp *Carrier_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Carrier))
}

// IsLeaf - whether field path is holds simple value
func (fp *Carrier_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Carrier_FieldPathSelectorName ||
		fp.selector == Carrier_FieldPathSelectorMobileCountryCode ||
		fp.selector == Carrier_FieldPathSelectorMobileNetworkCode ||
		fp.selector == Carrier_FieldPathSelectorLocationAreaCode
}

func (fp *Carrier_FieldTerminalPath) WithIValue(value interface{}) Carrier_FieldPathValue {
	switch fp.selector {
	case Carrier_FieldPathSelectorName:
		return &Carrier_FieldTerminalPathValue{Carrier_FieldTerminalPath: *fp, value: value.(string)}
	case Carrier_FieldPathSelectorMobileCountryCode:
		return &Carrier_FieldTerminalPathValue{Carrier_FieldTerminalPath: *fp, value: value.(string)}
	case Carrier_FieldPathSelectorMobileNetworkCode:
		return &Carrier_FieldTerminalPathValue{Carrier_FieldTerminalPath: *fp, value: value.(string)}
	case Carrier_FieldPathSelectorLocationAreaCode:
		return &Carrier_FieldTerminalPathValue{Carrier_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
	}
}

func (fp *Carrier_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Carrier_FieldTerminalPath) WithIArrayOfValues(values interface{}) Carrier_FieldPathArrayOfValues {
	fpaov := &Carrier_FieldTerminalPathArrayOfValues{Carrier_FieldTerminalPath: *fp}
	switch fp.selector {
	case Carrier_FieldPathSelectorName:
		return &Carrier_FieldTerminalPathArrayOfValues{Carrier_FieldTerminalPath: *fp, values: values.([]string)}
	case Carrier_FieldPathSelectorMobileCountryCode:
		return &Carrier_FieldTerminalPathArrayOfValues{Carrier_FieldTerminalPath: *fp, values: values.([]string)}
	case Carrier_FieldPathSelectorMobileNetworkCode:
		return &Carrier_FieldTerminalPathArrayOfValues{Carrier_FieldTerminalPath: *fp, values: values.([]string)}
	case Carrier_FieldPathSelectorLocationAreaCode:
		return &Carrier_FieldTerminalPathArrayOfValues{Carrier_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
	}
	return fpaov
}

func (fp *Carrier_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Carrier_FieldTerminalPath) WithIArrayItemValue(value interface{}) Carrier_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fp.selector))
	}
}

func (fp *Carrier_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Carrier_FieldPathValue allows storing values for Carrier fields according to their type
type Carrier_FieldPathValue interface {
	Carrier_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Carrier)
	CompareWith(*Carrier) (cmp int, comparable bool)
}

func ParseCarrier_FieldPathValue(pathStr, valueStr string) (Carrier_FieldPathValue, error) {
	fp, err := ParseCarrier_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Carrier field path value from %s: %v", valueStr, err)
	}
	return fpv.(Carrier_FieldPathValue), nil
}

func MustParseCarrier_FieldPathValue(pathStr, valueStr string) Carrier_FieldPathValue {
	fpv, err := ParseCarrier_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Carrier_FieldTerminalPathValue struct {
	Carrier_FieldTerminalPath
	value interface{}
}

var _ Carrier_FieldPathValue = (*Carrier_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Carrier' as interface{}
func (fpv *Carrier_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Carrier_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Carrier_FieldTerminalPathValue) AsMobileCountryCodeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Carrier_FieldTerminalPathValue) AsMobileNetworkCodeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Carrier_FieldTerminalPathValue) AsLocationAreaCodeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object Carrier
func (fpv *Carrier_FieldTerminalPathValue) SetTo(target **Carrier) {
	if *target == nil {
		*target = new(Carrier)
	}
	switch fpv.selector {
	case Carrier_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case Carrier_FieldPathSelectorMobileCountryCode:
		(*target).MobileCountryCode = fpv.value.(string)
	case Carrier_FieldPathSelectorMobileNetworkCode:
		(*target).MobileNetworkCode = fpv.value.(string)
	case Carrier_FieldPathSelectorLocationAreaCode:
		(*target).LocationAreaCode = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fpv.selector))
	}
}

func (fpv *Carrier_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Carrier)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Carrier_FieldTerminalPathValue' with the value under path in 'Carrier'.
func (fpv *Carrier_FieldTerminalPathValue) CompareWith(source *Carrier) (int, bool) {
	switch fpv.selector {
	case Carrier_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Carrier_FieldPathSelectorMobileCountryCode:
		leftValue := fpv.value.(string)
		rightValue := source.GetMobileCountryCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Carrier_FieldPathSelectorMobileNetworkCode:
		leftValue := fpv.value.(string)
		rightValue := source.GetMobileNetworkCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Carrier_FieldPathSelectorLocationAreaCode:
		leftValue := fpv.value.(string)
		rightValue := source.GetLocationAreaCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Carrier: %d", fpv.selector))
	}
}

func (fpv *Carrier_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Carrier))
}

// Carrier_FieldPathArrayItemValue allows storing single item in Path-specific values for Carrier according to their type
// Present only for array (repeated) types.
type Carrier_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Carrier_FieldPath
	ContainsValue(*Carrier) bool
}

// ParseCarrier_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseCarrier_FieldPathArrayItemValue(pathStr, valueStr string) (Carrier_FieldPathArrayItemValue, error) {
	fp, err := ParseCarrier_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Carrier field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Carrier_FieldPathArrayItemValue), nil
}

func MustParseCarrier_FieldPathArrayItemValue(pathStr, valueStr string) Carrier_FieldPathArrayItemValue {
	fpaiv, err := ParseCarrier_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Carrier_FieldTerminalPathArrayItemValue struct {
	Carrier_FieldTerminalPath
	value interface{}
}

var _ Carrier_FieldPathArrayItemValue = (*Carrier_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Carrier as interface{}
func (fpaiv *Carrier_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Carrier_FieldTerminalPathArrayItemValue) GetSingle(source *Carrier) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Carrier_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Carrier))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Carrier'
func (fpaiv *Carrier_FieldTerminalPathArrayItemValue) ContainsValue(source *Carrier) bool {
	slice := fpaiv.Carrier_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Carrier_FieldPathArrayOfValues allows storing slice of values for Carrier fields according to their type
type Carrier_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Carrier_FieldPath
}

func ParseCarrier_FieldPathArrayOfValues(pathStr, valuesStr string) (Carrier_FieldPathArrayOfValues, error) {
	fp, err := ParseCarrier_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Carrier field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Carrier_FieldPathArrayOfValues), nil
}

func MustParseCarrier_FieldPathArrayOfValues(pathStr, valuesStr string) Carrier_FieldPathArrayOfValues {
	fpaov, err := ParseCarrier_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Carrier_FieldTerminalPathArrayOfValues struct {
	Carrier_FieldTerminalPath
	values interface{}
}

var _ Carrier_FieldPathArrayOfValues = (*Carrier_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Carrier_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Carrier_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Carrier_FieldPathSelectorMobileCountryCode:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Carrier_FieldPathSelectorMobileNetworkCode:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Carrier_FieldPathSelectorLocationAreaCode:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Carrier_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Carrier_FieldTerminalPathArrayOfValues) AsMobileCountryCodeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Carrier_FieldTerminalPathArrayOfValues) AsMobileNetworkCodeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Carrier_FieldTerminalPathArrayOfValues) AsLocationAreaCodeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LocationDiscoverySpec_FieldPath interface {
	gotenobject.FieldPath
	Selector() LocationDiscoverySpec_FieldPathSelector
	Get(source *LocationDiscoverySpec) []interface{}
	GetSingle(source *LocationDiscoverySpec) (interface{}, bool)
	ClearValue(item *LocationDiscoverySpec)

	// Those methods build corresponding LocationDiscoverySpec_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LocationDiscoverySpec_FieldPathValue
	WithIArrayOfValues(values interface{}) LocationDiscoverySpec_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LocationDiscoverySpec_FieldPathArrayItemValue
}

type LocationDiscoverySpec_FieldPathSelector int32

const (
	LocationDiscoverySpec_FieldPathSelectorType             LocationDiscoverySpec_FieldPathSelector = 0
	LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy LocationDiscoverySpec_FieldPathSelector = 1
)

func (s LocationDiscoverySpec_FieldPathSelector) String() string {
	switch s {
	case LocationDiscoverySpec_FieldPathSelectorType:
		return "type"
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		return "required_accuracy"
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", s))
	}
}

func BuildLocationDiscoverySpec_FieldPath(fp gotenobject.RawFieldPath) (LocationDiscoverySpec_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LocationDiscoverySpec")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "type":
			return &LocationDiscoverySpec_FieldTerminalPath{selector: LocationDiscoverySpec_FieldPathSelectorType}, nil
		case "required_accuracy", "requiredAccuracy", "required-accuracy":
			return &LocationDiscoverySpec_FieldTerminalPath{selector: LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LocationDiscoverySpec", fp)
}

func ParseLocationDiscoverySpec_FieldPath(rawField string) (LocationDiscoverySpec_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLocationDiscoverySpec_FieldPath(fp)
}

func MustParseLocationDiscoverySpec_FieldPath(rawField string) LocationDiscoverySpec_FieldPath {
	fp, err := ParseLocationDiscoverySpec_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LocationDiscoverySpec_FieldTerminalPath struct {
	selector LocationDiscoverySpec_FieldPathSelector
}

var _ LocationDiscoverySpec_FieldPath = (*LocationDiscoverySpec_FieldTerminalPath)(nil)

func (fp *LocationDiscoverySpec_FieldTerminalPath) Selector() LocationDiscoverySpec_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LocationDiscoverySpec_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LocationDiscoverySpec_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LocationDiscoverySpec
func (fp *LocationDiscoverySpec_FieldTerminalPath) Get(source *LocationDiscoverySpec) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LocationDiscoverySpec_FieldPathSelectorType:
			values = append(values, source.Type)
		case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
			values = append(values, source.RequiredAccuracy)
		default:
			panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
		}
	}
	return
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LocationDiscoverySpec))
}

// GetSingle returns value pointed by specific field of from source LocationDiscoverySpec
func (fp *LocationDiscoverySpec_FieldTerminalPath) GetSingle(source *LocationDiscoverySpec) (interface{}, bool) {
	switch fp.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		return source.GetType(), source != nil
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		return source.GetRequiredAccuracy(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
	}
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LocationDiscoverySpec))
}

// GetDefault returns a default value of the field type
func (fp *LocationDiscoverySpec_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		return LocationDiscoverySpec_TYPE_UNSPECIFIED
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
	}
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) ClearValue(item *LocationDiscoverySpec) {
	if item != nil {
		switch fp.selector {
		case LocationDiscoverySpec_FieldPathSelectorType:
			item.Type = LocationDiscoverySpec_TYPE_UNSPECIFIED
		case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
			item.RequiredAccuracy = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
		}
	}
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LocationDiscoverySpec))
}

// IsLeaf - whether field path is holds simple value
func (fp *LocationDiscoverySpec_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LocationDiscoverySpec_FieldPathSelectorType ||
		fp.selector == LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithIValue(value interface{}) LocationDiscoverySpec_FieldPathValue {
	switch fp.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		return &LocationDiscoverySpec_FieldTerminalPathValue{LocationDiscoverySpec_FieldTerminalPath: *fp, value: value.(LocationDiscoverySpec_Type)}
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		return &LocationDiscoverySpec_FieldTerminalPathValue{LocationDiscoverySpec_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
	}
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithIArrayOfValues(values interface{}) LocationDiscoverySpec_FieldPathArrayOfValues {
	fpaov := &LocationDiscoverySpec_FieldTerminalPathArrayOfValues{LocationDiscoverySpec_FieldTerminalPath: *fp}
	switch fp.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		return &LocationDiscoverySpec_FieldTerminalPathArrayOfValues{LocationDiscoverySpec_FieldTerminalPath: *fp, values: values.([]LocationDiscoverySpec_Type)}
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		return &LocationDiscoverySpec_FieldTerminalPathArrayOfValues{LocationDiscoverySpec_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
	}
	return fpaov
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithIArrayItemValue(value interface{}) LocationDiscoverySpec_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fp.selector))
	}
}

func (fp *LocationDiscoverySpec_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LocationDiscoverySpec_FieldPathValue allows storing values for LocationDiscoverySpec fields according to their type
type LocationDiscoverySpec_FieldPathValue interface {
	LocationDiscoverySpec_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LocationDiscoverySpec)
	CompareWith(*LocationDiscoverySpec) (cmp int, comparable bool)
}

func ParseLocationDiscoverySpec_FieldPathValue(pathStr, valueStr string) (LocationDiscoverySpec_FieldPathValue, error) {
	fp, err := ParseLocationDiscoverySpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocationDiscoverySpec field path value from %s: %v", valueStr, err)
	}
	return fpv.(LocationDiscoverySpec_FieldPathValue), nil
}

func MustParseLocationDiscoverySpec_FieldPathValue(pathStr, valueStr string) LocationDiscoverySpec_FieldPathValue {
	fpv, err := ParseLocationDiscoverySpec_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LocationDiscoverySpec_FieldTerminalPathValue struct {
	LocationDiscoverySpec_FieldTerminalPath
	value interface{}
}

var _ LocationDiscoverySpec_FieldPathValue = (*LocationDiscoverySpec_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LocationDiscoverySpec' as interface{}
func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) AsTypeValue() (LocationDiscoverySpec_Type, bool) {
	res, ok := fpv.value.(LocationDiscoverySpec_Type)
	return res, ok
}
func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) AsRequiredAccuracyValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object LocationDiscoverySpec
func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) SetTo(target **LocationDiscoverySpec) {
	if *target == nil {
		*target = new(LocationDiscoverySpec)
	}
	switch fpv.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		(*target).Type = fpv.value.(LocationDiscoverySpec_Type)
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		(*target).RequiredAccuracy = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fpv.selector))
	}
}

func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LocationDiscoverySpec)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LocationDiscoverySpec_FieldTerminalPathValue' with the value under path in 'LocationDiscoverySpec'.
func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) CompareWith(source *LocationDiscoverySpec) (int, bool) {
	switch fpv.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		leftValue := fpv.value.(LocationDiscoverySpec_Type)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		leftValue := fpv.value.(float64)
		rightValue := source.GetRequiredAccuracy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LocationDiscoverySpec: %d", fpv.selector))
	}
}

func (fpv *LocationDiscoverySpec_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LocationDiscoverySpec))
}

// LocationDiscoverySpec_FieldPathArrayItemValue allows storing single item in Path-specific values for LocationDiscoverySpec according to their type
// Present only for array (repeated) types.
type LocationDiscoverySpec_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LocationDiscoverySpec_FieldPath
	ContainsValue(*LocationDiscoverySpec) bool
}

// ParseLocationDiscoverySpec_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLocationDiscoverySpec_FieldPathArrayItemValue(pathStr, valueStr string) (LocationDiscoverySpec_FieldPathArrayItemValue, error) {
	fp, err := ParseLocationDiscoverySpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocationDiscoverySpec field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LocationDiscoverySpec_FieldPathArrayItemValue), nil
}

func MustParseLocationDiscoverySpec_FieldPathArrayItemValue(pathStr, valueStr string) LocationDiscoverySpec_FieldPathArrayItemValue {
	fpaiv, err := ParseLocationDiscoverySpec_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LocationDiscoverySpec_FieldTerminalPathArrayItemValue struct {
	LocationDiscoverySpec_FieldTerminalPath
	value interface{}
}

var _ LocationDiscoverySpec_FieldPathArrayItemValue = (*LocationDiscoverySpec_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LocationDiscoverySpec as interface{}
func (fpaiv *LocationDiscoverySpec_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *LocationDiscoverySpec_FieldTerminalPathArrayItemValue) GetSingle(source *LocationDiscoverySpec) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LocationDiscoverySpec_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LocationDiscoverySpec))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LocationDiscoverySpec'
func (fpaiv *LocationDiscoverySpec_FieldTerminalPathArrayItemValue) ContainsValue(source *LocationDiscoverySpec) bool {
	slice := fpaiv.LocationDiscoverySpec_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LocationDiscoverySpec_FieldPathArrayOfValues allows storing slice of values for LocationDiscoverySpec fields according to their type
type LocationDiscoverySpec_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LocationDiscoverySpec_FieldPath
}

func ParseLocationDiscoverySpec_FieldPathArrayOfValues(pathStr, valuesStr string) (LocationDiscoverySpec_FieldPathArrayOfValues, error) {
	fp, err := ParseLocationDiscoverySpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocationDiscoverySpec field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LocationDiscoverySpec_FieldPathArrayOfValues), nil
}

func MustParseLocationDiscoverySpec_FieldPathArrayOfValues(pathStr, valuesStr string) LocationDiscoverySpec_FieldPathArrayOfValues {
	fpaov, err := ParseLocationDiscoverySpec_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LocationDiscoverySpec_FieldTerminalPathArrayOfValues struct {
	LocationDiscoverySpec_FieldTerminalPath
	values interface{}
}

var _ LocationDiscoverySpec_FieldPathArrayOfValues = (*LocationDiscoverySpec_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LocationDiscoverySpec_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LocationDiscoverySpec_FieldPathSelectorType:
		for _, v := range fpaov.values.([]LocationDiscoverySpec_Type) {
			values = append(values, v)
		}
	case LocationDiscoverySpec_FieldPathSelectorRequiredAccuracy:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LocationDiscoverySpec_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]LocationDiscoverySpec_Type, bool) {
	res, ok := fpaov.values.([]LocationDiscoverySpec_Type)
	return res, ok
}
func (fpaov *LocationDiscoverySpec_FieldTerminalPathArrayOfValues) AsRequiredAccuracyArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ProbingConstraint_FieldPath interface {
	gotenobject.FieldPath
	Selector() ProbingConstraint_FieldPathSelector
	Get(source *ProbingConstraint) []interface{}
	GetSingle(source *ProbingConstraint) (interface{}, bool)
	ClearValue(item *ProbingConstraint)

	// Those methods build corresponding ProbingConstraint_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ProbingConstraint_FieldPathValue
	WithIArrayOfValues(values interface{}) ProbingConstraint_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ProbingConstraint_FieldPathArrayItemValue
}

type ProbingConstraint_FieldPathSelector int32

const (
	ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation        ProbingConstraint_FieldPathSelector = 0
	ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress ProbingConstraint_FieldPathSelector = 1
)

func (s ProbingConstraint_FieldPathSelector) String() string {
	switch s {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return "max_sessions_per_agent_location"
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		return "max_sessions_per_agent_public_ip_address"
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", s))
	}
}

func BuildProbingConstraint_FieldPath(fp gotenobject.RawFieldPath) (ProbingConstraint_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ProbingConstraint")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "max_sessions_per_agent_location", "maxSessionsPerAgentLocation", "max-sessions-per-agent-location":
			return &ProbingConstraint_FieldTerminalPath{selector: ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation}, nil
		case "max_sessions_per_agent_public_ip_address", "maxSessionsPerAgentPublicIpAddress", "max-sessions-per-agent-public-ip-address":
			return &ProbingConstraint_FieldTerminalPath{selector: ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress}, nil
		}
	} else {
		switch fp[0] {
		case "max_sessions_per_agent_location", "maxSessionsPerAgentLocation", "max-sessions-per-agent-location":
			if subpath, err := BuildProbingConstraintAdminHierachy_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ProbingConstraint_FieldSubPath{selector: ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ProbingConstraint", fp)
}

func ParseProbingConstraint_FieldPath(rawField string) (ProbingConstraint_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildProbingConstraint_FieldPath(fp)
}

func MustParseProbingConstraint_FieldPath(rawField string) ProbingConstraint_FieldPath {
	fp, err := ParseProbingConstraint_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ProbingConstraint_FieldTerminalPath struct {
	selector ProbingConstraint_FieldPathSelector
}

var _ ProbingConstraint_FieldPath = (*ProbingConstraint_FieldTerminalPath)(nil)

func (fp *ProbingConstraint_FieldTerminalPath) Selector() ProbingConstraint_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ProbingConstraint_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ProbingConstraint_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ProbingConstraint
func (fp *ProbingConstraint_FieldTerminalPath) Get(source *ProbingConstraint) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
			if source.MaxSessionsPerAgentLocation != nil {
				values = append(values, source.MaxSessionsPerAgentLocation)
			}
		case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
			values = append(values, source.MaxSessionsPerAgentPublicIpAddress)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
		}
	}
	return
}

func (fp *ProbingConstraint_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ProbingConstraint))
}

// GetSingle returns value pointed by specific field of from source ProbingConstraint
func (fp *ProbingConstraint_FieldTerminalPath) GetSingle(source *ProbingConstraint) (interface{}, bool) {
	switch fp.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		res := source.GetMaxSessionsPerAgentLocation()
		return res, res != nil
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		return source.GetMaxSessionsPerAgentPublicIpAddress(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
	}
}

func (fp *ProbingConstraint_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ProbingConstraint))
}

// GetDefault returns a default value of the field type
func (fp *ProbingConstraint_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return (*ProbingConstraint_AdminHierachy)(nil)
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
	}
}

func (fp *ProbingConstraint_FieldTerminalPath) ClearValue(item *ProbingConstraint) {
	if item != nil {
		switch fp.selector {
		case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
			item.MaxSessionsPerAgentLocation = nil
		case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
			item.MaxSessionsPerAgentPublicIpAddress = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
		}
	}
}

func (fp *ProbingConstraint_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ProbingConstraint))
}

// IsLeaf - whether field path is holds simple value
func (fp *ProbingConstraint_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress
}

func (fp *ProbingConstraint_FieldTerminalPath) WithIValue(value interface{}) ProbingConstraint_FieldPathValue {
	switch fp.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return &ProbingConstraint_FieldTerminalPathValue{ProbingConstraint_FieldTerminalPath: *fp, value: value.(*ProbingConstraint_AdminHierachy)}
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		return &ProbingConstraint_FieldTerminalPathValue{ProbingConstraint_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
	}
}

func (fp *ProbingConstraint_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ProbingConstraint_FieldTerminalPath) WithIArrayOfValues(values interface{}) ProbingConstraint_FieldPathArrayOfValues {
	fpaov := &ProbingConstraint_FieldTerminalPathArrayOfValues{ProbingConstraint_FieldTerminalPath: *fp}
	switch fp.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return &ProbingConstraint_FieldTerminalPathArrayOfValues{ProbingConstraint_FieldTerminalPath: *fp, values: values.([]*ProbingConstraint_AdminHierachy)}
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		return &ProbingConstraint_FieldTerminalPathArrayOfValues{ProbingConstraint_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
	}
	return fpaov
}

func (fp *ProbingConstraint_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ProbingConstraint_FieldTerminalPath) WithIArrayItemValue(value interface{}) ProbingConstraint_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fp.selector))
	}
}

func (fp *ProbingConstraint_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ProbingConstraint_FieldSubPath struct {
	selector ProbingConstraint_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ProbingConstraint_FieldPath = (*ProbingConstraint_FieldSubPath)(nil)

func (fps *ProbingConstraint_FieldSubPath) Selector() ProbingConstraint_FieldPathSelector {
	return fps.selector
}
func (fps *ProbingConstraint_FieldSubPath) AsMaxSessionsPerAgentLocationSubPath() (ProbingConstraintAdminHierachy_FieldPath, bool) {
	res, ok := fps.subPath.(ProbingConstraintAdminHierachy_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ProbingConstraint_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ProbingConstraint_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ProbingConstraint
func (fps *ProbingConstraint_FieldSubPath) Get(source *ProbingConstraint) (values []interface{}) {
	if asAdminHierachyFieldPath, ok := fps.AsMaxSessionsPerAgentLocationSubPath(); ok {
		values = append(values, asAdminHierachyFieldPath.Get(source.GetMaxSessionsPerAgentLocation())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fps.selector))
	}
	return
}

func (fps *ProbingConstraint_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ProbingConstraint))
}

// GetSingle returns value of selected field from source ProbingConstraint
func (fps *ProbingConstraint_FieldSubPath) GetSingle(source *ProbingConstraint) (interface{}, bool) {
	switch fps.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		if source.GetMaxSessionsPerAgentLocation() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMaxSessionsPerAgentLocation())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fps.selector))
	}
}

func (fps *ProbingConstraint_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ProbingConstraint))
}

// GetDefault returns a default value of the field type
func (fps *ProbingConstraint_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ProbingConstraint_FieldSubPath) ClearValue(item *ProbingConstraint) {
	if item != nil {
		switch fps.selector {
		case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
			fps.subPath.ClearValueRaw(item.MaxSessionsPerAgentLocation)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fps.selector))
		}
	}
}

func (fps *ProbingConstraint_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ProbingConstraint))
}

// IsLeaf - whether field path is holds simple value
func (fps *ProbingConstraint_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ProbingConstraint_FieldSubPath) WithIValue(value interface{}) ProbingConstraint_FieldPathValue {
	return &ProbingConstraint_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ProbingConstraint_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ProbingConstraint_FieldSubPath) WithIArrayOfValues(values interface{}) ProbingConstraint_FieldPathArrayOfValues {
	return &ProbingConstraint_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ProbingConstraint_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ProbingConstraint_FieldSubPath) WithIArrayItemValue(value interface{}) ProbingConstraint_FieldPathArrayItemValue {
	return &ProbingConstraint_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ProbingConstraint_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ProbingConstraint_FieldPathValue allows storing values for ProbingConstraint fields according to their type
type ProbingConstraint_FieldPathValue interface {
	ProbingConstraint_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ProbingConstraint)
	CompareWith(*ProbingConstraint) (cmp int, comparable bool)
}

func ParseProbingConstraint_FieldPathValue(pathStr, valueStr string) (ProbingConstraint_FieldPathValue, error) {
	fp, err := ParseProbingConstraint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingConstraint field path value from %s: %v", valueStr, err)
	}
	return fpv.(ProbingConstraint_FieldPathValue), nil
}

func MustParseProbingConstraint_FieldPathValue(pathStr, valueStr string) ProbingConstraint_FieldPathValue {
	fpv, err := ParseProbingConstraint_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ProbingConstraint_FieldTerminalPathValue struct {
	ProbingConstraint_FieldTerminalPath
	value interface{}
}

var _ ProbingConstraint_FieldPathValue = (*ProbingConstraint_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ProbingConstraint' as interface{}
func (fpv *ProbingConstraint_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ProbingConstraint_FieldTerminalPathValue) AsMaxSessionsPerAgentLocationValue() (*ProbingConstraint_AdminHierachy, bool) {
	res, ok := fpv.value.(*ProbingConstraint_AdminHierachy)
	return res, ok
}
func (fpv *ProbingConstraint_FieldTerminalPathValue) AsMaxSessionsPerAgentPublicIpAddressValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object ProbingConstraint
func (fpv *ProbingConstraint_FieldTerminalPathValue) SetTo(target **ProbingConstraint) {
	if *target == nil {
		*target = new(ProbingConstraint)
	}
	switch fpv.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		(*target).MaxSessionsPerAgentLocation = fpv.value.(*ProbingConstraint_AdminHierachy)
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		(*target).MaxSessionsPerAgentPublicIpAddress = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fpv.selector))
	}
}

func (fpv *ProbingConstraint_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProbingConstraint)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ProbingConstraint_FieldTerminalPathValue' with the value under path in 'ProbingConstraint'.
func (fpv *ProbingConstraint_FieldTerminalPathValue) CompareWith(source *ProbingConstraint) (int, bool) {
	switch fpv.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return 0, false
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMaxSessionsPerAgentPublicIpAddress()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fpv.selector))
	}
}

func (fpv *ProbingConstraint_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ProbingConstraint))
}

type ProbingConstraint_FieldSubPathValue struct {
	ProbingConstraint_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ProbingConstraint_FieldPathValue = (*ProbingConstraint_FieldSubPathValue)(nil)

func (fpvs *ProbingConstraint_FieldSubPathValue) AsMaxSessionsPerAgentLocationPathValue() (ProbingConstraintAdminHierachy_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ProbingConstraintAdminHierachy_FieldPathValue)
	return res, ok
}

func (fpvs *ProbingConstraint_FieldSubPathValue) SetTo(target **ProbingConstraint) {
	if *target == nil {
		*target = new(ProbingConstraint)
	}
	switch fpvs.Selector() {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		fpvs.subPathValue.(ProbingConstraintAdminHierachy_FieldPathValue).SetTo(&(*target).MaxSessionsPerAgentLocation)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fpvs.Selector()))
	}
}

func (fpvs *ProbingConstraint_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProbingConstraint)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ProbingConstraint_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ProbingConstraint_FieldSubPathValue) CompareWith(source *ProbingConstraint) (int, bool) {
	switch fpvs.Selector() {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return fpvs.subPathValue.(ProbingConstraintAdminHierachy_FieldPathValue).CompareWith(source.GetMaxSessionsPerAgentLocation())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fpvs.Selector()))
	}
}

func (fpvs *ProbingConstraint_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ProbingConstraint))
}

// ProbingConstraint_FieldPathArrayItemValue allows storing single item in Path-specific values for ProbingConstraint according to their type
// Present only for array (repeated) types.
type ProbingConstraint_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ProbingConstraint_FieldPath
	ContainsValue(*ProbingConstraint) bool
}

// ParseProbingConstraint_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseProbingConstraint_FieldPathArrayItemValue(pathStr, valueStr string) (ProbingConstraint_FieldPathArrayItemValue, error) {
	fp, err := ParseProbingConstraint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingConstraint field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ProbingConstraint_FieldPathArrayItemValue), nil
}

func MustParseProbingConstraint_FieldPathArrayItemValue(pathStr, valueStr string) ProbingConstraint_FieldPathArrayItemValue {
	fpaiv, err := ParseProbingConstraint_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ProbingConstraint_FieldTerminalPathArrayItemValue struct {
	ProbingConstraint_FieldTerminalPath
	value interface{}
}

var _ ProbingConstraint_FieldPathArrayItemValue = (*ProbingConstraint_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ProbingConstraint as interface{}
func (fpaiv *ProbingConstraint_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ProbingConstraint_FieldTerminalPathArrayItemValue) GetSingle(source *ProbingConstraint) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ProbingConstraint_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ProbingConstraint))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ProbingConstraint'
func (fpaiv *ProbingConstraint_FieldTerminalPathArrayItemValue) ContainsValue(source *ProbingConstraint) bool {
	slice := fpaiv.ProbingConstraint_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ProbingConstraint_FieldSubPathArrayItemValue struct {
	ProbingConstraint_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ProbingConstraint_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ProbingConstraint_FieldSubPathArrayItemValue) AsMaxSessionsPerAgentLocationPathItemValue() (ProbingConstraintAdminHierachy_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ProbingConstraintAdminHierachy_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ProbingConstraint'
func (fpaivs *ProbingConstraint_FieldSubPathArrayItemValue) ContainsValue(source *ProbingConstraint) bool {
	switch fpaivs.Selector() {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		return fpaivs.subPathItemValue.(ProbingConstraintAdminHierachy_FieldPathArrayItemValue).ContainsValue(source.GetMaxSessionsPerAgentLocation())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint: %d", fpaivs.Selector()))
	}
}

// ProbingConstraint_FieldPathArrayOfValues allows storing slice of values for ProbingConstraint fields according to their type
type ProbingConstraint_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ProbingConstraint_FieldPath
}

func ParseProbingConstraint_FieldPathArrayOfValues(pathStr, valuesStr string) (ProbingConstraint_FieldPathArrayOfValues, error) {
	fp, err := ParseProbingConstraint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingConstraint field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ProbingConstraint_FieldPathArrayOfValues), nil
}

func MustParseProbingConstraint_FieldPathArrayOfValues(pathStr, valuesStr string) ProbingConstraint_FieldPathArrayOfValues {
	fpaov, err := ParseProbingConstraint_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ProbingConstraint_FieldTerminalPathArrayOfValues struct {
	ProbingConstraint_FieldTerminalPath
	values interface{}
}

var _ ProbingConstraint_FieldPathArrayOfValues = (*ProbingConstraint_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ProbingConstraint_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentLocation:
		for _, v := range fpaov.values.([]*ProbingConstraint_AdminHierachy) {
			values = append(values, v)
		}
	case ProbingConstraint_FieldPathSelectorMaxSessionsPerAgentPublicIpAddress:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ProbingConstraint_FieldTerminalPathArrayOfValues) AsMaxSessionsPerAgentLocationArrayOfValues() ([]*ProbingConstraint_AdminHierachy, bool) {
	res, ok := fpaov.values.([]*ProbingConstraint_AdminHierachy)
	return res, ok
}
func (fpaov *ProbingConstraint_FieldTerminalPathArrayOfValues) AsMaxSessionsPerAgentPublicIpAddressArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

type ProbingConstraint_FieldSubPathArrayOfValues struct {
	ProbingConstraint_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ProbingConstraint_FieldPathArrayOfValues = (*ProbingConstraint_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ProbingConstraint_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ProbingConstraint_FieldSubPathArrayOfValues) AsMaxSessionsPerAgentLocationPathArrayOfValues() (ProbingConstraintAdminHierachy_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ProbingConstraintAdminHierachy_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ProbingConstraintAdminHierachy_FieldPath interface {
	gotenobject.FieldPath
	Selector() ProbingConstraintAdminHierachy_FieldPathSelector
	Get(source *ProbingConstraint_AdminHierachy) []interface{}
	GetSingle(source *ProbingConstraint_AdminHierachy) (interface{}, bool)
	ClearValue(item *ProbingConstraint_AdminHierachy)

	// Those methods build corresponding ProbingConstraintAdminHierachy_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ProbingConstraintAdminHierachy_FieldPathValue
	WithIArrayOfValues(values interface{}) ProbingConstraintAdminHierachy_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ProbingConstraintAdminHierachy_FieldPathArrayItemValue
}

type ProbingConstraintAdminHierachy_FieldPathSelector int32

const (
	ProbingConstraintAdminHierachy_FieldPathSelectorCountry ProbingConstraintAdminHierachy_FieldPathSelector = 0
	ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1  ProbingConstraintAdminHierachy_FieldPathSelector = 1
	ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2  ProbingConstraintAdminHierachy_FieldPathSelector = 2
	ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3  ProbingConstraintAdminHierachy_FieldPathSelector = 3
	ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4  ProbingConstraintAdminHierachy_FieldPathSelector = 4
)

func (s ProbingConstraintAdminHierachy_FieldPathSelector) String() string {
	switch s {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		return "country"
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		return "admin1"
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		return "admin2"
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		return "admin3"
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		return "admin4"
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", s))
	}
}

func BuildProbingConstraintAdminHierachy_FieldPath(fp gotenobject.RawFieldPath) (ProbingConstraintAdminHierachy_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ProbingConstraint_AdminHierachy")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "country":
			return &ProbingConstraintAdminHierachy_FieldTerminalPath{selector: ProbingConstraintAdminHierachy_FieldPathSelectorCountry}, nil
		case "admin1", "admin_1", "admin-1":
			return &ProbingConstraintAdminHierachy_FieldTerminalPath{selector: ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1}, nil
		case "admin2", "admin_2", "admin-2":
			return &ProbingConstraintAdminHierachy_FieldTerminalPath{selector: ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2}, nil
		case "admin3", "admin_3", "admin-3":
			return &ProbingConstraintAdminHierachy_FieldTerminalPath{selector: ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3}, nil
		case "admin4", "admin_4", "admin-4":
			return &ProbingConstraintAdminHierachy_FieldTerminalPath{selector: ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ProbingConstraint_AdminHierachy", fp)
}

func ParseProbingConstraintAdminHierachy_FieldPath(rawField string) (ProbingConstraintAdminHierachy_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildProbingConstraintAdminHierachy_FieldPath(fp)
}

func MustParseProbingConstraintAdminHierachy_FieldPath(rawField string) ProbingConstraintAdminHierachy_FieldPath {
	fp, err := ParseProbingConstraintAdminHierachy_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ProbingConstraintAdminHierachy_FieldTerminalPath struct {
	selector ProbingConstraintAdminHierachy_FieldPathSelector
}

var _ ProbingConstraintAdminHierachy_FieldPath = (*ProbingConstraintAdminHierachy_FieldTerminalPath)(nil)

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) Selector() ProbingConstraintAdminHierachy_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ProbingConstraint_AdminHierachy
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) Get(source *ProbingConstraint_AdminHierachy) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
			values = append(values, source.Country)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
			values = append(values, source.Admin1)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
			values = append(values, source.Admin2)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
			values = append(values, source.Admin3)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
			values = append(values, source.Admin4)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
		}
	}
	return
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ProbingConstraint_AdminHierachy))
}

// GetSingle returns value pointed by specific field of from source ProbingConstraint_AdminHierachy
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) GetSingle(source *ProbingConstraint_AdminHierachy) (interface{}, bool) {
	switch fp.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		return source.GetCountry(), source != nil
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		return source.GetAdmin1(), source != nil
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		return source.GetAdmin2(), source != nil
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		return source.GetAdmin3(), source != nil
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		return source.GetAdmin4(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
	}
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ProbingConstraint_AdminHierachy))
}

// GetDefault returns a default value of the field type
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		return int32(0)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		return int32(0)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		return int32(0)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		return int32(0)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
	}
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) ClearValue(item *ProbingConstraint_AdminHierachy) {
	if item != nil {
		switch fp.selector {
		case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
			item.Country = int32(0)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
			item.Admin1 = int32(0)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
			item.Admin2 = int32(0)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
			item.Admin3 = int32(0)
		case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
			item.Admin4 = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
		}
	}
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ProbingConstraint_AdminHierachy))
}

// IsLeaf - whether field path is holds simple value
func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ProbingConstraintAdminHierachy_FieldPathSelectorCountry ||
		fp.selector == ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1 ||
		fp.selector == ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2 ||
		fp.selector == ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3 ||
		fp.selector == ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithIValue(value interface{}) ProbingConstraintAdminHierachy_FieldPathValue {
	switch fp.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathValue{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, value: value.(int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathValue{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, value: value.(int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathValue{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, value: value.(int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathValue{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, value: value.(int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathValue{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
	}
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithIArrayOfValues(values interface{}) ProbingConstraintAdminHierachy_FieldPathArrayOfValues {
	fpaov := &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp}
	switch fp.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, values: values.([]int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, values: values.([]int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, values: values.([]int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, values: values.([]int32)}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		return &ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues{ProbingConstraintAdminHierachy_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
	}
	return fpaov
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithIArrayItemValue(value interface{}) ProbingConstraintAdminHierachy_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fp.selector))
	}
}

func (fp *ProbingConstraintAdminHierachy_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ProbingConstraintAdminHierachy_FieldPathValue allows storing values for AdminHierachy fields according to their type
type ProbingConstraintAdminHierachy_FieldPathValue interface {
	ProbingConstraintAdminHierachy_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ProbingConstraint_AdminHierachy)
	CompareWith(*ProbingConstraint_AdminHierachy) (cmp int, comparable bool)
}

func ParseProbingConstraintAdminHierachy_FieldPathValue(pathStr, valueStr string) (ProbingConstraintAdminHierachy_FieldPathValue, error) {
	fp, err := ParseProbingConstraintAdminHierachy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing AdminHierachy field path value from %s: %v", valueStr, err)
	}
	return fpv.(ProbingConstraintAdminHierachy_FieldPathValue), nil
}

func MustParseProbingConstraintAdminHierachy_FieldPathValue(pathStr, valueStr string) ProbingConstraintAdminHierachy_FieldPathValue {
	fpv, err := ParseProbingConstraintAdminHierachy_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ProbingConstraintAdminHierachy_FieldTerminalPathValue struct {
	ProbingConstraintAdminHierachy_FieldTerminalPath
	value interface{}
}

var _ ProbingConstraintAdminHierachy_FieldPathValue = (*ProbingConstraintAdminHierachy_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'AdminHierachy' as interface{}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) AsCountryValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) AsAdmin1Value() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) AsAdmin2Value() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) AsAdmin3Value() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) AsAdmin4Value() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object AdminHierachy
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) SetTo(target **ProbingConstraint_AdminHierachy) {
	if *target == nil {
		*target = new(ProbingConstraint_AdminHierachy)
	}
	switch fpv.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		(*target).Country = fpv.value.(int32)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		(*target).Admin1 = fpv.value.(int32)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		(*target).Admin2 = fpv.value.(int32)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		(*target).Admin3 = fpv.value.(int32)
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		(*target).Admin4 = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fpv.selector))
	}
}

func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProbingConstraint_AdminHierachy)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ProbingConstraintAdminHierachy_FieldTerminalPathValue' with the value under path in 'ProbingConstraint_AdminHierachy'.
func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) CompareWith(source *ProbingConstraint_AdminHierachy) (int, bool) {
	switch fpv.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		leftValue := fpv.value.(int32)
		rightValue := source.GetCountry()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		leftValue := fpv.value.(int32)
		rightValue := source.GetAdmin1()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		leftValue := fpv.value.(int32)
		rightValue := source.GetAdmin2()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		leftValue := fpv.value.(int32)
		rightValue := source.GetAdmin3()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		leftValue := fpv.value.(int32)
		rightValue := source.GetAdmin4()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingConstraint_AdminHierachy: %d", fpv.selector))
	}
}

func (fpv *ProbingConstraintAdminHierachy_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ProbingConstraint_AdminHierachy))
}

// ProbingConstraintAdminHierachy_FieldPathArrayItemValue allows storing single item in Path-specific values for AdminHierachy according to their type
// Present only for array (repeated) types.
type ProbingConstraintAdminHierachy_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ProbingConstraintAdminHierachy_FieldPath
	ContainsValue(*ProbingConstraint_AdminHierachy) bool
}

// ParseProbingConstraintAdminHierachy_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseProbingConstraintAdminHierachy_FieldPathArrayItemValue(pathStr, valueStr string) (ProbingConstraintAdminHierachy_FieldPathArrayItemValue, error) {
	fp, err := ParseProbingConstraintAdminHierachy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing AdminHierachy field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ProbingConstraintAdminHierachy_FieldPathArrayItemValue), nil
}

func MustParseProbingConstraintAdminHierachy_FieldPathArrayItemValue(pathStr, valueStr string) ProbingConstraintAdminHierachy_FieldPathArrayItemValue {
	fpaiv, err := ParseProbingConstraintAdminHierachy_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue struct {
	ProbingConstraintAdminHierachy_FieldTerminalPath
	value interface{}
}

var _ ProbingConstraintAdminHierachy_FieldPathArrayItemValue = (*ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ProbingConstraint_AdminHierachy as interface{}
func (fpaiv *ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue) GetSingle(source *ProbingConstraint_AdminHierachy) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ProbingConstraint_AdminHierachy))
}

// Contains returns a boolean indicating if value that is being held is present in given 'AdminHierachy'
func (fpaiv *ProbingConstraintAdminHierachy_FieldTerminalPathArrayItemValue) ContainsValue(source *ProbingConstraint_AdminHierachy) bool {
	slice := fpaiv.ProbingConstraintAdminHierachy_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ProbingConstraintAdminHierachy_FieldPathArrayOfValues allows storing slice of values for AdminHierachy fields according to their type
type ProbingConstraintAdminHierachy_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ProbingConstraintAdminHierachy_FieldPath
}

func ParseProbingConstraintAdminHierachy_FieldPathArrayOfValues(pathStr, valuesStr string) (ProbingConstraintAdminHierachy_FieldPathArrayOfValues, error) {
	fp, err := ParseProbingConstraintAdminHierachy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing AdminHierachy field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ProbingConstraintAdminHierachy_FieldPathArrayOfValues), nil
}

func MustParseProbingConstraintAdminHierachy_FieldPathArrayOfValues(pathStr, valuesStr string) ProbingConstraintAdminHierachy_FieldPathArrayOfValues {
	fpaov, err := ParseProbingConstraintAdminHierachy_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues struct {
	ProbingConstraintAdminHierachy_FieldTerminalPath
	values interface{}
}

var _ ProbingConstraintAdminHierachy_FieldPathArrayOfValues = (*ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ProbingConstraintAdminHierachy_FieldPathSelectorCountry:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin1:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin2:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin3:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ProbingConstraintAdminHierachy_FieldPathSelectorAdmin4:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) AsCountryArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) AsAdmin1ArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) AsAdmin2ArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) AsAdmin3ArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ProbingConstraintAdminHierachy_FieldTerminalPathArrayOfValues) AsAdmin4ArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type PathProbe_FieldPath interface {
	gotenobject.FieldPath
	Selector() PathProbe_FieldPathSelector
	Get(source *PathProbe) []interface{}
	GetSingle(source *PathProbe) (interface{}, bool)
	ClearValue(item *PathProbe)

	// Those methods build corresponding PathProbe_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) PathProbe_FieldPathValue
	WithIArrayOfValues(values interface{}) PathProbe_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) PathProbe_FieldPathArrayItemValue
}

type PathProbe_FieldPathSelector int32

const (
	PathProbe_FieldPathSelectorEnabled     PathProbe_FieldPathSelector = 0
	PathProbe_FieldPathSelectorMode        PathProbe_FieldPathSelector = 1
	PathProbe_FieldPathSelectorInterval    PathProbe_FieldPathSelector = 2
	PathProbe_FieldPathSelectorIntervalSec PathProbe_FieldPathSelector = 3
	PathProbe_FieldPathSelectorAttempts    PathProbe_FieldPathSelector = 4
	PathProbe_FieldPathSelectorMaxTtl      PathProbe_FieldPathSelector = 5
)

func (s PathProbe_FieldPathSelector) String() string {
	switch s {
	case PathProbe_FieldPathSelectorEnabled:
		return "enabled"
	case PathProbe_FieldPathSelectorMode:
		return "mode"
	case PathProbe_FieldPathSelectorInterval:
		return "interval"
	case PathProbe_FieldPathSelectorIntervalSec:
		return "interval_sec"
	case PathProbe_FieldPathSelectorAttempts:
		return "attempts"
	case PathProbe_FieldPathSelectorMaxTtl:
		return "max_ttl"
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", s))
	}
}

func BuildPathProbe_FieldPath(fp gotenobject.RawFieldPath) (PathProbe_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object PathProbe")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "enabled":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorEnabled}, nil
		case "mode":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorMode}, nil
		case "interval":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorInterval}, nil
		case "interval_sec", "intervalSec", "interval-sec":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorIntervalSec}, nil
		case "attempts":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorAttempts}, nil
		case "max_ttl", "maxTtl", "max-ttl":
			return &PathProbe_FieldTerminalPath{selector: PathProbe_FieldPathSelectorMaxTtl}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object PathProbe", fp)
}

func ParsePathProbe_FieldPath(rawField string) (PathProbe_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPathProbe_FieldPath(fp)
}

func MustParsePathProbe_FieldPath(rawField string) PathProbe_FieldPath {
	fp, err := ParsePathProbe_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type PathProbe_FieldTerminalPath struct {
	selector PathProbe_FieldPathSelector
}

var _ PathProbe_FieldPath = (*PathProbe_FieldTerminalPath)(nil)

func (fp *PathProbe_FieldTerminalPath) Selector() PathProbe_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *PathProbe_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *PathProbe_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source PathProbe
func (fp *PathProbe_FieldTerminalPath) Get(source *PathProbe) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case PathProbe_FieldPathSelectorEnabled:
			values = append(values, source.Enabled)
		case PathProbe_FieldPathSelectorMode:
			values = append(values, source.Mode)
		case PathProbe_FieldPathSelectorInterval:
			if source.Interval != nil {
				values = append(values, source.Interval)
			}
		case PathProbe_FieldPathSelectorIntervalSec:
			values = append(values, source.IntervalSec)
		case PathProbe_FieldPathSelectorAttempts:
			if source.Attempts != nil {
				values = append(values, source.Attempts)
			}
		case PathProbe_FieldPathSelectorMaxTtl:
			if source.MaxTtl != nil {
				values = append(values, source.MaxTtl)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
		}
	}
	return
}

func (fp *PathProbe_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*PathProbe))
}

// GetSingle returns value pointed by specific field of from source PathProbe
func (fp *PathProbe_FieldTerminalPath) GetSingle(source *PathProbe) (interface{}, bool) {
	switch fp.selector {
	case PathProbe_FieldPathSelectorEnabled:
		return source.GetEnabled(), source != nil
	case PathProbe_FieldPathSelectorMode:
		return source.GetMode(), source != nil
	case PathProbe_FieldPathSelectorInterval:
		res := source.GetInterval()
		return res, res != nil
	case PathProbe_FieldPathSelectorIntervalSec:
		return source.GetIntervalSec(), source != nil
	case PathProbe_FieldPathSelectorAttempts:
		res := source.GetAttempts()
		return res, res != nil
	case PathProbe_FieldPathSelectorMaxTtl:
		res := source.GetMaxTtl()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
	}
}

func (fp *PathProbe_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*PathProbe))
}

// GetDefault returns a default value of the field type
func (fp *PathProbe_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case PathProbe_FieldPathSelectorEnabled:
		return false
	case PathProbe_FieldPathSelectorMode:
		return ProbingMode_PROBING_MODE_UNSPECIFIED
	case PathProbe_FieldPathSelectorInterval:
		return (*duration.Duration)(nil)
	case PathProbe_FieldPathSelectorIntervalSec:
		return int64(0)
	case PathProbe_FieldPathSelectorAttempts:
		return (*wrappers.UInt32Value)(nil)
	case PathProbe_FieldPathSelectorMaxTtl:
		return (*wrappers.UInt32Value)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
	}
}

func (fp *PathProbe_FieldTerminalPath) ClearValue(item *PathProbe) {
	if item != nil {
		switch fp.selector {
		case PathProbe_FieldPathSelectorEnabled:
			item.Enabled = false
		case PathProbe_FieldPathSelectorMode:
			item.Mode = ProbingMode_PROBING_MODE_UNSPECIFIED
		case PathProbe_FieldPathSelectorInterval:
			item.Interval = nil
		case PathProbe_FieldPathSelectorIntervalSec:
			item.IntervalSec = int64(0)
		case PathProbe_FieldPathSelectorAttempts:
			item.Attempts = nil
		case PathProbe_FieldPathSelectorMaxTtl:
			item.MaxTtl = nil
		default:
			panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
		}
	}
}

func (fp *PathProbe_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*PathProbe))
}

// IsLeaf - whether field path is holds simple value
func (fp *PathProbe_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == PathProbe_FieldPathSelectorEnabled ||
		fp.selector == PathProbe_FieldPathSelectorMode ||
		fp.selector == PathProbe_FieldPathSelectorInterval ||
		fp.selector == PathProbe_FieldPathSelectorIntervalSec ||
		fp.selector == PathProbe_FieldPathSelectorAttempts ||
		fp.selector == PathProbe_FieldPathSelectorMaxTtl
}

func (fp *PathProbe_FieldTerminalPath) WithIValue(value interface{}) PathProbe_FieldPathValue {
	switch fp.selector {
	case PathProbe_FieldPathSelectorEnabled:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(bool)}
	case PathProbe_FieldPathSelectorMode:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(ProbingMode)}
	case PathProbe_FieldPathSelectorInterval:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(*duration.Duration)}
	case PathProbe_FieldPathSelectorIntervalSec:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(int64)}
	case PathProbe_FieldPathSelectorAttempts:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(*wrappers.UInt32Value)}
	case PathProbe_FieldPathSelectorMaxTtl:
		return &PathProbe_FieldTerminalPathValue{PathProbe_FieldTerminalPath: *fp, value: value.(*wrappers.UInt32Value)}
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
	}
}

func (fp *PathProbe_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *PathProbe_FieldTerminalPath) WithIArrayOfValues(values interface{}) PathProbe_FieldPathArrayOfValues {
	fpaov := &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp}
	switch fp.selector {
	case PathProbe_FieldPathSelectorEnabled:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]bool)}
	case PathProbe_FieldPathSelectorMode:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]ProbingMode)}
	case PathProbe_FieldPathSelectorInterval:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]*duration.Duration)}
	case PathProbe_FieldPathSelectorIntervalSec:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]int64)}
	case PathProbe_FieldPathSelectorAttempts:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]*wrappers.UInt32Value)}
	case PathProbe_FieldPathSelectorMaxTtl:
		return &PathProbe_FieldTerminalPathArrayOfValues{PathProbe_FieldTerminalPath: *fp, values: values.([]*wrappers.UInt32Value)}
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
	}
	return fpaov
}

func (fp *PathProbe_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *PathProbe_FieldTerminalPath) WithIArrayItemValue(value interface{}) PathProbe_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fp.selector))
	}
}

func (fp *PathProbe_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// PathProbe_FieldPathValue allows storing values for PathProbe fields according to their type
type PathProbe_FieldPathValue interface {
	PathProbe_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **PathProbe)
	CompareWith(*PathProbe) (cmp int, comparable bool)
}

func ParsePathProbe_FieldPathValue(pathStr, valueStr string) (PathProbe_FieldPathValue, error) {
	fp, err := ParsePathProbe_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PathProbe field path value from %s: %v", valueStr, err)
	}
	return fpv.(PathProbe_FieldPathValue), nil
}

func MustParsePathProbe_FieldPathValue(pathStr, valueStr string) PathProbe_FieldPathValue {
	fpv, err := ParsePathProbe_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type PathProbe_FieldTerminalPathValue struct {
	PathProbe_FieldTerminalPath
	value interface{}
}

var _ PathProbe_FieldPathValue = (*PathProbe_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PathProbe' as interface{}
func (fpv *PathProbe_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *PathProbe_FieldTerminalPathValue) AsEnabledValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *PathProbe_FieldTerminalPathValue) AsModeValue() (ProbingMode, bool) {
	res, ok := fpv.value.(ProbingMode)
	return res, ok
}
func (fpv *PathProbe_FieldTerminalPathValue) AsIntervalValue() (*duration.Duration, bool) {
	res, ok := fpv.value.(*duration.Duration)
	return res, ok
}
func (fpv *PathProbe_FieldTerminalPathValue) AsIntervalSecValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *PathProbe_FieldTerminalPathValue) AsAttemptsValue() (*wrappers.UInt32Value, bool) {
	res, ok := fpv.value.(*wrappers.UInt32Value)
	return res, ok
}
func (fpv *PathProbe_FieldTerminalPathValue) AsMaxTtlValue() (*wrappers.UInt32Value, bool) {
	res, ok := fpv.value.(*wrappers.UInt32Value)
	return res, ok
}

// SetTo stores value for selected field for object PathProbe
func (fpv *PathProbe_FieldTerminalPathValue) SetTo(target **PathProbe) {
	if *target == nil {
		*target = new(PathProbe)
	}
	switch fpv.selector {
	case PathProbe_FieldPathSelectorEnabled:
		(*target).Enabled = fpv.value.(bool)
	case PathProbe_FieldPathSelectorMode:
		(*target).Mode = fpv.value.(ProbingMode)
	case PathProbe_FieldPathSelectorInterval:
		(*target).Interval = fpv.value.(*duration.Duration)
	case PathProbe_FieldPathSelectorIntervalSec:
		(*target).IntervalSec = fpv.value.(int64)
	case PathProbe_FieldPathSelectorAttempts:
		(*target).Attempts = fpv.value.(*wrappers.UInt32Value)
	case PathProbe_FieldPathSelectorMaxTtl:
		(*target).MaxTtl = fpv.value.(*wrappers.UInt32Value)
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fpv.selector))
	}
}

func (fpv *PathProbe_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PathProbe)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PathProbe_FieldTerminalPathValue' with the value under path in 'PathProbe'.
func (fpv *PathProbe_FieldTerminalPathValue) CompareWith(source *PathProbe) (int, bool) {
	switch fpv.selector {
	case PathProbe_FieldPathSelectorEnabled:
		leftValue := fpv.value.(bool)
		rightValue := source.GetEnabled()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PathProbe_FieldPathSelectorMode:
		leftValue := fpv.value.(ProbingMode)
		rightValue := source.GetMode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PathProbe_FieldPathSelectorInterval:
		leftValue := fpv.value.(*duration.Duration)
		rightValue := source.GetInterval()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case PathProbe_FieldPathSelectorIntervalSec:
		leftValue := fpv.value.(int64)
		rightValue := source.GetIntervalSec()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PathProbe_FieldPathSelectorAttempts:
		return 0, false
	case PathProbe_FieldPathSelectorMaxTtl:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for PathProbe: %d", fpv.selector))
	}
}

func (fpv *PathProbe_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*PathProbe))
}

// PathProbe_FieldPathArrayItemValue allows storing single item in Path-specific values for PathProbe according to their type
// Present only for array (repeated) types.
type PathProbe_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	PathProbe_FieldPath
	ContainsValue(*PathProbe) bool
}

// ParsePathProbe_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePathProbe_FieldPathArrayItemValue(pathStr, valueStr string) (PathProbe_FieldPathArrayItemValue, error) {
	fp, err := ParsePathProbe_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PathProbe field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(PathProbe_FieldPathArrayItemValue), nil
}

func MustParsePathProbe_FieldPathArrayItemValue(pathStr, valueStr string) PathProbe_FieldPathArrayItemValue {
	fpaiv, err := ParsePathProbe_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type PathProbe_FieldTerminalPathArrayItemValue struct {
	PathProbe_FieldTerminalPath
	value interface{}
}

var _ PathProbe_FieldPathArrayItemValue = (*PathProbe_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object PathProbe as interface{}
func (fpaiv *PathProbe_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *PathProbe_FieldTerminalPathArrayItemValue) GetSingle(source *PathProbe) (interface{}, bool) {
	return nil, false
}

func (fpaiv *PathProbe_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*PathProbe))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PathProbe'
func (fpaiv *PathProbe_FieldTerminalPathArrayItemValue) ContainsValue(source *PathProbe) bool {
	slice := fpaiv.PathProbe_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// PathProbe_FieldPathArrayOfValues allows storing slice of values for PathProbe fields according to their type
type PathProbe_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	PathProbe_FieldPath
}

func ParsePathProbe_FieldPathArrayOfValues(pathStr, valuesStr string) (PathProbe_FieldPathArrayOfValues, error) {
	fp, err := ParsePathProbe_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PathProbe field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(PathProbe_FieldPathArrayOfValues), nil
}

func MustParsePathProbe_FieldPathArrayOfValues(pathStr, valuesStr string) PathProbe_FieldPathArrayOfValues {
	fpaov, err := ParsePathProbe_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type PathProbe_FieldTerminalPathArrayOfValues struct {
	PathProbe_FieldTerminalPath
	values interface{}
}

var _ PathProbe_FieldPathArrayOfValues = (*PathProbe_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case PathProbe_FieldPathSelectorEnabled:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case PathProbe_FieldPathSelectorMode:
		for _, v := range fpaov.values.([]ProbingMode) {
			values = append(values, v)
		}
	case PathProbe_FieldPathSelectorInterval:
		for _, v := range fpaov.values.([]*duration.Duration) {
			values = append(values, v)
		}
	case PathProbe_FieldPathSelectorIntervalSec:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case PathProbe_FieldPathSelectorAttempts:
		for _, v := range fpaov.values.([]*wrappers.UInt32Value) {
			values = append(values, v)
		}
	case PathProbe_FieldPathSelectorMaxTtl:
		for _, v := range fpaov.values.([]*wrappers.UInt32Value) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsEnabledArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsModeArrayOfValues() ([]ProbingMode, bool) {
	res, ok := fpaov.values.([]ProbingMode)
	return res, ok
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsIntervalArrayOfValues() ([]*duration.Duration, bool) {
	res, ok := fpaov.values.([]*duration.Duration)
	return res, ok
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsIntervalSecArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsAttemptsArrayOfValues() ([]*wrappers.UInt32Value, bool) {
	res, ok := fpaov.values.([]*wrappers.UInt32Value)
	return res, ok
}
func (fpaov *PathProbe_FieldTerminalPathArrayOfValues) AsMaxTtlArrayOfValues() ([]*wrappers.UInt32Value, bool) {
	res, ok := fpaov.values.([]*wrappers.UInt32Value)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ProbingSettings_FieldPath interface {
	gotenobject.FieldPath
	Selector() ProbingSettings_FieldPathSelector
	Get(source *ProbingSettings) []interface{}
	GetSingle(source *ProbingSettings) (interface{}, bool)
	ClearValue(item *ProbingSettings)

	// Those methods build corresponding ProbingSettings_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ProbingSettings_FieldPathValue
	WithIArrayOfValues(values interface{}) ProbingSettings_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ProbingSettings_FieldPathArrayItemValue
}

type ProbingSettings_FieldPathSelector int32

const (
	ProbingSettings_FieldPathSelectorInterval           ProbingSettings_FieldPathSelector = 0
	ProbingSettings_FieldPathSelectorTos                ProbingSettings_FieldPathSelector = 1
	ProbingSettings_FieldPathSelectorWindowSize         ProbingSettings_FieldPathSelector = 2
	ProbingSettings_FieldPathSelectorPathProbing        ProbingSettings_FieldPathSelector = 3
	ProbingSettings_FieldPathSelectorSpeedtestSettings  ProbingSettings_FieldPathSelector = 4
	ProbingSettings_FieldPathSelectorHttpProbingConfig  ProbingSettings_FieldPathSelector = 5
	ProbingSettings_FieldPathSelectorProxyConfiguration ProbingSettings_FieldPathSelector = 6
)

func (s ProbingSettings_FieldPathSelector) String() string {
	switch s {
	case ProbingSettings_FieldPathSelectorInterval:
		return "interval"
	case ProbingSettings_FieldPathSelectorTos:
		return "tos"
	case ProbingSettings_FieldPathSelectorWindowSize:
		return "window_size"
	case ProbingSettings_FieldPathSelectorPathProbing:
		return "path_probing"
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return "speedtest_settings"
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return "http_probing_config"
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return "proxy_configuration"
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", s))
	}
}

func BuildProbingSettings_FieldPath(fp gotenobject.RawFieldPath) (ProbingSettings_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ProbingSettings")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "interval":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorInterval}, nil
		case "tos":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorTos}, nil
		case "window_size", "windowSize", "window-size":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorWindowSize}, nil
		case "path_probing", "pathProbing", "path-probing":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorPathProbing}, nil
		case "speedtest_settings", "speedtestSettings", "speedtest-settings":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorSpeedtestSettings}, nil
		case "http_probing_config", "httpProbingConfig", "http-probing-config":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorHttpProbingConfig}, nil
		case "proxy_configuration", "proxyConfiguration", "proxy-configuration":
			return &ProbingSettings_FieldTerminalPath{selector: ProbingSettings_FieldPathSelectorProxyConfiguration}, nil
		}
	} else {
		switch fp[0] {
		case "path_probing", "pathProbing", "path-probing":
			if subpath, err := BuildPathProbe_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ProbingSettings_FieldSubPath{selector: ProbingSettings_FieldPathSelectorPathProbing, subPath: subpath}, nil
			}
		case "speedtest_settings", "speedtestSettings", "speedtest-settings":
			if subpath, err := BuildSpeedTestSettings_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ProbingSettings_FieldSubPath{selector: ProbingSettings_FieldPathSelectorSpeedtestSettings, subPath: subpath}, nil
			}
		case "http_probing_config", "httpProbingConfig", "http-probing-config":
			if subpath, err := BuildHTTPProbingConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ProbingSettings_FieldSubPath{selector: ProbingSettings_FieldPathSelectorHttpProbingConfig, subPath: subpath}, nil
			}
		case "proxy_configuration", "proxyConfiguration", "proxy-configuration":
			if subpath, err := BuildProxyConfiguration_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ProbingSettings_FieldSubPath{selector: ProbingSettings_FieldPathSelectorProxyConfiguration, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ProbingSettings", fp)
}

func ParseProbingSettings_FieldPath(rawField string) (ProbingSettings_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildProbingSettings_FieldPath(fp)
}

func MustParseProbingSettings_FieldPath(rawField string) ProbingSettings_FieldPath {
	fp, err := ParseProbingSettings_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ProbingSettings_FieldTerminalPath struct {
	selector ProbingSettings_FieldPathSelector
}

var _ ProbingSettings_FieldPath = (*ProbingSettings_FieldTerminalPath)(nil)

func (fp *ProbingSettings_FieldTerminalPath) Selector() ProbingSettings_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ProbingSettings_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ProbingSettings_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ProbingSettings
func (fp *ProbingSettings_FieldTerminalPath) Get(source *ProbingSettings) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ProbingSettings_FieldPathSelectorInterval:
			if source.Interval != nil {
				values = append(values, source.Interval)
			}
		case ProbingSettings_FieldPathSelectorTos:
			if source.Tos != nil {
				values = append(values, source.Tos)
			}
		case ProbingSettings_FieldPathSelectorWindowSize:
			if source.WindowSize != nil {
				values = append(values, source.WindowSize)
			}
		case ProbingSettings_FieldPathSelectorPathProbing:
			if source.PathProbing != nil {
				values = append(values, source.PathProbing)
			}
		case ProbingSettings_FieldPathSelectorSpeedtestSettings:
			if source.SpeedtestSettings != nil {
				values = append(values, source.SpeedtestSettings)
			}
		case ProbingSettings_FieldPathSelectorHttpProbingConfig:
			if source.HttpProbingConfig != nil {
				values = append(values, source.HttpProbingConfig)
			}
		case ProbingSettings_FieldPathSelectorProxyConfiguration:
			if source.ProxyConfiguration != nil {
				values = append(values, source.ProxyConfiguration)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
		}
	}
	return
}

func (fp *ProbingSettings_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ProbingSettings))
}

// GetSingle returns value pointed by specific field of from source ProbingSettings
func (fp *ProbingSettings_FieldTerminalPath) GetSingle(source *ProbingSettings) (interface{}, bool) {
	switch fp.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		res := source.GetInterval()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorTos:
		res := source.GetTos()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorWindowSize:
		res := source.GetWindowSize()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorPathProbing:
		res := source.GetPathProbing()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		res := source.GetSpeedtestSettings()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		res := source.GetHttpProbingConfig()
		return res, res != nil
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		res := source.GetProxyConfiguration()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
	}
}

func (fp *ProbingSettings_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ProbingSettings))
}

// GetDefault returns a default value of the field type
func (fp *ProbingSettings_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		return (*duration.Duration)(nil)
	case ProbingSettings_FieldPathSelectorTos:
		return (*wrappers.UInt32Value)(nil)
	case ProbingSettings_FieldPathSelectorWindowSize:
		return (*wrappers.UInt32Value)(nil)
	case ProbingSettings_FieldPathSelectorPathProbing:
		return (*PathProbe)(nil)
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return (*SpeedTestSettings)(nil)
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return (*HTTPProbingConfig)(nil)
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return (*ProxyConfiguration)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
	}
}

func (fp *ProbingSettings_FieldTerminalPath) ClearValue(item *ProbingSettings) {
	if item != nil {
		switch fp.selector {
		case ProbingSettings_FieldPathSelectorInterval:
			item.Interval = nil
		case ProbingSettings_FieldPathSelectorTos:
			item.Tos = nil
		case ProbingSettings_FieldPathSelectorWindowSize:
			item.WindowSize = nil
		case ProbingSettings_FieldPathSelectorPathProbing:
			item.PathProbing = nil
		case ProbingSettings_FieldPathSelectorSpeedtestSettings:
			item.SpeedtestSettings = nil
		case ProbingSettings_FieldPathSelectorHttpProbingConfig:
			item.HttpProbingConfig = nil
		case ProbingSettings_FieldPathSelectorProxyConfiguration:
			item.ProxyConfiguration = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
		}
	}
}

func (fp *ProbingSettings_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ProbingSettings))
}

// IsLeaf - whether field path is holds simple value
func (fp *ProbingSettings_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ProbingSettings_FieldPathSelectorInterval ||
		fp.selector == ProbingSettings_FieldPathSelectorTos ||
		fp.selector == ProbingSettings_FieldPathSelectorWindowSize
}

func (fp *ProbingSettings_FieldTerminalPath) WithIValue(value interface{}) ProbingSettings_FieldPathValue {
	switch fp.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*duration.Duration)}
	case ProbingSettings_FieldPathSelectorTos:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*wrappers.UInt32Value)}
	case ProbingSettings_FieldPathSelectorWindowSize:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*wrappers.UInt32Value)}
	case ProbingSettings_FieldPathSelectorPathProbing:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*PathProbe)}
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*SpeedTestSettings)}
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*HTTPProbingConfig)}
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return &ProbingSettings_FieldTerminalPathValue{ProbingSettings_FieldTerminalPath: *fp, value: value.(*ProxyConfiguration)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
	}
}

func (fp *ProbingSettings_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ProbingSettings_FieldTerminalPath) WithIArrayOfValues(values interface{}) ProbingSettings_FieldPathArrayOfValues {
	fpaov := &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp}
	switch fp.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*duration.Duration)}
	case ProbingSettings_FieldPathSelectorTos:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*wrappers.UInt32Value)}
	case ProbingSettings_FieldPathSelectorWindowSize:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*wrappers.UInt32Value)}
	case ProbingSettings_FieldPathSelectorPathProbing:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*PathProbe)}
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*SpeedTestSettings)}
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*HTTPProbingConfig)}
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return &ProbingSettings_FieldTerminalPathArrayOfValues{ProbingSettings_FieldTerminalPath: *fp, values: values.([]*ProxyConfiguration)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
	}
	return fpaov
}

func (fp *ProbingSettings_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ProbingSettings_FieldTerminalPath) WithIArrayItemValue(value interface{}) ProbingSettings_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fp.selector))
	}
}

func (fp *ProbingSettings_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ProbingSettings_FieldSubPath struct {
	selector ProbingSettings_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ProbingSettings_FieldPath = (*ProbingSettings_FieldSubPath)(nil)

func (fps *ProbingSettings_FieldSubPath) Selector() ProbingSettings_FieldPathSelector {
	return fps.selector
}
func (fps *ProbingSettings_FieldSubPath) AsPathProbingSubPath() (PathProbe_FieldPath, bool) {
	res, ok := fps.subPath.(PathProbe_FieldPath)
	return res, ok
}
func (fps *ProbingSettings_FieldSubPath) AsSpeedtestSettingsSubPath() (SpeedTestSettings_FieldPath, bool) {
	res, ok := fps.subPath.(SpeedTestSettings_FieldPath)
	return res, ok
}
func (fps *ProbingSettings_FieldSubPath) AsHttpProbingConfigSubPath() (HTTPProbingConfig_FieldPath, bool) {
	res, ok := fps.subPath.(HTTPProbingConfig_FieldPath)
	return res, ok
}
func (fps *ProbingSettings_FieldSubPath) AsProxyConfigurationSubPath() (ProxyConfiguration_FieldPath, bool) {
	res, ok := fps.subPath.(ProxyConfiguration_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ProbingSettings_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ProbingSettings_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ProbingSettings
func (fps *ProbingSettings_FieldSubPath) Get(source *ProbingSettings) (values []interface{}) {
	if asPathProbeFieldPath, ok := fps.AsPathProbingSubPath(); ok {
		values = append(values, asPathProbeFieldPath.Get(source.GetPathProbing())...)
	} else if asSpeedTestSettingsFieldPath, ok := fps.AsSpeedtestSettingsSubPath(); ok {
		values = append(values, asSpeedTestSettingsFieldPath.Get(source.GetSpeedtestSettings())...)
	} else if asHTTPProbingConfigFieldPath, ok := fps.AsHttpProbingConfigSubPath(); ok {
		values = append(values, asHTTPProbingConfigFieldPath.Get(source.GetHttpProbingConfig())...)
	} else if asProxyConfigurationFieldPath, ok := fps.AsProxyConfigurationSubPath(); ok {
		values = append(values, asProxyConfigurationFieldPath.Get(source.GetProxyConfiguration())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fps.selector))
	}
	return
}

func (fps *ProbingSettings_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ProbingSettings))
}

// GetSingle returns value of selected field from source ProbingSettings
func (fps *ProbingSettings_FieldSubPath) GetSingle(source *ProbingSettings) (interface{}, bool) {
	switch fps.selector {
	case ProbingSettings_FieldPathSelectorPathProbing:
		if source.GetPathProbing() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPathProbing())
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		if source.GetSpeedtestSettings() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSpeedtestSettings())
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		if source.GetHttpProbingConfig() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetHttpProbingConfig())
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		if source.GetProxyConfiguration() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetProxyConfiguration())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fps.selector))
	}
}

func (fps *ProbingSettings_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ProbingSettings))
}

// GetDefault returns a default value of the field type
func (fps *ProbingSettings_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ProbingSettings_FieldSubPath) ClearValue(item *ProbingSettings) {
	if item != nil {
		switch fps.selector {
		case ProbingSettings_FieldPathSelectorPathProbing:
			fps.subPath.ClearValueRaw(item.PathProbing)
		case ProbingSettings_FieldPathSelectorSpeedtestSettings:
			fps.subPath.ClearValueRaw(item.SpeedtestSettings)
		case ProbingSettings_FieldPathSelectorHttpProbingConfig:
			fps.subPath.ClearValueRaw(item.HttpProbingConfig)
		case ProbingSettings_FieldPathSelectorProxyConfiguration:
			fps.subPath.ClearValueRaw(item.ProxyConfiguration)
		default:
			panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fps.selector))
		}
	}
}

func (fps *ProbingSettings_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ProbingSettings))
}

// IsLeaf - whether field path is holds simple value
func (fps *ProbingSettings_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ProbingSettings_FieldSubPath) WithIValue(value interface{}) ProbingSettings_FieldPathValue {
	return &ProbingSettings_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ProbingSettings_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ProbingSettings_FieldSubPath) WithIArrayOfValues(values interface{}) ProbingSettings_FieldPathArrayOfValues {
	return &ProbingSettings_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ProbingSettings_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ProbingSettings_FieldSubPath) WithIArrayItemValue(value interface{}) ProbingSettings_FieldPathArrayItemValue {
	return &ProbingSettings_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ProbingSettings_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ProbingSettings_FieldPathValue allows storing values for ProbingSettings fields according to their type
type ProbingSettings_FieldPathValue interface {
	ProbingSettings_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ProbingSettings)
	CompareWith(*ProbingSettings) (cmp int, comparable bool)
}

func ParseProbingSettings_FieldPathValue(pathStr, valueStr string) (ProbingSettings_FieldPathValue, error) {
	fp, err := ParseProbingSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingSettings field path value from %s: %v", valueStr, err)
	}
	return fpv.(ProbingSettings_FieldPathValue), nil
}

func MustParseProbingSettings_FieldPathValue(pathStr, valueStr string) ProbingSettings_FieldPathValue {
	fpv, err := ParseProbingSettings_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ProbingSettings_FieldTerminalPathValue struct {
	ProbingSettings_FieldTerminalPath
	value interface{}
}

var _ ProbingSettings_FieldPathValue = (*ProbingSettings_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ProbingSettings' as interface{}
func (fpv *ProbingSettings_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsIntervalValue() (*duration.Duration, bool) {
	res, ok := fpv.value.(*duration.Duration)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsTosValue() (*wrappers.UInt32Value, bool) {
	res, ok := fpv.value.(*wrappers.UInt32Value)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsWindowSizeValue() (*wrappers.UInt32Value, bool) {
	res, ok := fpv.value.(*wrappers.UInt32Value)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsPathProbingValue() (*PathProbe, bool) {
	res, ok := fpv.value.(*PathProbe)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsSpeedtestSettingsValue() (*SpeedTestSettings, bool) {
	res, ok := fpv.value.(*SpeedTestSettings)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsHttpProbingConfigValue() (*HTTPProbingConfig, bool) {
	res, ok := fpv.value.(*HTTPProbingConfig)
	return res, ok
}
func (fpv *ProbingSettings_FieldTerminalPathValue) AsProxyConfigurationValue() (*ProxyConfiguration, bool) {
	res, ok := fpv.value.(*ProxyConfiguration)
	return res, ok
}

// SetTo stores value for selected field for object ProbingSettings
func (fpv *ProbingSettings_FieldTerminalPathValue) SetTo(target **ProbingSettings) {
	if *target == nil {
		*target = new(ProbingSettings)
	}
	switch fpv.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		(*target).Interval = fpv.value.(*duration.Duration)
	case ProbingSettings_FieldPathSelectorTos:
		(*target).Tos = fpv.value.(*wrappers.UInt32Value)
	case ProbingSettings_FieldPathSelectorWindowSize:
		(*target).WindowSize = fpv.value.(*wrappers.UInt32Value)
	case ProbingSettings_FieldPathSelectorPathProbing:
		(*target).PathProbing = fpv.value.(*PathProbe)
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		(*target).SpeedtestSettings = fpv.value.(*SpeedTestSettings)
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		(*target).HttpProbingConfig = fpv.value.(*HTTPProbingConfig)
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		(*target).ProxyConfiguration = fpv.value.(*ProxyConfiguration)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fpv.selector))
	}
}

func (fpv *ProbingSettings_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProbingSettings)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ProbingSettings_FieldTerminalPathValue' with the value under path in 'ProbingSettings'.
func (fpv *ProbingSettings_FieldTerminalPathValue) CompareWith(source *ProbingSettings) (int, bool) {
	switch fpv.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		leftValue := fpv.value.(*duration.Duration)
		rightValue := source.GetInterval()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case ProbingSettings_FieldPathSelectorTos:
		return 0, false
	case ProbingSettings_FieldPathSelectorWindowSize:
		return 0, false
	case ProbingSettings_FieldPathSelectorPathProbing:
		return 0, false
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return 0, false
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return 0, false
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fpv.selector))
	}
}

func (fpv *ProbingSettings_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ProbingSettings))
}

type ProbingSettings_FieldSubPathValue struct {
	ProbingSettings_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ProbingSettings_FieldPathValue = (*ProbingSettings_FieldSubPathValue)(nil)

func (fpvs *ProbingSettings_FieldSubPathValue) AsPathProbingPathValue() (PathProbe_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(PathProbe_FieldPathValue)
	return res, ok
}
func (fpvs *ProbingSettings_FieldSubPathValue) AsSpeedtestSettingsPathValue() (SpeedTestSettings_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SpeedTestSettings_FieldPathValue)
	return res, ok
}
func (fpvs *ProbingSettings_FieldSubPathValue) AsHttpProbingConfigPathValue() (HTTPProbingConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(HTTPProbingConfig_FieldPathValue)
	return res, ok
}
func (fpvs *ProbingSettings_FieldSubPathValue) AsProxyConfigurationPathValue() (ProxyConfiguration_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ProxyConfiguration_FieldPathValue)
	return res, ok
}

func (fpvs *ProbingSettings_FieldSubPathValue) SetTo(target **ProbingSettings) {
	if *target == nil {
		*target = new(ProbingSettings)
	}
	switch fpvs.Selector() {
	case ProbingSettings_FieldPathSelectorPathProbing:
		fpvs.subPathValue.(PathProbe_FieldPathValue).SetTo(&(*target).PathProbing)
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		fpvs.subPathValue.(SpeedTestSettings_FieldPathValue).SetTo(&(*target).SpeedtestSettings)
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		fpvs.subPathValue.(HTTPProbingConfig_FieldPathValue).SetTo(&(*target).HttpProbingConfig)
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		fpvs.subPathValue.(ProxyConfiguration_FieldPathValue).SetTo(&(*target).ProxyConfiguration)
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fpvs.Selector()))
	}
}

func (fpvs *ProbingSettings_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProbingSettings)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ProbingSettings_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ProbingSettings_FieldSubPathValue) CompareWith(source *ProbingSettings) (int, bool) {
	switch fpvs.Selector() {
	case ProbingSettings_FieldPathSelectorPathProbing:
		return fpvs.subPathValue.(PathProbe_FieldPathValue).CompareWith(source.GetPathProbing())
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return fpvs.subPathValue.(SpeedTestSettings_FieldPathValue).CompareWith(source.GetSpeedtestSettings())
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return fpvs.subPathValue.(HTTPProbingConfig_FieldPathValue).CompareWith(source.GetHttpProbingConfig())
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return fpvs.subPathValue.(ProxyConfiguration_FieldPathValue).CompareWith(source.GetProxyConfiguration())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fpvs.Selector()))
	}
}

func (fpvs *ProbingSettings_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ProbingSettings))
}

// ProbingSettings_FieldPathArrayItemValue allows storing single item in Path-specific values for ProbingSettings according to their type
// Present only for array (repeated) types.
type ProbingSettings_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ProbingSettings_FieldPath
	ContainsValue(*ProbingSettings) bool
}

// ParseProbingSettings_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseProbingSettings_FieldPathArrayItemValue(pathStr, valueStr string) (ProbingSettings_FieldPathArrayItemValue, error) {
	fp, err := ParseProbingSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingSettings field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ProbingSettings_FieldPathArrayItemValue), nil
}

func MustParseProbingSettings_FieldPathArrayItemValue(pathStr, valueStr string) ProbingSettings_FieldPathArrayItemValue {
	fpaiv, err := ParseProbingSettings_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ProbingSettings_FieldTerminalPathArrayItemValue struct {
	ProbingSettings_FieldTerminalPath
	value interface{}
}

var _ ProbingSettings_FieldPathArrayItemValue = (*ProbingSettings_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ProbingSettings as interface{}
func (fpaiv *ProbingSettings_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ProbingSettings_FieldTerminalPathArrayItemValue) GetSingle(source *ProbingSettings) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ProbingSettings_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ProbingSettings))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ProbingSettings'
func (fpaiv *ProbingSettings_FieldTerminalPathArrayItemValue) ContainsValue(source *ProbingSettings) bool {
	slice := fpaiv.ProbingSettings_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ProbingSettings_FieldSubPathArrayItemValue struct {
	ProbingSettings_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) AsPathProbingPathItemValue() (PathProbe_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(PathProbe_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) AsSpeedtestSettingsPathItemValue() (SpeedTestSettings_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SpeedTestSettings_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) AsHttpProbingConfigPathItemValue() (HTTPProbingConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(HTTPProbingConfig_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) AsProxyConfigurationPathItemValue() (ProxyConfiguration_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ProxyConfiguration_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ProbingSettings'
func (fpaivs *ProbingSettings_FieldSubPathArrayItemValue) ContainsValue(source *ProbingSettings) bool {
	switch fpaivs.Selector() {
	case ProbingSettings_FieldPathSelectorPathProbing:
		return fpaivs.subPathItemValue.(PathProbe_FieldPathArrayItemValue).ContainsValue(source.GetPathProbing())
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		return fpaivs.subPathItemValue.(SpeedTestSettings_FieldPathArrayItemValue).ContainsValue(source.GetSpeedtestSettings())
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		return fpaivs.subPathItemValue.(HTTPProbingConfig_FieldPathArrayItemValue).ContainsValue(source.GetHttpProbingConfig())
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		return fpaivs.subPathItemValue.(ProxyConfiguration_FieldPathArrayItemValue).ContainsValue(source.GetProxyConfiguration())
	default:
		panic(fmt.Sprintf("Invalid selector for ProbingSettings: %d", fpaivs.Selector()))
	}
}

// ProbingSettings_FieldPathArrayOfValues allows storing slice of values for ProbingSettings fields according to their type
type ProbingSettings_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ProbingSettings_FieldPath
}

func ParseProbingSettings_FieldPathArrayOfValues(pathStr, valuesStr string) (ProbingSettings_FieldPathArrayOfValues, error) {
	fp, err := ParseProbingSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProbingSettings field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ProbingSettings_FieldPathArrayOfValues), nil
}

func MustParseProbingSettings_FieldPathArrayOfValues(pathStr, valuesStr string) ProbingSettings_FieldPathArrayOfValues {
	fpaov, err := ParseProbingSettings_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ProbingSettings_FieldTerminalPathArrayOfValues struct {
	ProbingSettings_FieldTerminalPath
	values interface{}
}

var _ ProbingSettings_FieldPathArrayOfValues = (*ProbingSettings_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ProbingSettings_FieldPathSelectorInterval:
		for _, v := range fpaov.values.([]*duration.Duration) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorTos:
		for _, v := range fpaov.values.([]*wrappers.UInt32Value) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorWindowSize:
		for _, v := range fpaov.values.([]*wrappers.UInt32Value) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorPathProbing:
		for _, v := range fpaov.values.([]*PathProbe) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorSpeedtestSettings:
		for _, v := range fpaov.values.([]*SpeedTestSettings) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorHttpProbingConfig:
		for _, v := range fpaov.values.([]*HTTPProbingConfig) {
			values = append(values, v)
		}
	case ProbingSettings_FieldPathSelectorProxyConfiguration:
		for _, v := range fpaov.values.([]*ProxyConfiguration) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsIntervalArrayOfValues() ([]*duration.Duration, bool) {
	res, ok := fpaov.values.([]*duration.Duration)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsTosArrayOfValues() ([]*wrappers.UInt32Value, bool) {
	res, ok := fpaov.values.([]*wrappers.UInt32Value)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsWindowSizeArrayOfValues() ([]*wrappers.UInt32Value, bool) {
	res, ok := fpaov.values.([]*wrappers.UInt32Value)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsPathProbingArrayOfValues() ([]*PathProbe, bool) {
	res, ok := fpaov.values.([]*PathProbe)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsSpeedtestSettingsArrayOfValues() ([]*SpeedTestSettings, bool) {
	res, ok := fpaov.values.([]*SpeedTestSettings)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsHttpProbingConfigArrayOfValues() ([]*HTTPProbingConfig, bool) {
	res, ok := fpaov.values.([]*HTTPProbingConfig)
	return res, ok
}
func (fpaov *ProbingSettings_FieldTerminalPathArrayOfValues) AsProxyConfigurationArrayOfValues() ([]*ProxyConfiguration, bool) {
	res, ok := fpaov.values.([]*ProxyConfiguration)
	return res, ok
}

type ProbingSettings_FieldSubPathArrayOfValues struct {
	ProbingSettings_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ProbingSettings_FieldPathArrayOfValues = (*ProbingSettings_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ProbingSettings_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ProbingSettings_FieldSubPathArrayOfValues) AsPathProbingPathArrayOfValues() (PathProbe_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(PathProbe_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *ProbingSettings_FieldSubPathArrayOfValues) AsSpeedtestSettingsPathArrayOfValues() (SpeedTestSettings_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SpeedTestSettings_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *ProbingSettings_FieldSubPathArrayOfValues) AsHttpProbingConfigPathArrayOfValues() (HTTPProbingConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(HTTPProbingConfig_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *ProbingSettings_FieldSubPathArrayOfValues) AsProxyConfigurationPathArrayOfValues() (ProxyConfiguration_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ProxyConfiguration_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ProxyConfiguration_FieldPath interface {
	gotenobject.FieldPath
	Selector() ProxyConfiguration_FieldPathSelector
	Get(source *ProxyConfiguration) []interface{}
	GetSingle(source *ProxyConfiguration) (interface{}, bool)
	ClearValue(item *ProxyConfiguration)

	// Those methods build corresponding ProxyConfiguration_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ProxyConfiguration_FieldPathValue
	WithIArrayOfValues(values interface{}) ProxyConfiguration_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ProxyConfiguration_FieldPathArrayItemValue
}

type ProxyConfiguration_FieldPathSelector int32

const (
	ProxyConfiguration_FieldPathSelectorProxySetting ProxyConfiguration_FieldPathSelector = 0
	ProxyConfiguration_FieldPathSelectorHttpProxy    ProxyConfiguration_FieldPathSelector = 1
	ProxyConfiguration_FieldPathSelectorHttpsProxy   ProxyConfiguration_FieldPathSelector = 2
	ProxyConfiguration_FieldPathSelectorNoProxy      ProxyConfiguration_FieldPathSelector = 3
)

func (s ProxyConfiguration_FieldPathSelector) String() string {
	switch s {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		return "proxy_setting"
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		return "http_proxy"
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		return "https_proxy"
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		return "no_proxy"
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", s))
	}
}

func BuildProxyConfiguration_FieldPath(fp gotenobject.RawFieldPath) (ProxyConfiguration_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ProxyConfiguration")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "proxy_setting", "proxySetting", "proxy-setting":
			return &ProxyConfiguration_FieldTerminalPath{selector: ProxyConfiguration_FieldPathSelectorProxySetting}, nil
		case "http_proxy", "httpProxy", "http-proxy":
			return &ProxyConfiguration_FieldTerminalPath{selector: ProxyConfiguration_FieldPathSelectorHttpProxy}, nil
		case "https_proxy", "httpsProxy", "https-proxy":
			return &ProxyConfiguration_FieldTerminalPath{selector: ProxyConfiguration_FieldPathSelectorHttpsProxy}, nil
		case "no_proxy", "noProxy", "no-proxy":
			return &ProxyConfiguration_FieldTerminalPath{selector: ProxyConfiguration_FieldPathSelectorNoProxy}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ProxyConfiguration", fp)
}

func ParseProxyConfiguration_FieldPath(rawField string) (ProxyConfiguration_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildProxyConfiguration_FieldPath(fp)
}

func MustParseProxyConfiguration_FieldPath(rawField string) ProxyConfiguration_FieldPath {
	fp, err := ParseProxyConfiguration_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ProxyConfiguration_FieldTerminalPath struct {
	selector ProxyConfiguration_FieldPathSelector
}

var _ ProxyConfiguration_FieldPath = (*ProxyConfiguration_FieldTerminalPath)(nil)

func (fp *ProxyConfiguration_FieldTerminalPath) Selector() ProxyConfiguration_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ProxyConfiguration_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ProxyConfiguration_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ProxyConfiguration
func (fp *ProxyConfiguration_FieldTerminalPath) Get(source *ProxyConfiguration) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ProxyConfiguration_FieldPathSelectorProxySetting:
			values = append(values, source.ProxySetting)
		case ProxyConfiguration_FieldPathSelectorHttpProxy:
			values = append(values, source.HttpProxy)
		case ProxyConfiguration_FieldPathSelectorHttpsProxy:
			values = append(values, source.HttpsProxy)
		case ProxyConfiguration_FieldPathSelectorNoProxy:
			values = append(values, source.NoProxy)
		default:
			panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
		}
	}
	return
}

func (fp *ProxyConfiguration_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ProxyConfiguration))
}

// GetSingle returns value pointed by specific field of from source ProxyConfiguration
func (fp *ProxyConfiguration_FieldTerminalPath) GetSingle(source *ProxyConfiguration) (interface{}, bool) {
	switch fp.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		return source.GetProxySetting(), source != nil
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		return source.GetHttpProxy(), source != nil
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		return source.GetHttpsProxy(), source != nil
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		return source.GetNoProxy(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
	}
}

func (fp *ProxyConfiguration_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ProxyConfiguration))
}

// GetDefault returns a default value of the field type
func (fp *ProxyConfiguration_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		return ProxySetting_USE_SYSTEM_CONFIGURATION
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		return ""
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		return ""
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
	}
}

func (fp *ProxyConfiguration_FieldTerminalPath) ClearValue(item *ProxyConfiguration) {
	if item != nil {
		switch fp.selector {
		case ProxyConfiguration_FieldPathSelectorProxySetting:
			item.ProxySetting = ProxySetting_USE_SYSTEM_CONFIGURATION
		case ProxyConfiguration_FieldPathSelectorHttpProxy:
			item.HttpProxy = ""
		case ProxyConfiguration_FieldPathSelectorHttpsProxy:
			item.HttpsProxy = ""
		case ProxyConfiguration_FieldPathSelectorNoProxy:
			item.NoProxy = ""
		default:
			panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
		}
	}
}

func (fp *ProxyConfiguration_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ProxyConfiguration))
}

// IsLeaf - whether field path is holds simple value
func (fp *ProxyConfiguration_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ProxyConfiguration_FieldPathSelectorProxySetting ||
		fp.selector == ProxyConfiguration_FieldPathSelectorHttpProxy ||
		fp.selector == ProxyConfiguration_FieldPathSelectorHttpsProxy ||
		fp.selector == ProxyConfiguration_FieldPathSelectorNoProxy
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithIValue(value interface{}) ProxyConfiguration_FieldPathValue {
	switch fp.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		return &ProxyConfiguration_FieldTerminalPathValue{ProxyConfiguration_FieldTerminalPath: *fp, value: value.(ProxySetting)}
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		return &ProxyConfiguration_FieldTerminalPathValue{ProxyConfiguration_FieldTerminalPath: *fp, value: value.(string)}
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		return &ProxyConfiguration_FieldTerminalPathValue{ProxyConfiguration_FieldTerminalPath: *fp, value: value.(string)}
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		return &ProxyConfiguration_FieldTerminalPathValue{ProxyConfiguration_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
	}
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithIArrayOfValues(values interface{}) ProxyConfiguration_FieldPathArrayOfValues {
	fpaov := &ProxyConfiguration_FieldTerminalPathArrayOfValues{ProxyConfiguration_FieldTerminalPath: *fp}
	switch fp.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		return &ProxyConfiguration_FieldTerminalPathArrayOfValues{ProxyConfiguration_FieldTerminalPath: *fp, values: values.([]ProxySetting)}
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		return &ProxyConfiguration_FieldTerminalPathArrayOfValues{ProxyConfiguration_FieldTerminalPath: *fp, values: values.([]string)}
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		return &ProxyConfiguration_FieldTerminalPathArrayOfValues{ProxyConfiguration_FieldTerminalPath: *fp, values: values.([]string)}
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		return &ProxyConfiguration_FieldTerminalPathArrayOfValues{ProxyConfiguration_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
	}
	return fpaov
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithIArrayItemValue(value interface{}) ProxyConfiguration_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fp.selector))
	}
}

func (fp *ProxyConfiguration_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ProxyConfiguration_FieldPathValue allows storing values for ProxyConfiguration fields according to their type
type ProxyConfiguration_FieldPathValue interface {
	ProxyConfiguration_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ProxyConfiguration)
	CompareWith(*ProxyConfiguration) (cmp int, comparable bool)
}

func ParseProxyConfiguration_FieldPathValue(pathStr, valueStr string) (ProxyConfiguration_FieldPathValue, error) {
	fp, err := ParseProxyConfiguration_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProxyConfiguration field path value from %s: %v", valueStr, err)
	}
	return fpv.(ProxyConfiguration_FieldPathValue), nil
}

func MustParseProxyConfiguration_FieldPathValue(pathStr, valueStr string) ProxyConfiguration_FieldPathValue {
	fpv, err := ParseProxyConfiguration_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ProxyConfiguration_FieldTerminalPathValue struct {
	ProxyConfiguration_FieldTerminalPath
	value interface{}
}

var _ ProxyConfiguration_FieldPathValue = (*ProxyConfiguration_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ProxyConfiguration' as interface{}
func (fpv *ProxyConfiguration_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ProxyConfiguration_FieldTerminalPathValue) AsProxySettingValue() (ProxySetting, bool) {
	res, ok := fpv.value.(ProxySetting)
	return res, ok
}
func (fpv *ProxyConfiguration_FieldTerminalPathValue) AsHttpProxyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ProxyConfiguration_FieldTerminalPathValue) AsHttpsProxyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ProxyConfiguration_FieldTerminalPathValue) AsNoProxyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object ProxyConfiguration
func (fpv *ProxyConfiguration_FieldTerminalPathValue) SetTo(target **ProxyConfiguration) {
	if *target == nil {
		*target = new(ProxyConfiguration)
	}
	switch fpv.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		(*target).ProxySetting = fpv.value.(ProxySetting)
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		(*target).HttpProxy = fpv.value.(string)
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		(*target).HttpsProxy = fpv.value.(string)
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		(*target).NoProxy = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fpv.selector))
	}
}

func (fpv *ProxyConfiguration_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ProxyConfiguration)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ProxyConfiguration_FieldTerminalPathValue' with the value under path in 'ProxyConfiguration'.
func (fpv *ProxyConfiguration_FieldTerminalPathValue) CompareWith(source *ProxyConfiguration) (int, bool) {
	switch fpv.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		leftValue := fpv.value.(ProxySetting)
		rightValue := source.GetProxySetting()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		leftValue := fpv.value.(string)
		rightValue := source.GetHttpProxy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		leftValue := fpv.value.(string)
		rightValue := source.GetHttpsProxy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		leftValue := fpv.value.(string)
		rightValue := source.GetNoProxy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ProxyConfiguration: %d", fpv.selector))
	}
}

func (fpv *ProxyConfiguration_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ProxyConfiguration))
}

// ProxyConfiguration_FieldPathArrayItemValue allows storing single item in Path-specific values for ProxyConfiguration according to their type
// Present only for array (repeated) types.
type ProxyConfiguration_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ProxyConfiguration_FieldPath
	ContainsValue(*ProxyConfiguration) bool
}

// ParseProxyConfiguration_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseProxyConfiguration_FieldPathArrayItemValue(pathStr, valueStr string) (ProxyConfiguration_FieldPathArrayItemValue, error) {
	fp, err := ParseProxyConfiguration_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProxyConfiguration field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ProxyConfiguration_FieldPathArrayItemValue), nil
}

func MustParseProxyConfiguration_FieldPathArrayItemValue(pathStr, valueStr string) ProxyConfiguration_FieldPathArrayItemValue {
	fpaiv, err := ParseProxyConfiguration_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ProxyConfiguration_FieldTerminalPathArrayItemValue struct {
	ProxyConfiguration_FieldTerminalPath
	value interface{}
}

var _ ProxyConfiguration_FieldPathArrayItemValue = (*ProxyConfiguration_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ProxyConfiguration as interface{}
func (fpaiv *ProxyConfiguration_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ProxyConfiguration_FieldTerminalPathArrayItemValue) GetSingle(source *ProxyConfiguration) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ProxyConfiguration_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ProxyConfiguration))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ProxyConfiguration'
func (fpaiv *ProxyConfiguration_FieldTerminalPathArrayItemValue) ContainsValue(source *ProxyConfiguration) bool {
	slice := fpaiv.ProxyConfiguration_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ProxyConfiguration_FieldPathArrayOfValues allows storing slice of values for ProxyConfiguration fields according to their type
type ProxyConfiguration_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ProxyConfiguration_FieldPath
}

func ParseProxyConfiguration_FieldPathArrayOfValues(pathStr, valuesStr string) (ProxyConfiguration_FieldPathArrayOfValues, error) {
	fp, err := ParseProxyConfiguration_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ProxyConfiguration field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ProxyConfiguration_FieldPathArrayOfValues), nil
}

func MustParseProxyConfiguration_FieldPathArrayOfValues(pathStr, valuesStr string) ProxyConfiguration_FieldPathArrayOfValues {
	fpaov, err := ParseProxyConfiguration_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ProxyConfiguration_FieldTerminalPathArrayOfValues struct {
	ProxyConfiguration_FieldTerminalPath
	values interface{}
}

var _ ProxyConfiguration_FieldPathArrayOfValues = (*ProxyConfiguration_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ProxyConfiguration_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ProxyConfiguration_FieldPathSelectorProxySetting:
		for _, v := range fpaov.values.([]ProxySetting) {
			values = append(values, v)
		}
	case ProxyConfiguration_FieldPathSelectorHttpProxy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ProxyConfiguration_FieldPathSelectorHttpsProxy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ProxyConfiguration_FieldPathSelectorNoProxy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ProxyConfiguration_FieldTerminalPathArrayOfValues) AsProxySettingArrayOfValues() ([]ProxySetting, bool) {
	res, ok := fpaov.values.([]ProxySetting)
	return res, ok
}
func (fpaov *ProxyConfiguration_FieldTerminalPathArrayOfValues) AsHttpProxyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ProxyConfiguration_FieldTerminalPathArrayOfValues) AsHttpsProxyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ProxyConfiguration_FieldTerminalPathArrayOfValues) AsNoProxyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WLAN_FieldPath interface {
	gotenobject.FieldPath
	Selector() WLAN_FieldPathSelector
	Get(source *WLAN) []interface{}
	GetSingle(source *WLAN) (interface{}, bool)
	ClearValue(item *WLAN)

	// Those methods build corresponding WLAN_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WLAN_FieldPathValue
	WithIArrayOfValues(values interface{}) WLAN_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WLAN_FieldPathArrayItemValue
}

type WLAN_FieldPathSelector int32

const (
	WLAN_FieldPathSelectorMac    WLAN_FieldPathSelector = 0
	WLAN_FieldPathSelectorSignal WLAN_FieldPathSelector = 1
)

func (s WLAN_FieldPathSelector) String() string {
	switch s {
	case WLAN_FieldPathSelectorMac:
		return "mac"
	case WLAN_FieldPathSelectorSignal:
		return "signal"
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", s))
	}
}

func BuildWLAN_FieldPath(fp gotenobject.RawFieldPath) (WLAN_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WLAN")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "mac":
			return &WLAN_FieldTerminalPath{selector: WLAN_FieldPathSelectorMac}, nil
		case "signal":
			return &WLAN_FieldTerminalPath{selector: WLAN_FieldPathSelectorSignal}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WLAN", fp)
}

func ParseWLAN_FieldPath(rawField string) (WLAN_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWLAN_FieldPath(fp)
}

func MustParseWLAN_FieldPath(rawField string) WLAN_FieldPath {
	fp, err := ParseWLAN_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WLAN_FieldTerminalPath struct {
	selector WLAN_FieldPathSelector
}

var _ WLAN_FieldPath = (*WLAN_FieldTerminalPath)(nil)

func (fp *WLAN_FieldTerminalPath) Selector() WLAN_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WLAN_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WLAN_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WLAN
func (fp *WLAN_FieldTerminalPath) Get(source *WLAN) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WLAN_FieldPathSelectorMac:
			values = append(values, source.Mac)
		case WLAN_FieldPathSelectorSignal:
			values = append(values, source.Signal)
		default:
			panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
		}
	}
	return
}

func (fp *WLAN_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WLAN))
}

// GetSingle returns value pointed by specific field of from source WLAN
func (fp *WLAN_FieldTerminalPath) GetSingle(source *WLAN) (interface{}, bool) {
	switch fp.selector {
	case WLAN_FieldPathSelectorMac:
		return source.GetMac(), source != nil
	case WLAN_FieldPathSelectorSignal:
		return source.GetSignal(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
	}
}

func (fp *WLAN_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WLAN))
}

// GetDefault returns a default value of the field type
func (fp *WLAN_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WLAN_FieldPathSelectorMac:
		return ""
	case WLAN_FieldPathSelectorSignal:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
	}
}

func (fp *WLAN_FieldTerminalPath) ClearValue(item *WLAN) {
	if item != nil {
		switch fp.selector {
		case WLAN_FieldPathSelectorMac:
			item.Mac = ""
		case WLAN_FieldPathSelectorSignal:
			item.Signal = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
		}
	}
}

func (fp *WLAN_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WLAN))
}

// IsLeaf - whether field path is holds simple value
func (fp *WLAN_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WLAN_FieldPathSelectorMac ||
		fp.selector == WLAN_FieldPathSelectorSignal
}

func (fp *WLAN_FieldTerminalPath) WithIValue(value interface{}) WLAN_FieldPathValue {
	switch fp.selector {
	case WLAN_FieldPathSelectorMac:
		return &WLAN_FieldTerminalPathValue{WLAN_FieldTerminalPath: *fp, value: value.(string)}
	case WLAN_FieldPathSelectorSignal:
		return &WLAN_FieldTerminalPathValue{WLAN_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
	}
}

func (fp *WLAN_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WLAN_FieldTerminalPath) WithIArrayOfValues(values interface{}) WLAN_FieldPathArrayOfValues {
	fpaov := &WLAN_FieldTerminalPathArrayOfValues{WLAN_FieldTerminalPath: *fp}
	switch fp.selector {
	case WLAN_FieldPathSelectorMac:
		return &WLAN_FieldTerminalPathArrayOfValues{WLAN_FieldTerminalPath: *fp, values: values.([]string)}
	case WLAN_FieldPathSelectorSignal:
		return &WLAN_FieldTerminalPathArrayOfValues{WLAN_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
	}
	return fpaov
}

func (fp *WLAN_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WLAN_FieldTerminalPath) WithIArrayItemValue(value interface{}) WLAN_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fp.selector))
	}
}

func (fp *WLAN_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WLAN_FieldPathValue allows storing values for WLAN fields according to their type
type WLAN_FieldPathValue interface {
	WLAN_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WLAN)
	CompareWith(*WLAN) (cmp int, comparable bool)
}

func ParseWLAN_FieldPathValue(pathStr, valueStr string) (WLAN_FieldPathValue, error) {
	fp, err := ParseWLAN_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WLAN field path value from %s: %v", valueStr, err)
	}
	return fpv.(WLAN_FieldPathValue), nil
}

func MustParseWLAN_FieldPathValue(pathStr, valueStr string) WLAN_FieldPathValue {
	fpv, err := ParseWLAN_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WLAN_FieldTerminalPathValue struct {
	WLAN_FieldTerminalPath
	value interface{}
}

var _ WLAN_FieldPathValue = (*WLAN_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WLAN' as interface{}
func (fpv *WLAN_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WLAN_FieldTerminalPathValue) AsMacValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *WLAN_FieldTerminalPathValue) AsSignalValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object WLAN
func (fpv *WLAN_FieldTerminalPathValue) SetTo(target **WLAN) {
	if *target == nil {
		*target = new(WLAN)
	}
	switch fpv.selector {
	case WLAN_FieldPathSelectorMac:
		(*target).Mac = fpv.value.(string)
	case WLAN_FieldPathSelectorSignal:
		(*target).Signal = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fpv.selector))
	}
}

func (fpv *WLAN_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WLAN)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WLAN_FieldTerminalPathValue' with the value under path in 'WLAN'.
func (fpv *WLAN_FieldTerminalPathValue) CompareWith(source *WLAN) (int, bool) {
	switch fpv.selector {
	case WLAN_FieldPathSelectorMac:
		leftValue := fpv.value.(string)
		rightValue := source.GetMac()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WLAN_FieldPathSelectorSignal:
		leftValue := fpv.value.(int32)
		rightValue := source.GetSignal()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WLAN: %d", fpv.selector))
	}
}

func (fpv *WLAN_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WLAN))
}

// WLAN_FieldPathArrayItemValue allows storing single item in Path-specific values for WLAN according to their type
// Present only for array (repeated) types.
type WLAN_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WLAN_FieldPath
	ContainsValue(*WLAN) bool
}

// ParseWLAN_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWLAN_FieldPathArrayItemValue(pathStr, valueStr string) (WLAN_FieldPathArrayItemValue, error) {
	fp, err := ParseWLAN_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WLAN field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WLAN_FieldPathArrayItemValue), nil
}

func MustParseWLAN_FieldPathArrayItemValue(pathStr, valueStr string) WLAN_FieldPathArrayItemValue {
	fpaiv, err := ParseWLAN_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WLAN_FieldTerminalPathArrayItemValue struct {
	WLAN_FieldTerminalPath
	value interface{}
}

var _ WLAN_FieldPathArrayItemValue = (*WLAN_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WLAN as interface{}
func (fpaiv *WLAN_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WLAN_FieldTerminalPathArrayItemValue) GetSingle(source *WLAN) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WLAN_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WLAN))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WLAN'
func (fpaiv *WLAN_FieldTerminalPathArrayItemValue) ContainsValue(source *WLAN) bool {
	slice := fpaiv.WLAN_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WLAN_FieldPathArrayOfValues allows storing slice of values for WLAN fields according to their type
type WLAN_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WLAN_FieldPath
}

func ParseWLAN_FieldPathArrayOfValues(pathStr, valuesStr string) (WLAN_FieldPathArrayOfValues, error) {
	fp, err := ParseWLAN_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WLAN field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WLAN_FieldPathArrayOfValues), nil
}

func MustParseWLAN_FieldPathArrayOfValues(pathStr, valuesStr string) WLAN_FieldPathArrayOfValues {
	fpaov, err := ParseWLAN_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WLAN_FieldTerminalPathArrayOfValues struct {
	WLAN_FieldTerminalPath
	values interface{}
}

var _ WLAN_FieldPathArrayOfValues = (*WLAN_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WLAN_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WLAN_FieldPathSelectorMac:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case WLAN_FieldPathSelectorSignal:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WLAN_FieldTerminalPathArrayOfValues) AsMacArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *WLAN_FieldTerminalPathArrayOfValues) AsSignalArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SpeedTestSettings_FieldPath interface {
	gotenobject.FieldPath
	Selector() SpeedTestSettings_FieldPathSelector
	Get(source *SpeedTestSettings) []interface{}
	GetSingle(source *SpeedTestSettings) (interface{}, bool)
	ClearValue(item *SpeedTestSettings)

	// Those methods build corresponding SpeedTestSettings_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SpeedTestSettings_FieldPathValue
	WithIArrayOfValues(values interface{}) SpeedTestSettings_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SpeedTestSettings_FieldPathArrayItemValue
}

type SpeedTestSettings_FieldPathSelector int32

const (
	SpeedTestSettings_FieldPathSelectorDuration        SpeedTestSettings_FieldPathSelector = 0
	SpeedTestSettings_FieldPathSelectorServerSelection SpeedTestSettings_FieldPathSelector = 1
	SpeedTestSettings_FieldPathSelectorTcpPort         SpeedTestSettings_FieldPathSelector = 2
)

func (s SpeedTestSettings_FieldPathSelector) String() string {
	switch s {
	case SpeedTestSettings_FieldPathSelectorDuration:
		return "duration"
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		return "server_selection"
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		return "tcp_port"
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", s))
	}
}

func BuildSpeedTestSettings_FieldPath(fp gotenobject.RawFieldPath) (SpeedTestSettings_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SpeedTestSettings")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "duration":
			return &SpeedTestSettings_FieldTerminalPath{selector: SpeedTestSettings_FieldPathSelectorDuration}, nil
		case "server_selection", "serverSelection", "server-selection":
			return &SpeedTestSettings_FieldTerminalPath{selector: SpeedTestSettings_FieldPathSelectorServerSelection}, nil
		case "tcp_port", "tcpPort", "tcp-port":
			return &SpeedTestSettings_FieldTerminalPath{selector: SpeedTestSettings_FieldPathSelectorTcpPort}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SpeedTestSettings", fp)
}

func ParseSpeedTestSettings_FieldPath(rawField string) (SpeedTestSettings_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSpeedTestSettings_FieldPath(fp)
}

func MustParseSpeedTestSettings_FieldPath(rawField string) SpeedTestSettings_FieldPath {
	fp, err := ParseSpeedTestSettings_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SpeedTestSettings_FieldTerminalPath struct {
	selector SpeedTestSettings_FieldPathSelector
}

var _ SpeedTestSettings_FieldPath = (*SpeedTestSettings_FieldTerminalPath)(nil)

func (fp *SpeedTestSettings_FieldTerminalPath) Selector() SpeedTestSettings_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SpeedTestSettings_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SpeedTestSettings_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SpeedTestSettings
func (fp *SpeedTestSettings_FieldTerminalPath) Get(source *SpeedTestSettings) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SpeedTestSettings_FieldPathSelectorDuration:
			if source.Duration != nil {
				values = append(values, source.Duration)
			}
		case SpeedTestSettings_FieldPathSelectorServerSelection:
			values = append(values, source.ServerSelection)
		case SpeedTestSettings_FieldPathSelectorTcpPort:
			values = append(values, source.TcpPort)
		default:
			panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
		}
	}
	return
}

func (fp *SpeedTestSettings_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SpeedTestSettings))
}

// GetSingle returns value pointed by specific field of from source SpeedTestSettings
func (fp *SpeedTestSettings_FieldTerminalPath) GetSingle(source *SpeedTestSettings) (interface{}, bool) {
	switch fp.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		res := source.GetDuration()
		return res, res != nil
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		return source.GetServerSelection(), source != nil
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		return source.GetTcpPort(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
	}
}

func (fp *SpeedTestSettings_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SpeedTestSettings))
}

// GetDefault returns a default value of the field type
func (fp *SpeedTestSettings_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		return (*duration.Duration)(nil)
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		return SpeedTestSettings_NEAREST
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
	}
}

func (fp *SpeedTestSettings_FieldTerminalPath) ClearValue(item *SpeedTestSettings) {
	if item != nil {
		switch fp.selector {
		case SpeedTestSettings_FieldPathSelectorDuration:
			item.Duration = nil
		case SpeedTestSettings_FieldPathSelectorServerSelection:
			item.ServerSelection = SpeedTestSettings_NEAREST
		case SpeedTestSettings_FieldPathSelectorTcpPort:
			item.TcpPort = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
		}
	}
}

func (fp *SpeedTestSettings_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SpeedTestSettings))
}

// IsLeaf - whether field path is holds simple value
func (fp *SpeedTestSettings_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SpeedTestSettings_FieldPathSelectorDuration ||
		fp.selector == SpeedTestSettings_FieldPathSelectorServerSelection ||
		fp.selector == SpeedTestSettings_FieldPathSelectorTcpPort
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithIValue(value interface{}) SpeedTestSettings_FieldPathValue {
	switch fp.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		return &SpeedTestSettings_FieldTerminalPathValue{SpeedTestSettings_FieldTerminalPath: *fp, value: value.(*duration.Duration)}
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		return &SpeedTestSettings_FieldTerminalPathValue{SpeedTestSettings_FieldTerminalPath: *fp, value: value.(SpeedTestSettings_ServerSelection)}
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		return &SpeedTestSettings_FieldTerminalPathValue{SpeedTestSettings_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
	}
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithIArrayOfValues(values interface{}) SpeedTestSettings_FieldPathArrayOfValues {
	fpaov := &SpeedTestSettings_FieldTerminalPathArrayOfValues{SpeedTestSettings_FieldTerminalPath: *fp}
	switch fp.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		return &SpeedTestSettings_FieldTerminalPathArrayOfValues{SpeedTestSettings_FieldTerminalPath: *fp, values: values.([]*duration.Duration)}
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		return &SpeedTestSettings_FieldTerminalPathArrayOfValues{SpeedTestSettings_FieldTerminalPath: *fp, values: values.([]SpeedTestSettings_ServerSelection)}
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		return &SpeedTestSettings_FieldTerminalPathArrayOfValues{SpeedTestSettings_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
	}
	return fpaov
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithIArrayItemValue(value interface{}) SpeedTestSettings_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fp.selector))
	}
}

func (fp *SpeedTestSettings_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SpeedTestSettings_FieldPathValue allows storing values for SpeedTestSettings fields according to their type
type SpeedTestSettings_FieldPathValue interface {
	SpeedTestSettings_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SpeedTestSettings)
	CompareWith(*SpeedTestSettings) (cmp int, comparable bool)
}

func ParseSpeedTestSettings_FieldPathValue(pathStr, valueStr string) (SpeedTestSettings_FieldPathValue, error) {
	fp, err := ParseSpeedTestSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SpeedTestSettings field path value from %s: %v", valueStr, err)
	}
	return fpv.(SpeedTestSettings_FieldPathValue), nil
}

func MustParseSpeedTestSettings_FieldPathValue(pathStr, valueStr string) SpeedTestSettings_FieldPathValue {
	fpv, err := ParseSpeedTestSettings_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SpeedTestSettings_FieldTerminalPathValue struct {
	SpeedTestSettings_FieldTerminalPath
	value interface{}
}

var _ SpeedTestSettings_FieldPathValue = (*SpeedTestSettings_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SpeedTestSettings' as interface{}
func (fpv *SpeedTestSettings_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SpeedTestSettings_FieldTerminalPathValue) AsDurationValue() (*duration.Duration, bool) {
	res, ok := fpv.value.(*duration.Duration)
	return res, ok
}
func (fpv *SpeedTestSettings_FieldTerminalPathValue) AsServerSelectionValue() (SpeedTestSettings_ServerSelection, bool) {
	res, ok := fpv.value.(SpeedTestSettings_ServerSelection)
	return res, ok
}
func (fpv *SpeedTestSettings_FieldTerminalPathValue) AsTcpPortValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object SpeedTestSettings
func (fpv *SpeedTestSettings_FieldTerminalPathValue) SetTo(target **SpeedTestSettings) {
	if *target == nil {
		*target = new(SpeedTestSettings)
	}
	switch fpv.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		(*target).Duration = fpv.value.(*duration.Duration)
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		(*target).ServerSelection = fpv.value.(SpeedTestSettings_ServerSelection)
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		(*target).TcpPort = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fpv.selector))
	}
}

func (fpv *SpeedTestSettings_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SpeedTestSettings)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SpeedTestSettings_FieldTerminalPathValue' with the value under path in 'SpeedTestSettings'.
func (fpv *SpeedTestSettings_FieldTerminalPathValue) CompareWith(source *SpeedTestSettings) (int, bool) {
	switch fpv.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		leftValue := fpv.value.(*duration.Duration)
		rightValue := source.GetDuration()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		leftValue := fpv.value.(SpeedTestSettings_ServerSelection)
		rightValue := source.GetServerSelection()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		leftValue := fpv.value.(int32)
		rightValue := source.GetTcpPort()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SpeedTestSettings: %d", fpv.selector))
	}
}

func (fpv *SpeedTestSettings_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SpeedTestSettings))
}

// SpeedTestSettings_FieldPathArrayItemValue allows storing single item in Path-specific values for SpeedTestSettings according to their type
// Present only for array (repeated) types.
type SpeedTestSettings_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SpeedTestSettings_FieldPath
	ContainsValue(*SpeedTestSettings) bool
}

// ParseSpeedTestSettings_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSpeedTestSettings_FieldPathArrayItemValue(pathStr, valueStr string) (SpeedTestSettings_FieldPathArrayItemValue, error) {
	fp, err := ParseSpeedTestSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SpeedTestSettings field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SpeedTestSettings_FieldPathArrayItemValue), nil
}

func MustParseSpeedTestSettings_FieldPathArrayItemValue(pathStr, valueStr string) SpeedTestSettings_FieldPathArrayItemValue {
	fpaiv, err := ParseSpeedTestSettings_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SpeedTestSettings_FieldTerminalPathArrayItemValue struct {
	SpeedTestSettings_FieldTerminalPath
	value interface{}
}

var _ SpeedTestSettings_FieldPathArrayItemValue = (*SpeedTestSettings_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SpeedTestSettings as interface{}
func (fpaiv *SpeedTestSettings_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *SpeedTestSettings_FieldTerminalPathArrayItemValue) GetSingle(source *SpeedTestSettings) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SpeedTestSettings_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SpeedTestSettings))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SpeedTestSettings'
func (fpaiv *SpeedTestSettings_FieldTerminalPathArrayItemValue) ContainsValue(source *SpeedTestSettings) bool {
	slice := fpaiv.SpeedTestSettings_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SpeedTestSettings_FieldPathArrayOfValues allows storing slice of values for SpeedTestSettings fields according to their type
type SpeedTestSettings_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SpeedTestSettings_FieldPath
}

func ParseSpeedTestSettings_FieldPathArrayOfValues(pathStr, valuesStr string) (SpeedTestSettings_FieldPathArrayOfValues, error) {
	fp, err := ParseSpeedTestSettings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SpeedTestSettings field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SpeedTestSettings_FieldPathArrayOfValues), nil
}

func MustParseSpeedTestSettings_FieldPathArrayOfValues(pathStr, valuesStr string) SpeedTestSettings_FieldPathArrayOfValues {
	fpaov, err := ParseSpeedTestSettings_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SpeedTestSettings_FieldTerminalPathArrayOfValues struct {
	SpeedTestSettings_FieldTerminalPath
	values interface{}
}

var _ SpeedTestSettings_FieldPathArrayOfValues = (*SpeedTestSettings_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SpeedTestSettings_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SpeedTestSettings_FieldPathSelectorDuration:
		for _, v := range fpaov.values.([]*duration.Duration) {
			values = append(values, v)
		}
	case SpeedTestSettings_FieldPathSelectorServerSelection:
		for _, v := range fpaov.values.([]SpeedTestSettings_ServerSelection) {
			values = append(values, v)
		}
	case SpeedTestSettings_FieldPathSelectorTcpPort:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SpeedTestSettings_FieldTerminalPathArrayOfValues) AsDurationArrayOfValues() ([]*duration.Duration, bool) {
	res, ok := fpaov.values.([]*duration.Duration)
	return res, ok
}
func (fpaov *SpeedTestSettings_FieldTerminalPathArrayOfValues) AsServerSelectionArrayOfValues() ([]SpeedTestSettings_ServerSelection, bool) {
	res, ok := fpaov.values.([]SpeedTestSettings_ServerSelection)
	return res, ok
}
func (fpaov *SpeedTestSettings_FieldTerminalPathArrayOfValues) AsTcpPortArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type HTTPProbingConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() HTTPProbingConfig_FieldPathSelector
	Get(source *HTTPProbingConfig) []interface{}
	GetSingle(source *HTTPProbingConfig) (interface{}, bool)
	ClearValue(item *HTTPProbingConfig)

	// Those methods build corresponding HTTPProbingConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) HTTPProbingConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) HTTPProbingConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) HTTPProbingConfig_FieldPathArrayItemValue
}

type HTTPProbingConfig_FieldPathSelector int32

const (
	HTTPProbingConfig_FieldPathSelectorHttpRequest HTTPProbingConfig_FieldPathSelector = 0
	HTTPProbingConfig_FieldPathSelectorAuthConfig  HTTPProbingConfig_FieldPathSelector = 1
)

func (s HTTPProbingConfig_FieldPathSelector) String() string {
	switch s {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return "http_request"
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return "auth_config"
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", s))
	}
}

func BuildHTTPProbingConfig_FieldPath(fp gotenobject.RawFieldPath) (HTTPProbingConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object HTTPProbingConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "http_request", "httpRequest", "http-request":
			return &HTTPProbingConfig_FieldTerminalPath{selector: HTTPProbingConfig_FieldPathSelectorHttpRequest}, nil
		case "auth_config", "authConfig", "auth-config":
			return &HTTPProbingConfig_FieldTerminalPath{selector: HTTPProbingConfig_FieldPathSelectorAuthConfig}, nil
		}
	} else {
		switch fp[0] {
		case "http_request", "httpRequest", "http-request":
			if subpath, err := BuildHTTPProbingConfigHTTPRequest_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &HTTPProbingConfig_FieldSubPath{selector: HTTPProbingConfig_FieldPathSelectorHttpRequest, subPath: subpath}, nil
			}
		case "auth_config", "authConfig", "auth-config":
			if subpath, err := BuildHTTPProbingConfigHTTPAuth_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &HTTPProbingConfig_FieldSubPath{selector: HTTPProbingConfig_FieldPathSelectorAuthConfig, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object HTTPProbingConfig", fp)
}

func ParseHTTPProbingConfig_FieldPath(rawField string) (HTTPProbingConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildHTTPProbingConfig_FieldPath(fp)
}

func MustParseHTTPProbingConfig_FieldPath(rawField string) HTTPProbingConfig_FieldPath {
	fp, err := ParseHTTPProbingConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type HTTPProbingConfig_FieldTerminalPath struct {
	selector HTTPProbingConfig_FieldPathSelector
}

var _ HTTPProbingConfig_FieldPath = (*HTTPProbingConfig_FieldTerminalPath)(nil)

func (fp *HTTPProbingConfig_FieldTerminalPath) Selector() HTTPProbingConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *HTTPProbingConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *HTTPProbingConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source HTTPProbingConfig
func (fp *HTTPProbingConfig_FieldTerminalPath) Get(source *HTTPProbingConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case HTTPProbingConfig_FieldPathSelectorHttpRequest:
			if source.HttpRequest != nil {
				values = append(values, source.HttpRequest)
			}
		case HTTPProbingConfig_FieldPathSelectorAuthConfig:
			if source.AuthConfig != nil {
				values = append(values, source.AuthConfig)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *HTTPProbingConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*HTTPProbingConfig))
}

// GetSingle returns value pointed by specific field of from source HTTPProbingConfig
func (fp *HTTPProbingConfig_FieldTerminalPath) GetSingle(source *HTTPProbingConfig) (interface{}, bool) {
	switch fp.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		res := source.GetHttpRequest()
		return res, res != nil
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		res := source.GetAuthConfig()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*HTTPProbingConfig))
}

// GetDefault returns a default value of the field type
func (fp *HTTPProbingConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return (*HTTPProbingConfig_HTTPRequest)(nil)
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return (*HTTPProbingConfig_HTTPAuth)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfig_FieldTerminalPath) ClearValue(item *HTTPProbingConfig) {
	if item != nil {
		switch fp.selector {
		case HTTPProbingConfig_FieldPathSelectorHttpRequest:
			item.HttpRequest = nil
		case HTTPProbingConfig_FieldPathSelectorAuthConfig:
			item.AuthConfig = nil
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
		}
	}
}

func (fp *HTTPProbingConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*HTTPProbingConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *HTTPProbingConfig_FieldTerminalPath) IsLeaf() bool {
	return false
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithIValue(value interface{}) HTTPProbingConfig_FieldPathValue {
	switch fp.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return &HTTPProbingConfig_FieldTerminalPathValue{HTTPProbingConfig_FieldTerminalPath: *fp, value: value.(*HTTPProbingConfig_HTTPRequest)}
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return &HTTPProbingConfig_FieldTerminalPathValue{HTTPProbingConfig_FieldTerminalPath: *fp, value: value.(*HTTPProbingConfig_HTTPAuth)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) HTTPProbingConfig_FieldPathArrayOfValues {
	fpaov := &HTTPProbingConfig_FieldTerminalPathArrayOfValues{HTTPProbingConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return &HTTPProbingConfig_FieldTerminalPathArrayOfValues{HTTPProbingConfig_FieldTerminalPath: *fp, values: values.([]*HTTPProbingConfig_HTTPRequest)}
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return &HTTPProbingConfig_FieldTerminalPathArrayOfValues{HTTPProbingConfig_FieldTerminalPath: *fp, values: values.([]*HTTPProbingConfig_HTTPAuth)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) HTTPProbingConfig_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type HTTPProbingConfig_FieldSubPath struct {
	selector HTTPProbingConfig_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ HTTPProbingConfig_FieldPath = (*HTTPProbingConfig_FieldSubPath)(nil)

func (fps *HTTPProbingConfig_FieldSubPath) Selector() HTTPProbingConfig_FieldPathSelector {
	return fps.selector
}
func (fps *HTTPProbingConfig_FieldSubPath) AsHttpRequestSubPath() (HTTPProbingConfigHTTPRequest_FieldPath, bool) {
	res, ok := fps.subPath.(HTTPProbingConfigHTTPRequest_FieldPath)
	return res, ok
}
func (fps *HTTPProbingConfig_FieldSubPath) AsAuthConfigSubPath() (HTTPProbingConfigHTTPAuth_FieldPath, bool) {
	res, ok := fps.subPath.(HTTPProbingConfigHTTPAuth_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *HTTPProbingConfig_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *HTTPProbingConfig_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source HTTPProbingConfig
func (fps *HTTPProbingConfig_FieldSubPath) Get(source *HTTPProbingConfig) (values []interface{}) {
	if asHTTPRequestFieldPath, ok := fps.AsHttpRequestSubPath(); ok {
		values = append(values, asHTTPRequestFieldPath.Get(source.GetHttpRequest())...)
	} else if asHTTPAuthFieldPath, ok := fps.AsAuthConfigSubPath(); ok {
		values = append(values, asHTTPAuthFieldPath.Get(source.GetAuthConfig())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fps.selector))
	}
	return
}

func (fps *HTTPProbingConfig_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*HTTPProbingConfig))
}

// GetSingle returns value of selected field from source HTTPProbingConfig
func (fps *HTTPProbingConfig_FieldSubPath) GetSingle(source *HTTPProbingConfig) (interface{}, bool) {
	switch fps.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		if source.GetHttpRequest() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetHttpRequest())
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		if source.GetAuthConfig() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetAuthConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fps.selector))
	}
}

func (fps *HTTPProbingConfig_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*HTTPProbingConfig))
}

// GetDefault returns a default value of the field type
func (fps *HTTPProbingConfig_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *HTTPProbingConfig_FieldSubPath) ClearValue(item *HTTPProbingConfig) {
	if item != nil {
		switch fps.selector {
		case HTTPProbingConfig_FieldPathSelectorHttpRequest:
			fps.subPath.ClearValueRaw(item.HttpRequest)
		case HTTPProbingConfig_FieldPathSelectorAuthConfig:
			fps.subPath.ClearValueRaw(item.AuthConfig)
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fps.selector))
		}
	}
}

func (fps *HTTPProbingConfig_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*HTTPProbingConfig))
}

// IsLeaf - whether field path is holds simple value
func (fps *HTTPProbingConfig_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *HTTPProbingConfig_FieldSubPath) WithIValue(value interface{}) HTTPProbingConfig_FieldPathValue {
	return &HTTPProbingConfig_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *HTTPProbingConfig_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *HTTPProbingConfig_FieldSubPath) WithIArrayOfValues(values interface{}) HTTPProbingConfig_FieldPathArrayOfValues {
	return &HTTPProbingConfig_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *HTTPProbingConfig_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *HTTPProbingConfig_FieldSubPath) WithIArrayItemValue(value interface{}) HTTPProbingConfig_FieldPathArrayItemValue {
	return &HTTPProbingConfig_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *HTTPProbingConfig_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// HTTPProbingConfig_FieldPathValue allows storing values for HTTPProbingConfig fields according to their type
type HTTPProbingConfig_FieldPathValue interface {
	HTTPProbingConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **HTTPProbingConfig)
	CompareWith(*HTTPProbingConfig) (cmp int, comparable bool)
}

func ParseHTTPProbingConfig_FieldPathValue(pathStr, valueStr string) (HTTPProbingConfig_FieldPathValue, error) {
	fp, err := ParseHTTPProbingConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPProbingConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(HTTPProbingConfig_FieldPathValue), nil
}

func MustParseHTTPProbingConfig_FieldPathValue(pathStr, valueStr string) HTTPProbingConfig_FieldPathValue {
	fpv, err := ParseHTTPProbingConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type HTTPProbingConfig_FieldTerminalPathValue struct {
	HTTPProbingConfig_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfig_FieldPathValue = (*HTTPProbingConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'HTTPProbingConfig' as interface{}
func (fpv *HTTPProbingConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *HTTPProbingConfig_FieldTerminalPathValue) AsHttpRequestValue() (*HTTPProbingConfig_HTTPRequest, bool) {
	res, ok := fpv.value.(*HTTPProbingConfig_HTTPRequest)
	return res, ok
}
func (fpv *HTTPProbingConfig_FieldTerminalPathValue) AsAuthConfigValue() (*HTTPProbingConfig_HTTPAuth, bool) {
	res, ok := fpv.value.(*HTTPProbingConfig_HTTPAuth)
	return res, ok
}

// SetTo stores value for selected field for object HTTPProbingConfig
func (fpv *HTTPProbingConfig_FieldTerminalPathValue) SetTo(target **HTTPProbingConfig) {
	if *target == nil {
		*target = new(HTTPProbingConfig)
	}
	switch fpv.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		(*target).HttpRequest = fpv.value.(*HTTPProbingConfig_HTTPRequest)
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		(*target).AuthConfig = fpv.value.(*HTTPProbingConfig_HTTPAuth)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HTTPProbingConfig_FieldTerminalPathValue' with the value under path in 'HTTPProbingConfig'.
func (fpv *HTTPProbingConfig_FieldTerminalPathValue) CompareWith(source *HTTPProbingConfig) (int, bool) {
	switch fpv.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return 0, false
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*HTTPProbingConfig))
}

type HTTPProbingConfig_FieldSubPathValue struct {
	HTTPProbingConfig_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ HTTPProbingConfig_FieldPathValue = (*HTTPProbingConfig_FieldSubPathValue)(nil)

func (fpvs *HTTPProbingConfig_FieldSubPathValue) AsHttpRequestPathValue() (HTTPProbingConfigHTTPRequest_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue)
	return res, ok
}
func (fpvs *HTTPProbingConfig_FieldSubPathValue) AsAuthConfigPathValue() (HTTPProbingConfigHTTPAuth_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(HTTPProbingConfigHTTPAuth_FieldPathValue)
	return res, ok
}

func (fpvs *HTTPProbingConfig_FieldSubPathValue) SetTo(target **HTTPProbingConfig) {
	if *target == nil {
		*target = new(HTTPProbingConfig)
	}
	switch fpvs.Selector() {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue).SetTo(&(*target).HttpRequest)
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		fpvs.subPathValue.(HTTPProbingConfigHTTPAuth_FieldPathValue).SetTo(&(*target).AuthConfig)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *HTTPProbingConfig_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig)
	fpvs.SetTo(&typedObject)
}

func (fpvs *HTTPProbingConfig_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *HTTPProbingConfig_FieldSubPathValue) CompareWith(source *HTTPProbingConfig) (int, bool) {
	switch fpvs.Selector() {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue).CompareWith(source.GetHttpRequest())
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return fpvs.subPathValue.(HTTPProbingConfigHTTPAuth_FieldPathValue).CompareWith(source.GetAuthConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *HTTPProbingConfig_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*HTTPProbingConfig))
}

// HTTPProbingConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for HTTPProbingConfig according to their type
// Present only for array (repeated) types.
type HTTPProbingConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	HTTPProbingConfig_FieldPath
	ContainsValue(*HTTPProbingConfig) bool
}

// ParseHTTPProbingConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseHTTPProbingConfig_FieldPathArrayItemValue(pathStr, valueStr string) (HTTPProbingConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseHTTPProbingConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPProbingConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(HTTPProbingConfig_FieldPathArrayItemValue), nil
}

func MustParseHTTPProbingConfig_FieldPathArrayItemValue(pathStr, valueStr string) HTTPProbingConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseHTTPProbingConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type HTTPProbingConfig_FieldTerminalPathArrayItemValue struct {
	HTTPProbingConfig_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfig_FieldPathArrayItemValue = (*HTTPProbingConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object HTTPProbingConfig as interface{}
func (fpaiv *HTTPProbingConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *HTTPProbingConfig_FieldTerminalPathArrayItemValue) GetSingle(source *HTTPProbingConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *HTTPProbingConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*HTTPProbingConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'HTTPProbingConfig'
func (fpaiv *HTTPProbingConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *HTTPProbingConfig) bool {
	slice := fpaiv.HTTPProbingConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type HTTPProbingConfig_FieldSubPathArrayItemValue struct {
	HTTPProbingConfig_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *HTTPProbingConfig_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *HTTPProbingConfig_FieldSubPathArrayItemValue) AsHttpRequestPathItemValue() (HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *HTTPProbingConfig_FieldSubPathArrayItemValue) AsAuthConfigPathItemValue() (HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'HTTPProbingConfig'
func (fpaivs *HTTPProbingConfig_FieldSubPathArrayItemValue) ContainsValue(source *HTTPProbingConfig) bool {
	switch fpaivs.Selector() {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		return fpaivs.subPathItemValue.(HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue).ContainsValue(source.GetHttpRequest())
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		return fpaivs.subPathItemValue.(HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue).ContainsValue(source.GetAuthConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig: %d", fpaivs.Selector()))
	}
}

// HTTPProbingConfig_FieldPathArrayOfValues allows storing slice of values for HTTPProbingConfig fields according to their type
type HTTPProbingConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	HTTPProbingConfig_FieldPath
}

func ParseHTTPProbingConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (HTTPProbingConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseHTTPProbingConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPProbingConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(HTTPProbingConfig_FieldPathArrayOfValues), nil
}

func MustParseHTTPProbingConfig_FieldPathArrayOfValues(pathStr, valuesStr string) HTTPProbingConfig_FieldPathArrayOfValues {
	fpaov, err := ParseHTTPProbingConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type HTTPProbingConfig_FieldTerminalPathArrayOfValues struct {
	HTTPProbingConfig_FieldTerminalPath
	values interface{}
}

var _ HTTPProbingConfig_FieldPathArrayOfValues = (*HTTPProbingConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *HTTPProbingConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case HTTPProbingConfig_FieldPathSelectorHttpRequest:
		for _, v := range fpaov.values.([]*HTTPProbingConfig_HTTPRequest) {
			values = append(values, v)
		}
	case HTTPProbingConfig_FieldPathSelectorAuthConfig:
		for _, v := range fpaov.values.([]*HTTPProbingConfig_HTTPAuth) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *HTTPProbingConfig_FieldTerminalPathArrayOfValues) AsHttpRequestArrayOfValues() ([]*HTTPProbingConfig_HTTPRequest, bool) {
	res, ok := fpaov.values.([]*HTTPProbingConfig_HTTPRequest)
	return res, ok
}
func (fpaov *HTTPProbingConfig_FieldTerminalPathArrayOfValues) AsAuthConfigArrayOfValues() ([]*HTTPProbingConfig_HTTPAuth, bool) {
	res, ok := fpaov.values.([]*HTTPProbingConfig_HTTPAuth)
	return res, ok
}

type HTTPProbingConfig_FieldSubPathArrayOfValues struct {
	HTTPProbingConfig_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ HTTPProbingConfig_FieldPathArrayOfValues = (*HTTPProbingConfig_FieldSubPathArrayOfValues)(nil)

func (fpsaov *HTTPProbingConfig_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *HTTPProbingConfig_FieldSubPathArrayOfValues) AsHttpRequestPathArrayOfValues() (HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *HTTPProbingConfig_FieldSubPathArrayOfValues) AsAuthConfigPathArrayOfValues() (HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type HTTPProbingConfigHTTPRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() HTTPProbingConfigHTTPRequest_FieldPathSelector
	Get(source *HTTPProbingConfig_HTTPRequest) []interface{}
	GetSingle(source *HTTPProbingConfig_HTTPRequest) (interface{}, bool)
	ClearValue(item *HTTPProbingConfig_HTTPRequest)

	// Those methods build corresponding HTTPProbingConfigHTTPRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue
}

type HTTPProbingConfigHTTPRequest_FieldPathSelector int32

const (
	HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl                  HTTPProbingConfigHTTPRequest_FieldPathSelector = 0
	HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders       HTTPProbingConfigHTTPRequest_FieldPathSelector = 1
	HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod        HTTPProbingConfigHTTPRequest_FieldPathSelector = 2
	HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode HTTPProbingConfigHTTPRequest_FieldPathSelector = 3
	HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout              HTTPProbingConfigHTTPRequest_FieldPathSelector = 4
	HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody          HTTPProbingConfigHTTPRequest_FieldPathSelector = 5
	HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod HTTPProbingConfigHTTPRequest_FieldPathSelector = 6
	HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody   HTTPProbingConfigHTTPRequest_FieldPathSelector = 7
)

func (s HTTPProbingConfigHTTPRequest_FieldPathSelector) String() string {
	switch s {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		return "url"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return "request_headers"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		return "request_method"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		return "expected_response_code"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		return "timeout"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		return "request_body"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		return "authentication_method"
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return "url_form_encoded_body"
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", s))
	}
}

func BuildHTTPProbingConfigHTTPRequest_FieldPath(fp gotenobject.RawFieldPath) (HTTPProbingConfigHTTPRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object HTTPProbingConfig_HTTPRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "url":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl}, nil
		case "request_headers", "requestHeaders", "request-headers":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders}, nil
		case "request_method", "requestMethod", "request-method":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod}, nil
		case "expected_response_code", "expectedResponseCode", "expected-response-code":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode}, nil
		case "timeout":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout}, nil
		case "request_body", "requestBody", "request-body":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody}, nil
		case "authentication_method", "authenticationMethod", "authentication-method":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod}, nil
		case "url_form_encoded_body", "urlFormEncodedBody", "url-form-encoded-body":
			return &HTTPProbingConfigHTTPRequest_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody}, nil
		}
	} else {
		switch fp[0] {
		case "request_headers", "requestHeaders", "request-headers":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object HTTPProbingConfig_HTTPRequest)", fp)
			}
			return &HTTPProbingConfigHTTPRequest_FieldPathMap{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders, key: fp[1]}, nil
		case "url_form_encoded_body", "urlFormEncodedBody", "url-form-encoded-body":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object HTTPProbingConfig_HTTPRequest)", fp)
			}
			return &HTTPProbingConfigHTTPRequest_FieldPathMap{selector: HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object HTTPProbingConfig_HTTPRequest", fp)
}

func ParseHTTPProbingConfigHTTPRequest_FieldPath(rawField string) (HTTPProbingConfigHTTPRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildHTTPProbingConfigHTTPRequest_FieldPath(fp)
}

func MustParseHTTPProbingConfigHTTPRequest_FieldPath(rawField string) HTTPProbingConfigHTTPRequest_FieldPath {
	fp, err := ParseHTTPProbingConfigHTTPRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type HTTPProbingConfigHTTPRequest_FieldTerminalPath struct {
	selector HTTPProbingConfigHTTPRequest_FieldPathSelector
}

var _ HTTPProbingConfigHTTPRequest_FieldPath = (*HTTPProbingConfigHTTPRequest_FieldTerminalPath)(nil)

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) Selector() HTTPProbingConfigHTTPRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source HTTPProbingConfig_HTTPRequest
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) Get(source *HTTPProbingConfig_HTTPRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
			values = append(values, source.Url)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
			values = append(values, source.RequestHeaders)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
			values = append(values, source.RequestMethod)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
			values = append(values, source.ExpectedResponseCode)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
			if source.Timeout != nil {
				values = append(values, source.Timeout)
			}
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
			values = append(values, source.RequestBody)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
			values = append(values, source.AuthenticationMethod)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
			if source.UrlFormEncodedBody != nil {
				values = append(values, source.UrlFormEncodedBody)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*HTTPProbingConfig_HTTPRequest))
}

// GetSingle returns value pointed by specific field of from source HTTPProbingConfig_HTTPRequest
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) GetSingle(source *HTTPProbingConfig_HTTPRequest) (interface{}, bool) {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		return source.GetUrl(), source != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		res := source.GetRequestHeaders()
		return res, res != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		return source.GetRequestMethod(), source != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		return source.GetExpectedResponseCode(), source != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		res := source.GetTimeout()
		return res, res != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		return source.GetRequestBody(), source != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		return source.GetAuthenticationMethod(), source != nil
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		res := source.GetUrlFormEncodedBody()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*HTTPProbingConfig_HTTPRequest))
}

// GetDefault returns a default value of the field type
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		return ""
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return (map[string]string)(nil)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		return HTTPRequestMethod_GET
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		return uint32(0)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		return (*duration.Duration)(nil)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		return ""
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		return AuthenticationMethod_NO_AUTH
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return (map[string]*HTTPProbingConfig_HTTPRequest_StringArray)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) ClearValue(item *HTTPProbingConfig_HTTPRequest) {
	if item != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
			item.Url = ""
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
			item.RequestHeaders = nil
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
			item.RequestMethod = HTTPRequestMethod_GET
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
			item.ExpectedResponseCode = uint32(0)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
			item.Timeout = nil
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
			item.RequestBody = ""
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
			item.AuthenticationMethod = AuthenticationMethod_NO_AUTH
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
			item.UrlFormEncodedBody = nil
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
		}
	}
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*HTTPProbingConfig_HTTPRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody ||
		fp.selector == HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithIValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathValue {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(HTTPRequestMethod)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(uint32)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(*duration.Duration)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(AuthenticationMethod)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathValue{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, value: value.(map[string]*HTTPProbingConfig_HTTPRequest_StringArray)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues {
	fpaov := &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]HTTPRequestMethod)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]uint32)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]*duration.Duration)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]AuthenticationMethod)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return &HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequest_FieldTerminalPath: *fp, values: values.([]map[string]*HTTPProbingConfig_HTTPRequest_StringArray)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type HTTPProbingConfigHTTPRequest_FieldPathMap struct {
	key      string
	selector HTTPProbingConfigHTTPRequest_FieldPathSelector
}

var _ HTTPProbingConfigHTTPRequest_FieldPath = (*HTTPProbingConfigHTTPRequest_FieldPathMap)(nil)

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) Selector() HTTPProbingConfigHTTPRequest_FieldPathSelector {
	return fpm.selector
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source HTTPProbingConfig_HTTPRequest
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) Get(source *HTTPProbingConfig_HTTPRequest) (values []interface{}) {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		if value, ok := source.GetRequestHeaders()[fpm.key]; ok {
			values = append(values, value)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		if value, ok := source.GetUrlFormEncodedBody()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
	return
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*HTTPProbingConfig_HTTPRequest))
}

// GetSingle returns value by selected field map key from source HTTPProbingConfig_HTTPRequest
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) GetSingle(source *HTTPProbingConfig_HTTPRequest) (interface{}, bool) {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		res, ok := source.GetRequestHeaders()[fpm.key]
		return res, ok
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		res, ok := source.GetUrlFormEncodedBody()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*HTTPProbingConfig_HTTPRequest))
}

// GetDefault returns a default value of the field type
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		var v string
		return v
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		var v *HTTPProbingConfig_HTTPRequest_StringArray
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) ClearValue(item *HTTPProbingConfig_HTTPRequest) {
	if item != nil {
		switch fpm.selector {
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
			delete(item.RequestHeaders, fpm.key)
		case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
			delete(item.UrlFormEncodedBody, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
		}
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*HTTPProbingConfig_HTTPRequest))
}

// IsLeaf - whether field path is holds simple value
func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return true
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithIValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathValue {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return &HTTPProbingConfigHTTPRequest_FieldPathMapValue{HTTPProbingConfigHTTPRequest_FieldPathMap: *fpm, value: value.(string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return &HTTPProbingConfigHTTPRequest_FieldPathMapValue{HTTPProbingConfigHTTPRequest_FieldPathMap: *fpm, value: value.(*HTTPProbingConfig_HTTPRequest_StringArray)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues {
	switch fpm.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return &HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues{HTTPProbingConfigHTTPRequest_FieldPathMap: *fpm, values: values.([]string)}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return &HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues{HTTPProbingConfigHTTPRequest_FieldPathMap: *fpm, values: values.([]*HTTPProbingConfig_HTTPRequest_StringArray)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpm.selector))
	}
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *HTTPProbingConfigHTTPRequest_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// HTTPProbingConfigHTTPRequest_FieldPathValue allows storing values for HTTPRequest fields according to their type
type HTTPProbingConfigHTTPRequest_FieldPathValue interface {
	HTTPProbingConfigHTTPRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **HTTPProbingConfig_HTTPRequest)
	CompareWith(*HTTPProbingConfig_HTTPRequest) (cmp int, comparable bool)
}

func ParseHTTPProbingConfigHTTPRequest_FieldPathValue(pathStr, valueStr string) (HTTPProbingConfigHTTPRequest_FieldPathValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(HTTPProbingConfigHTTPRequest_FieldPathValue), nil
}

func MustParseHTTPProbingConfigHTTPRequest_FieldPathValue(pathStr, valueStr string) HTTPProbingConfigHTTPRequest_FieldPathValue {
	fpv, err := ParseHTTPProbingConfigHTTPRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type HTTPProbingConfigHTTPRequest_FieldTerminalPathValue struct {
	HTTPProbingConfigHTTPRequest_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPRequest_FieldPathValue = (*HTTPProbingConfigHTTPRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'HTTPRequest' as interface{}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsUrlValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsRequestHeadersValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsRequestMethodValue() (HTTPRequestMethod, bool) {
	res, ok := fpv.value.(HTTPRequestMethod)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsExpectedResponseCodeValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsTimeoutValue() (*duration.Duration, bool) {
	res, ok := fpv.value.(*duration.Duration)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsRequestBodyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsAuthenticationMethodValue() (AuthenticationMethod, bool) {
	res, ok := fpv.value.(AuthenticationMethod)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) AsUrlFormEncodedBodyValue() (map[string]*HTTPProbingConfig_HTTPRequest_StringArray, bool) {
	res, ok := fpv.value.(map[string]*HTTPProbingConfig_HTTPRequest_StringArray)
	return res, ok
}

// SetTo stores value for selected field for object HTTPRequest
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) SetTo(target **HTTPProbingConfig_HTTPRequest) {
	if *target == nil {
		*target = new(HTTPProbingConfig_HTTPRequest)
	}
	switch fpv.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		(*target).Url = fpv.value.(string)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		(*target).RequestHeaders = fpv.value.(map[string]string)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		(*target).RequestMethod = fpv.value.(HTTPRequestMethod)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		(*target).ExpectedResponseCode = fpv.value.(uint32)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		(*target).Timeout = fpv.value.(*duration.Duration)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		(*target).RequestBody = fpv.value.(string)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		(*target).AuthenticationMethod = fpv.value.(AuthenticationMethod)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		(*target).UrlFormEncodedBody = fpv.value.(map[string]*HTTPProbingConfig_HTTPRequest_StringArray)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig_HTTPRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HTTPProbingConfigHTTPRequest_FieldTerminalPathValue' with the value under path in 'HTTPProbingConfig_HTTPRequest'.
func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) CompareWith(source *HTTPProbingConfig_HTTPRequest) (int, bool) {
	switch fpv.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		leftValue := fpv.value.(string)
		rightValue := source.GetUrl()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		return 0, false
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		leftValue := fpv.value.(HTTPRequestMethod)
		rightValue := source.GetRequestMethod()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetExpectedResponseCode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		leftValue := fpv.value.(*duration.Duration)
		rightValue := source.GetTimeout()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		leftValue := fpv.value.(string)
		rightValue := source.GetRequestBody()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		leftValue := fpv.value.(AuthenticationMethod)
		rightValue := source.GetAuthenticationMethod()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*HTTPProbingConfig_HTTPRequest))
}

type HTTPProbingConfigHTTPRequest_FieldPathMapValue struct {
	HTTPProbingConfigHTTPRequest_FieldPathMap
	value interface{}
}

var _ HTTPProbingConfigHTTPRequest_FieldPathValue = (*HTTPProbingConfigHTTPRequest_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in HTTPRequest as interface{}
func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) AsRequestHeadersElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}
func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) AsUrlFormEncodedBodyElementValue() (*HTTPProbingConfig_HTTPRequest_StringArray, bool) {
	res, ok := fpmv.value.(*HTTPProbingConfig_HTTPRequest_StringArray)
	return res, ok
}

// SetTo stores value for selected field in HTTPRequest
func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) SetTo(target **HTTPProbingConfig_HTTPRequest) {
	if *target == nil {
		*target = new(HTTPProbingConfig_HTTPRequest)
	}
	switch fpmv.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		if (*target).RequestHeaders == nil {
			(*target).RequestHeaders = make(map[string]string)
		}
		(*target).RequestHeaders[fpmv.key] = fpmv.value.(string)
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		if (*target).UrlFormEncodedBody == nil {
			(*target).UrlFormEncodedBody = make(map[string]*HTTPProbingConfig_HTTPRequest_StringArray)
		}
		(*target).UrlFormEncodedBody[fpmv.key] = fpmv.value.(*HTTPProbingConfig_HTTPRequest_StringArray)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpmv.selector))
	}
}

func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig_HTTPRequest)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HTTPProbingConfigHTTPRequest_FieldPathMapValue' with the value under path in 'HTTPProbingConfig_HTTPRequest'.
func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) CompareWith(source *HTTPProbingConfig_HTTPRequest) (int, bool) {
	switch fpmv.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		leftValue := fpmv.value.(string)
		rightValue := source.GetRequestHeaders()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest: %d", fpmv.selector))
	}
}

func (fpmv *HTTPProbingConfigHTTPRequest_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*HTTPProbingConfig_HTTPRequest))
}

// HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for HTTPRequest according to their type
// Present only for array (repeated) types.
type HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	HTTPProbingConfigHTTPRequest_FieldPath
	ContainsValue(*HTTPProbingConfig_HTTPRequest) bool
}

// ParseHTTPProbingConfigHTTPRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseHTTPProbingConfigHTTPRequest_FieldPathArrayItemValue(pathStr, valueStr string) (HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue), nil
}

func MustParseHTTPProbingConfigHTTPRequest_FieldPathArrayItemValue(pathStr, valueStr string) HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseHTTPProbingConfigHTTPRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue struct {
	HTTPProbingConfigHTTPRequest_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue = (*HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object HTTPProbingConfig_HTTPRequest as interface{}
func (fpaiv *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue) GetSingle(source *HTTPProbingConfig_HTTPRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*HTTPProbingConfig_HTTPRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'HTTPRequest'
func (fpaiv *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *HTTPProbingConfig_HTTPRequest) bool {
	slice := fpaiv.HTTPProbingConfigHTTPRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues allows storing slice of values for HTTPRequest fields according to their type
type HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	HTTPProbingConfigHTTPRequest_FieldPath
}

func ParseHTTPProbingConfigHTTPRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues), nil
}

func MustParseHTTPProbingConfigHTTPRequest_FieldPathArrayOfValues(pathStr, valuesStr string) HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues {
	fpaov, err := ParseHTTPProbingConfigHTTPRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues struct {
	HTTPProbingConfigHTTPRequest_FieldTerminalPath
	values interface{}
}

var _ HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues = (*HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrl:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestMethod:
		for _, v := range fpaov.values.([]HTTPRequestMethod) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorExpectedResponseCode:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorTimeout:
		for _, v := range fpaov.values.([]*duration.Duration) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestBody:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorAuthenticationMethod:
		for _, v := range fpaov.values.([]AuthenticationMethod) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		for _, v := range fpaov.values.([]map[string]*HTTPProbingConfig_HTTPRequest_StringArray) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsUrlArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsRequestHeadersArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsRequestMethodArrayOfValues() ([]HTTPRequestMethod, bool) {
	res, ok := fpaov.values.([]HTTPRequestMethod)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsExpectedResponseCodeArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsTimeoutArrayOfValues() ([]*duration.Duration, bool) {
	res, ok := fpaov.values.([]*duration.Duration)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsRequestBodyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsAuthenticationMethodArrayOfValues() ([]AuthenticationMethod, bool) {
	res, ok := fpaov.values.([]AuthenticationMethod)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPRequest_FieldTerminalPathArrayOfValues) AsUrlFormEncodedBodyArrayOfValues() ([]map[string]*HTTPProbingConfig_HTTPRequest_StringArray, bool) {
	res, ok := fpaov.values.([]map[string]*HTTPProbingConfig_HTTPRequest_StringArray)
	return res, ok
}

type HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues struct {
	HTTPProbingConfigHTTPRequest_FieldPathMap
	values interface{}
}

var _ HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues = (*HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues)(nil)

func (fpmaov *HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorRequestHeaders:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPRequest_FieldPathSelectorUrlFormEncodedBody:
		for _, v := range fpmaov.values.([]*HTTPProbingConfig_HTTPRequest_StringArray) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues) AsRequestHeadersArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}
func (fpmaov *HTTPProbingConfigHTTPRequest_FieldPathMapArrayOfValues) AsUrlFormEncodedBodyArrayOfElementValues() ([]*HTTPProbingConfig_HTTPRequest_StringArray, bool) {
	res, ok := fpmaov.values.([]*HTTPProbingConfig_HTTPRequest_StringArray)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type HTTPProbingConfigHTTPAuth_FieldPath interface {
	gotenobject.FieldPath
	Selector() HTTPProbingConfigHTTPAuth_FieldPathSelector
	Get(source *HTTPProbingConfig_HTTPAuth) []interface{}
	GetSingle(source *HTTPProbingConfig_HTTPAuth) (interface{}, bool)
	ClearValue(item *HTTPProbingConfig_HTTPAuth)

	// Those methods build corresponding HTTPProbingConfigHTTPAuth_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathValue
	WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue
}

type HTTPProbingConfigHTTPAuth_FieldPathSelector int32

const (
	HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername                   HTTPProbingConfigHTTPAuth_FieldPathSelector = 0
	HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword                   HTTPProbingConfigHTTPAuth_FieldPathSelector = 1
	HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest               HTTPProbingConfigHTTPAuth_FieldPathSelector = 2
	HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader        HTTPProbingConfigHTTPAuth_FieldPathSelector = 3
	HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey       HTTPProbingConfigHTTPAuth_FieldPathSelector = 4
	HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey      HTTPProbingConfigHTTPAuth_FieldPathSelector = 5
	HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey HTTPProbingConfigHTTPAuth_FieldPathSelector = 6
)

func (s HTTPProbingConfigHTTPAuth_FieldPathSelector) String() string {
	switch s {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		return "username"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		return "password"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return "token_request"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		return "token_response_header"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		return "token_response_body_key"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		return "request_header_token_key"
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		return "token_response_body_expiry_key"
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", s))
	}
}

func BuildHTTPProbingConfigHTTPAuth_FieldPath(fp gotenobject.RawFieldPath) (HTTPProbingConfigHTTPAuth_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object HTTPProbingConfig_HTTPAuth")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "username":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername}, nil
		case "password":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword}, nil
		case "token_request", "tokenRequest", "token-request":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest}, nil
		case "token_response_header", "tokenResponseHeader", "token-response-header":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader}, nil
		case "token_response_body_key", "tokenResponseBodyKey", "token-response-body-key":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey}, nil
		case "request_header_token_key", "requestHeaderTokenKey", "request-header-token-key":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey}, nil
		case "token_response_body_expiry_key", "tokenResponseBodyExpiryKey", "token-response-body-expiry-key":
			return &HTTPProbingConfigHTTPAuth_FieldTerminalPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey}, nil
		}
	} else {
		switch fp[0] {
		case "token_request", "tokenRequest", "token-request":
			if subpath, err := BuildHTTPProbingConfigHTTPRequest_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &HTTPProbingConfigHTTPAuth_FieldSubPath{selector: HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object HTTPProbingConfig_HTTPAuth", fp)
}

func ParseHTTPProbingConfigHTTPAuth_FieldPath(rawField string) (HTTPProbingConfigHTTPAuth_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildHTTPProbingConfigHTTPAuth_FieldPath(fp)
}

func MustParseHTTPProbingConfigHTTPAuth_FieldPath(rawField string) HTTPProbingConfigHTTPAuth_FieldPath {
	fp, err := ParseHTTPProbingConfigHTTPAuth_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type HTTPProbingConfigHTTPAuth_FieldTerminalPath struct {
	selector HTTPProbingConfigHTTPAuth_FieldPathSelector
}

var _ HTTPProbingConfigHTTPAuth_FieldPath = (*HTTPProbingConfigHTTPAuth_FieldTerminalPath)(nil)

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) Selector() HTTPProbingConfigHTTPAuth_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source HTTPProbingConfig_HTTPAuth
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) Get(source *HTTPProbingConfig_HTTPAuth) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
			values = append(values, source.Username)
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
			values = append(values, source.Password)
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
			if source.TokenRequest != nil {
				values = append(values, source.TokenRequest)
			}
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
			values = append(values, source.TokenResponseHeader)
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
			values = append(values, source.TokenResponseBodyKey)
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
			values = append(values, source.RequestHeaderTokenKey)
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
			values = append(values, source.TokenResponseBodyExpiryKey)
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
		}
	}
	return
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*HTTPProbingConfig_HTTPAuth))
}

// GetSingle returns value pointed by specific field of from source HTTPProbingConfig_HTTPAuth
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) GetSingle(source *HTTPProbingConfig_HTTPAuth) (interface{}, bool) {
	switch fp.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		return source.GetUsername(), source != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		return source.GetPassword(), source != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		res := source.GetTokenRequest()
		return res, res != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		return source.GetTokenResponseHeader(), source != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		return source.GetTokenResponseBodyKey(), source != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		return source.GetRequestHeaderTokenKey(), source != nil
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		return source.GetTokenResponseBodyExpiryKey(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*HTTPProbingConfig_HTTPAuth))
}

// GetDefault returns a default value of the field type
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		return ""
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		return ""
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return (*HTTPProbingConfig_HTTPRequest)(nil)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		return ""
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		return ""
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		return ""
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) ClearValue(item *HTTPProbingConfig_HTTPAuth) {
	if item != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
			item.Username = ""
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
			item.Password = ""
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
			item.TokenRequest = nil
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
			item.TokenResponseHeader = ""
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
			item.TokenResponseBodyKey = ""
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
			item.RequestHeaderTokenKey = ""
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
			item.TokenResponseBodyExpiryKey = ""
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
		}
	}
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*HTTPProbingConfig_HTTPAuth))
}

// IsLeaf - whether field path is holds simple value
func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername ||
		fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword ||
		fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader ||
		fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey ||
		fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey ||
		fp.selector == HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithIValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathValue {
	switch fp.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(*HTTPProbingConfig_HTTPRequest)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathValue{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues {
	fpaov := &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp}
	switch fp.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]*HTTPProbingConfig_HTTPRequest)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		return &HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPAuth_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
	}
	return fpaov
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPAuth_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type HTTPProbingConfigHTTPAuth_FieldSubPath struct {
	selector HTTPProbingConfigHTTPAuth_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ HTTPProbingConfigHTTPAuth_FieldPath = (*HTTPProbingConfigHTTPAuth_FieldSubPath)(nil)

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) Selector() HTTPProbingConfigHTTPAuth_FieldPathSelector {
	return fps.selector
}
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) AsTokenRequestSubPath() (HTTPProbingConfigHTTPRequest_FieldPath, bool) {
	res, ok := fps.subPath.(HTTPProbingConfigHTTPRequest_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source HTTPProbingConfig_HTTPAuth
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) Get(source *HTTPProbingConfig_HTTPAuth) (values []interface{}) {
	if asHTTPRequestFieldPath, ok := fps.AsTokenRequestSubPath(); ok {
		values = append(values, asHTTPRequestFieldPath.Get(source.GetTokenRequest())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fps.selector))
	}
	return
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*HTTPProbingConfig_HTTPAuth))
}

// GetSingle returns value of selected field from source HTTPProbingConfig_HTTPAuth
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) GetSingle(source *HTTPProbingConfig_HTTPAuth) (interface{}, bool) {
	switch fps.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		if source.GetTokenRequest() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetTokenRequest())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fps.selector))
	}
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*HTTPProbingConfig_HTTPAuth))
}

// GetDefault returns a default value of the field type
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) ClearValue(item *HTTPProbingConfig_HTTPAuth) {
	if item != nil {
		switch fps.selector {
		case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
			fps.subPath.ClearValueRaw(item.TokenRequest)
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fps.selector))
		}
	}
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*HTTPProbingConfig_HTTPAuth))
}

// IsLeaf - whether field path is holds simple value
func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithIValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathValue {
	return &HTTPProbingConfigHTTPAuth_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues {
	return &HTTPProbingConfigHTTPAuth_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue {
	return &HTTPProbingConfigHTTPAuth_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *HTTPProbingConfigHTTPAuth_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// HTTPProbingConfigHTTPAuth_FieldPathValue allows storing values for HTTPAuth fields according to their type
type HTTPProbingConfigHTTPAuth_FieldPathValue interface {
	HTTPProbingConfigHTTPAuth_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **HTTPProbingConfig_HTTPAuth)
	CompareWith(*HTTPProbingConfig_HTTPAuth) (cmp int, comparable bool)
}

func ParseHTTPProbingConfigHTTPAuth_FieldPathValue(pathStr, valueStr string) (HTTPProbingConfigHTTPAuth_FieldPathValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPAuth_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPAuth field path value from %s: %v", valueStr, err)
	}
	return fpv.(HTTPProbingConfigHTTPAuth_FieldPathValue), nil
}

func MustParseHTTPProbingConfigHTTPAuth_FieldPathValue(pathStr, valueStr string) HTTPProbingConfigHTTPAuth_FieldPathValue {
	fpv, err := ParseHTTPProbingConfigHTTPAuth_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type HTTPProbingConfigHTTPAuth_FieldTerminalPathValue struct {
	HTTPProbingConfigHTTPAuth_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPAuth_FieldPathValue = (*HTTPProbingConfigHTTPAuth_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'HTTPAuth' as interface{}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsUsernameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsPasswordValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsTokenRequestValue() (*HTTPProbingConfig_HTTPRequest, bool) {
	res, ok := fpv.value.(*HTTPProbingConfig_HTTPRequest)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsTokenResponseHeaderValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsTokenResponseBodyKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsRequestHeaderTokenKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) AsTokenResponseBodyExpiryKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object HTTPAuth
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) SetTo(target **HTTPProbingConfig_HTTPAuth) {
	if *target == nil {
		*target = new(HTTPProbingConfig_HTTPAuth)
	}
	switch fpv.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		(*target).Username = fpv.value.(string)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		(*target).Password = fpv.value.(string)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		(*target).TokenRequest = fpv.value.(*HTTPProbingConfig_HTTPRequest)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		(*target).TokenResponseHeader = fpv.value.(string)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		(*target).TokenResponseBodyKey = fpv.value.(string)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		(*target).RequestHeaderTokenKey = fpv.value.(string)
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		(*target).TokenResponseBodyExpiryKey = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig_HTTPAuth)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HTTPProbingConfigHTTPAuth_FieldTerminalPathValue' with the value under path in 'HTTPProbingConfig_HTTPAuth'.
func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) CompareWith(source *HTTPProbingConfig_HTTPAuth) (int, bool) {
	switch fpv.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		leftValue := fpv.value.(string)
		rightValue := source.GetUsername()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		leftValue := fpv.value.(string)
		rightValue := source.GetPassword()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return 0, false
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		leftValue := fpv.value.(string)
		rightValue := source.GetTokenResponseHeader()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetTokenResponseBodyKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetRequestHeaderTokenKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetTokenResponseBodyExpiryKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPAuth_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*HTTPProbingConfig_HTTPAuth))
}

type HTTPProbingConfigHTTPAuth_FieldSubPathValue struct {
	HTTPProbingConfigHTTPAuth_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ HTTPProbingConfigHTTPAuth_FieldPathValue = (*HTTPProbingConfigHTTPAuth_FieldSubPathValue)(nil)

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) AsTokenRequestPathValue() (HTTPProbingConfigHTTPRequest_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue)
	return res, ok
}

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) SetTo(target **HTTPProbingConfig_HTTPAuth) {
	if *target == nil {
		*target = new(HTTPProbingConfig_HTTPAuth)
	}
	switch fpvs.Selector() {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue).SetTo(&(*target).TokenRequest)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fpvs.Selector()))
	}
}

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig_HTTPAuth)
	fpvs.SetTo(&typedObject)
}

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) CompareWith(source *HTTPProbingConfig_HTTPAuth) (int, bool) {
	switch fpvs.Selector() {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return fpvs.subPathValue.(HTTPProbingConfigHTTPRequest_FieldPathValue).CompareWith(source.GetTokenRequest())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fpvs.Selector()))
	}
}

func (fpvs *HTTPProbingConfigHTTPAuth_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*HTTPProbingConfig_HTTPAuth))
}

// HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue allows storing single item in Path-specific values for HTTPAuth according to their type
// Present only for array (repeated) types.
type HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	HTTPProbingConfigHTTPAuth_FieldPath
	ContainsValue(*HTTPProbingConfig_HTTPAuth) bool
}

// ParseHTTPProbingConfigHTTPAuth_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseHTTPProbingConfigHTTPAuth_FieldPathArrayItemValue(pathStr, valueStr string) (HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPAuth_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPAuth field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue), nil
}

func MustParseHTTPProbingConfigHTTPAuth_FieldPathArrayItemValue(pathStr, valueStr string) HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue {
	fpaiv, err := ParseHTTPProbingConfigHTTPAuth_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue struct {
	HTTPProbingConfigHTTPAuth_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPAuth_FieldPathArrayItemValue = (*HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object HTTPProbingConfig_HTTPAuth as interface{}
func (fpaiv *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue) GetSingle(source *HTTPProbingConfig_HTTPAuth) (interface{}, bool) {
	return nil, false
}

func (fpaiv *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*HTTPProbingConfig_HTTPAuth))
}

// Contains returns a boolean indicating if value that is being held is present in given 'HTTPAuth'
func (fpaiv *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayItemValue) ContainsValue(source *HTTPProbingConfig_HTTPAuth) bool {
	slice := fpaiv.HTTPProbingConfigHTTPAuth_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type HTTPProbingConfigHTTPAuth_FieldSubPathArrayItemValue struct {
	HTTPProbingConfigHTTPAuth_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *HTTPProbingConfigHTTPAuth_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *HTTPProbingConfigHTTPAuth_FieldSubPathArrayItemValue) AsTokenRequestPathItemValue() (HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'HTTPAuth'
func (fpaivs *HTTPProbingConfigHTTPAuth_FieldSubPathArrayItemValue) ContainsValue(source *HTTPProbingConfig_HTTPAuth) bool {
	switch fpaivs.Selector() {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		return fpaivs.subPathItemValue.(HTTPProbingConfigHTTPRequest_FieldPathArrayItemValue).ContainsValue(source.GetTokenRequest())
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPAuth: %d", fpaivs.Selector()))
	}
}

// HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues allows storing slice of values for HTTPAuth fields according to their type
type HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	HTTPProbingConfigHTTPAuth_FieldPath
}

func ParseHTTPProbingConfigHTTPAuth_FieldPathArrayOfValues(pathStr, valuesStr string) (HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues, error) {
	fp, err := ParseHTTPProbingConfigHTTPAuth_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HTTPAuth field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues), nil
}

func MustParseHTTPProbingConfigHTTPAuth_FieldPathArrayOfValues(pathStr, valuesStr string) HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues {
	fpaov, err := ParseHTTPProbingConfigHTTPAuth_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues struct {
	HTTPProbingConfigHTTPAuth_FieldTerminalPath
	values interface{}
}

var _ HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues = (*HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorUsername:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorPassword:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenRequest:
		for _, v := range fpaov.values.([]*HTTPProbingConfig_HTTPRequest) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseHeader:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorRequestHeaderTokenKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HTTPProbingConfigHTTPAuth_FieldPathSelectorTokenResponseBodyExpiryKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsUsernameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsPasswordArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsTokenRequestArrayOfValues() ([]*HTTPProbingConfig_HTTPRequest, bool) {
	res, ok := fpaov.values.([]*HTTPProbingConfig_HTTPRequest)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsTokenResponseHeaderArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsTokenResponseBodyKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsRequestHeaderTokenKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HTTPProbingConfigHTTPAuth_FieldTerminalPathArrayOfValues) AsTokenResponseBodyExpiryKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

type HTTPProbingConfigHTTPAuth_FieldSubPathArrayOfValues struct {
	HTTPProbingConfigHTTPAuth_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ HTTPProbingConfigHTTPAuth_FieldPathArrayOfValues = (*HTTPProbingConfigHTTPAuth_FieldSubPathArrayOfValues)(nil)

func (fpsaov *HTTPProbingConfigHTTPAuth_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *HTTPProbingConfigHTTPAuth_FieldSubPathArrayOfValues) AsTokenRequestPathArrayOfValues() (HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(HTTPProbingConfigHTTPRequest_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type HTTPProbingConfigHTTPRequestStringArray_FieldPath interface {
	gotenobject.FieldPath
	Selector() HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector
	Get(source *HTTPProbingConfig_HTTPRequest_StringArray) []interface{}
	GetSingle(source *HTTPProbingConfig_HTTPRequest_StringArray) (interface{}, bool)
	ClearValue(item *HTTPProbingConfig_HTTPRequest_StringArray)

	// Those methods build corresponding HTTPProbingConfigHTTPRequestStringArray_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathValue
	WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue
}

type HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector int32

const (
	HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector = 0
)

func (s HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector) String() string {
	switch s {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return "value"
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", s))
	}
}

func BuildHTTPProbingConfigHTTPRequestStringArray_FieldPath(fp gotenobject.RawFieldPath) (HTTPProbingConfigHTTPRequestStringArray_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object HTTPProbingConfig_HTTPRequest_StringArray")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "value":
			return &HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath{selector: HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object HTTPProbingConfig_HTTPRequest_StringArray", fp)
}

func ParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(rawField string) (HTTPProbingConfigHTTPRequestStringArray_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildHTTPProbingConfigHTTPRequestStringArray_FieldPath(fp)
}

func MustParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(rawField string) HTTPProbingConfigHTTPRequestStringArray_FieldPath {
	fp, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath struct {
	selector HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector
}

var _ HTTPProbingConfigHTTPRequestStringArray_FieldPath = (*HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath)(nil)

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) Selector() HTTPProbingConfigHTTPRequestStringArray_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source HTTPProbingConfig_HTTPRequest_StringArray
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) Get(source *HTTPProbingConfig_HTTPRequest_StringArray) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
			for _, value := range source.GetValue() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
		}
	}
	return
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*HTTPProbingConfig_HTTPRequest_StringArray))
}

// GetSingle returns value pointed by specific field of from source HTTPProbingConfig_HTTPRequest_StringArray
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) GetSingle(source *HTTPProbingConfig_HTTPRequest_StringArray) (interface{}, bool) {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		res := source.GetValue()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*HTTPProbingConfig_HTTPRequest_StringArray))
}

// GetDefault returns a default value of the field type
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) ClearValue(item *HTTPProbingConfig_HTTPRequest_StringArray) {
	if item != nil {
		switch fp.selector {
		case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
			item.Value = nil
		default:
			panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
		}
	}
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*HTTPProbingConfig_HTTPRequest_StringArray))
}

// IsLeaf - whether field path is holds simple value
func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithIValue(value interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathValue {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return &HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue{HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithIArrayOfValues(values interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues {
	fpaov := &HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath: *fp}
	switch fp.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return &HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues{HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
	}
	return fpaov
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithIArrayItemValue(value interface{}) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue {
	switch fp.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return &HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue{HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fp.selector))
	}
}

func (fp *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// HTTPProbingConfigHTTPRequestStringArray_FieldPathValue allows storing values for StringArray fields according to their type
type HTTPProbingConfigHTTPRequestStringArray_FieldPathValue interface {
	HTTPProbingConfigHTTPRequestStringArray_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **HTTPProbingConfig_HTTPRequest_StringArray)
	CompareWith(*HTTPProbingConfig_HTTPRequest_StringArray) (cmp int, comparable bool)
}

func ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathValue(pathStr, valueStr string) (HTTPProbingConfigHTTPRequestStringArray_FieldPathValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StringArray field path value from %s: %v", valueStr, err)
	}
	return fpv.(HTTPProbingConfigHTTPRequestStringArray_FieldPathValue), nil
}

func MustParseHTTPProbingConfigHTTPRequestStringArray_FieldPathValue(pathStr, valueStr string) HTTPProbingConfigHTTPRequestStringArray_FieldPathValue {
	fpv, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue struct {
	HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPRequestStringArray_FieldPathValue = (*HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'StringArray' as interface{}
func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) AsValueValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object StringArray
func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) SetTo(target **HTTPProbingConfig_HTTPRequest_StringArray) {
	if *target == nil {
		*target = new(HTTPProbingConfig_HTTPRequest_StringArray)
	}
	switch fpv.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		(*target).Value = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HTTPProbingConfig_HTTPRequest_StringArray)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue' with the value under path in 'HTTPProbingConfig_HTTPRequest_StringArray'.
func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) CompareWith(source *HTTPProbingConfig_HTTPRequest_StringArray) (int, bool) {
	switch fpv.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for HTTPProbingConfig_HTTPRequest_StringArray: %d", fpv.selector))
	}
}

func (fpv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*HTTPProbingConfig_HTTPRequest_StringArray))
}

// HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue allows storing single item in Path-specific values for StringArray according to their type
// Present only for array (repeated) types.
type HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	HTTPProbingConfigHTTPRequestStringArray_FieldPath
	ContainsValue(*HTTPProbingConfig_HTTPRequest_StringArray) bool
}

// ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue(pathStr, valueStr string) (HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StringArray field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue), nil
}

func MustParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue(pathStr, valueStr string) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue {
	fpaiv, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue struct {
	HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath
	value interface{}
}

var _ HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayItemValue = (*HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object HTTPProbingConfig_HTTPRequest_StringArray as interface{}
func (fpaiv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue) AsValueItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue) GetSingle(source *HTTPProbingConfig_HTTPRequest_StringArray) (interface{}, bool) {
	return nil, false
}

func (fpaiv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*HTTPProbingConfig_HTTPRequest_StringArray))
}

// Contains returns a boolean indicating if value that is being held is present in given 'StringArray'
func (fpaiv *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayItemValue) ContainsValue(source *HTTPProbingConfig_HTTPRequest_StringArray) bool {
	slice := fpaiv.HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues allows storing slice of values for StringArray fields according to their type
type HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	HTTPProbingConfigHTTPRequestStringArray_FieldPath
}

func ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues(pathStr, valuesStr string) (HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues, error) {
	fp, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StringArray field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues), nil
}

func MustParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues(pathStr, valuesStr string) HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues {
	fpaov, err := ParseHTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues struct {
	HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPath
	values interface{}
}

var _ HTTPProbingConfigHTTPRequestStringArray_FieldPathArrayOfValues = (*HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case HTTPProbingConfigHTTPRequestStringArray_FieldPathSelectorValue:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *HTTPProbingConfigHTTPRequestStringArray_FieldTerminalPathArrayOfValues) AsValueArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DNSQuery_FieldPath interface {
	gotenobject.FieldPath
	Selector() DNSQuery_FieldPathSelector
	Get(source *DNSQuery) []interface{}
	GetSingle(source *DNSQuery) (interface{}, bool)
	ClearValue(item *DNSQuery)

	// Those methods build corresponding DNSQuery_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DNSQuery_FieldPathValue
	WithIArrayOfValues(values interface{}) DNSQuery_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DNSQuery_FieldPathArrayItemValue
}

type DNSQuery_FieldPathSelector int32

const (
	DNSQuery_FieldPathSelectorName   DNSQuery_FieldPathSelector = 0
	DNSQuery_FieldPathSelectorQtype  DNSQuery_FieldPathSelector = 1
	DNSQuery_FieldPathSelectorQclass DNSQuery_FieldPathSelector = 2
)

func (s DNSQuery_FieldPathSelector) String() string {
	switch s {
	case DNSQuery_FieldPathSelectorName:
		return "name"
	case DNSQuery_FieldPathSelectorQtype:
		return "qtype"
	case DNSQuery_FieldPathSelectorQclass:
		return "qclass"
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", s))
	}
}

func BuildDNSQuery_FieldPath(fp gotenobject.RawFieldPath) (DNSQuery_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object DNSQuery")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &DNSQuery_FieldTerminalPath{selector: DNSQuery_FieldPathSelectorName}, nil
		case "qtype":
			return &DNSQuery_FieldTerminalPath{selector: DNSQuery_FieldPathSelectorQtype}, nil
		case "qclass":
			return &DNSQuery_FieldTerminalPath{selector: DNSQuery_FieldPathSelectorQclass}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object DNSQuery", fp)
}

func ParseDNSQuery_FieldPath(rawField string) (DNSQuery_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDNSQuery_FieldPath(fp)
}

func MustParseDNSQuery_FieldPath(rawField string) DNSQuery_FieldPath {
	fp, err := ParseDNSQuery_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DNSQuery_FieldTerminalPath struct {
	selector DNSQuery_FieldPathSelector
}

var _ DNSQuery_FieldPath = (*DNSQuery_FieldTerminalPath)(nil)

func (fp *DNSQuery_FieldTerminalPath) Selector() DNSQuery_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DNSQuery_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DNSQuery_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source DNSQuery
func (fp *DNSQuery_FieldTerminalPath) Get(source *DNSQuery) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DNSQuery_FieldPathSelectorName:
			values = append(values, source.Name)
		case DNSQuery_FieldPathSelectorQtype:
			values = append(values, source.Qtype)
		case DNSQuery_FieldPathSelectorQclass:
			values = append(values, source.Qclass)
		default:
			panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
		}
	}
	return
}

func (fp *DNSQuery_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*DNSQuery))
}

// GetSingle returns value pointed by specific field of from source DNSQuery
func (fp *DNSQuery_FieldTerminalPath) GetSingle(source *DNSQuery) (interface{}, bool) {
	switch fp.selector {
	case DNSQuery_FieldPathSelectorName:
		return source.GetName(), source != nil
	case DNSQuery_FieldPathSelectorQtype:
		return source.GetQtype(), source != nil
	case DNSQuery_FieldPathSelectorQclass:
		return source.GetQclass(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
	}
}

func (fp *DNSQuery_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*DNSQuery))
}

// GetDefault returns a default value of the field type
func (fp *DNSQuery_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DNSQuery_FieldPathSelectorName:
		return ""
	case DNSQuery_FieldPathSelectorQtype:
		return DNSResourceRecordType_DNS_RESOURCE_RECORD_TYPE_UNSPECIFIED
	case DNSQuery_FieldPathSelectorQclass:
		return DNSClass_DNS_CLASS_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
	}
}

func (fp *DNSQuery_FieldTerminalPath) ClearValue(item *DNSQuery) {
	if item != nil {
		switch fp.selector {
		case DNSQuery_FieldPathSelectorName:
			item.Name = ""
		case DNSQuery_FieldPathSelectorQtype:
			item.Qtype = DNSResourceRecordType_DNS_RESOURCE_RECORD_TYPE_UNSPECIFIED
		case DNSQuery_FieldPathSelectorQclass:
			item.Qclass = DNSClass_DNS_CLASS_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
		}
	}
}

func (fp *DNSQuery_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*DNSQuery))
}

// IsLeaf - whether field path is holds simple value
func (fp *DNSQuery_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DNSQuery_FieldPathSelectorName ||
		fp.selector == DNSQuery_FieldPathSelectorQtype ||
		fp.selector == DNSQuery_FieldPathSelectorQclass
}

func (fp *DNSQuery_FieldTerminalPath) WithIValue(value interface{}) DNSQuery_FieldPathValue {
	switch fp.selector {
	case DNSQuery_FieldPathSelectorName:
		return &DNSQuery_FieldTerminalPathValue{DNSQuery_FieldTerminalPath: *fp, value: value.(string)}
	case DNSQuery_FieldPathSelectorQtype:
		return &DNSQuery_FieldTerminalPathValue{DNSQuery_FieldTerminalPath: *fp, value: value.(DNSResourceRecordType)}
	case DNSQuery_FieldPathSelectorQclass:
		return &DNSQuery_FieldTerminalPathValue{DNSQuery_FieldTerminalPath: *fp, value: value.(DNSClass)}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
	}
}

func (fp *DNSQuery_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DNSQuery_FieldTerminalPath) WithIArrayOfValues(values interface{}) DNSQuery_FieldPathArrayOfValues {
	fpaov := &DNSQuery_FieldTerminalPathArrayOfValues{DNSQuery_FieldTerminalPath: *fp}
	switch fp.selector {
	case DNSQuery_FieldPathSelectorName:
		return &DNSQuery_FieldTerminalPathArrayOfValues{DNSQuery_FieldTerminalPath: *fp, values: values.([]string)}
	case DNSQuery_FieldPathSelectorQtype:
		return &DNSQuery_FieldTerminalPathArrayOfValues{DNSQuery_FieldTerminalPath: *fp, values: values.([]DNSResourceRecordType)}
	case DNSQuery_FieldPathSelectorQclass:
		return &DNSQuery_FieldTerminalPathArrayOfValues{DNSQuery_FieldTerminalPath: *fp, values: values.([]DNSClass)}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
	}
	return fpaov
}

func (fp *DNSQuery_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DNSQuery_FieldTerminalPath) WithIArrayItemValue(value interface{}) DNSQuery_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fp.selector))
	}
}

func (fp *DNSQuery_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DNSQuery_FieldPathValue allows storing values for DNSQuery fields according to their type
type DNSQuery_FieldPathValue interface {
	DNSQuery_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **DNSQuery)
	CompareWith(*DNSQuery) (cmp int, comparable bool)
}

func ParseDNSQuery_FieldPathValue(pathStr, valueStr string) (DNSQuery_FieldPathValue, error) {
	fp, err := ParseDNSQuery_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSQuery field path value from %s: %v", valueStr, err)
	}
	return fpv.(DNSQuery_FieldPathValue), nil
}

func MustParseDNSQuery_FieldPathValue(pathStr, valueStr string) DNSQuery_FieldPathValue {
	fpv, err := ParseDNSQuery_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DNSQuery_FieldTerminalPathValue struct {
	DNSQuery_FieldTerminalPath
	value interface{}
}

var _ DNSQuery_FieldPathValue = (*DNSQuery_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'DNSQuery' as interface{}
func (fpv *DNSQuery_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DNSQuery_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *DNSQuery_FieldTerminalPathValue) AsQtypeValue() (DNSResourceRecordType, bool) {
	res, ok := fpv.value.(DNSResourceRecordType)
	return res, ok
}
func (fpv *DNSQuery_FieldTerminalPathValue) AsQclassValue() (DNSClass, bool) {
	res, ok := fpv.value.(DNSClass)
	return res, ok
}

// SetTo stores value for selected field for object DNSQuery
func (fpv *DNSQuery_FieldTerminalPathValue) SetTo(target **DNSQuery) {
	if *target == nil {
		*target = new(DNSQuery)
	}
	switch fpv.selector {
	case DNSQuery_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case DNSQuery_FieldPathSelectorQtype:
		(*target).Qtype = fpv.value.(DNSResourceRecordType)
	case DNSQuery_FieldPathSelectorQclass:
		(*target).Qclass = fpv.value.(DNSClass)
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fpv.selector))
	}
}

func (fpv *DNSQuery_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*DNSQuery)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DNSQuery_FieldTerminalPathValue' with the value under path in 'DNSQuery'.
func (fpv *DNSQuery_FieldTerminalPathValue) CompareWith(source *DNSQuery) (int, bool) {
	switch fpv.selector {
	case DNSQuery_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSQuery_FieldPathSelectorQtype:
		leftValue := fpv.value.(DNSResourceRecordType)
		rightValue := source.GetQtype()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSQuery_FieldPathSelectorQclass:
		leftValue := fpv.value.(DNSClass)
		rightValue := source.GetQclass()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSQuery: %d", fpv.selector))
	}
}

func (fpv *DNSQuery_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*DNSQuery))
}

// DNSQuery_FieldPathArrayItemValue allows storing single item in Path-specific values for DNSQuery according to their type
// Present only for array (repeated) types.
type DNSQuery_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DNSQuery_FieldPath
	ContainsValue(*DNSQuery) bool
}

// ParseDNSQuery_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDNSQuery_FieldPathArrayItemValue(pathStr, valueStr string) (DNSQuery_FieldPathArrayItemValue, error) {
	fp, err := ParseDNSQuery_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSQuery field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DNSQuery_FieldPathArrayItemValue), nil
}

func MustParseDNSQuery_FieldPathArrayItemValue(pathStr, valueStr string) DNSQuery_FieldPathArrayItemValue {
	fpaiv, err := ParseDNSQuery_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DNSQuery_FieldTerminalPathArrayItemValue struct {
	DNSQuery_FieldTerminalPath
	value interface{}
}

var _ DNSQuery_FieldPathArrayItemValue = (*DNSQuery_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object DNSQuery as interface{}
func (fpaiv *DNSQuery_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DNSQuery_FieldTerminalPathArrayItemValue) GetSingle(source *DNSQuery) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DNSQuery_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*DNSQuery))
}

// Contains returns a boolean indicating if value that is being held is present in given 'DNSQuery'
func (fpaiv *DNSQuery_FieldTerminalPathArrayItemValue) ContainsValue(source *DNSQuery) bool {
	slice := fpaiv.DNSQuery_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DNSQuery_FieldPathArrayOfValues allows storing slice of values for DNSQuery fields according to their type
type DNSQuery_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DNSQuery_FieldPath
}

func ParseDNSQuery_FieldPathArrayOfValues(pathStr, valuesStr string) (DNSQuery_FieldPathArrayOfValues, error) {
	fp, err := ParseDNSQuery_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSQuery field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DNSQuery_FieldPathArrayOfValues), nil
}

func MustParseDNSQuery_FieldPathArrayOfValues(pathStr, valuesStr string) DNSQuery_FieldPathArrayOfValues {
	fpaov, err := ParseDNSQuery_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DNSQuery_FieldTerminalPathArrayOfValues struct {
	DNSQuery_FieldTerminalPath
	values interface{}
}

var _ DNSQuery_FieldPathArrayOfValues = (*DNSQuery_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DNSQuery_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DNSQuery_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case DNSQuery_FieldPathSelectorQtype:
		for _, v := range fpaov.values.([]DNSResourceRecordType) {
			values = append(values, v)
		}
	case DNSQuery_FieldPathSelectorQclass:
		for _, v := range fpaov.values.([]DNSClass) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DNSQuery_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *DNSQuery_FieldTerminalPathArrayOfValues) AsQtypeArrayOfValues() ([]DNSResourceRecordType, bool) {
	res, ok := fpaov.values.([]DNSResourceRecordType)
	return res, ok
}
func (fpaov *DNSQuery_FieldTerminalPathArrayOfValues) AsQclassArrayOfValues() ([]DNSClass, bool) {
	res, ok := fpaov.values.([]DNSClass)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DNSResourceRecord_FieldPath interface {
	gotenobject.FieldPath
	Selector() DNSResourceRecord_FieldPathSelector
	Get(source *DNSResourceRecord) []interface{}
	GetSingle(source *DNSResourceRecord) (interface{}, bool)
	ClearValue(item *DNSResourceRecord)

	// Those methods build corresponding DNSResourceRecord_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DNSResourceRecord_FieldPathValue
	WithIArrayOfValues(values interface{}) DNSResourceRecord_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DNSResourceRecord_FieldPathArrayItemValue
}

type DNSResourceRecord_FieldPathSelector int32

const (
	DNSResourceRecord_FieldPathSelectorName     DNSResourceRecord_FieldPathSelector = 0
	DNSResourceRecord_FieldPathSelectorRrtype   DNSResourceRecord_FieldPathSelector = 1
	DNSResourceRecord_FieldPathSelectorClass    DNSResourceRecord_FieldPathSelector = 2
	DNSResourceRecord_FieldPathSelectorTtl      DNSResourceRecord_FieldPathSelector = 3
	DNSResourceRecord_FieldPathSelectorRdlength DNSResourceRecord_FieldPathSelector = 4
	DNSResourceRecord_FieldPathSelectorRdata    DNSResourceRecord_FieldPathSelector = 5
)

func (s DNSResourceRecord_FieldPathSelector) String() string {
	switch s {
	case DNSResourceRecord_FieldPathSelectorName:
		return "name"
	case DNSResourceRecord_FieldPathSelectorRrtype:
		return "rrtype"
	case DNSResourceRecord_FieldPathSelectorClass:
		return "class"
	case DNSResourceRecord_FieldPathSelectorTtl:
		return "ttl"
	case DNSResourceRecord_FieldPathSelectorRdlength:
		return "rdlength"
	case DNSResourceRecord_FieldPathSelectorRdata:
		return "rdata"
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", s))
	}
}

func BuildDNSResourceRecord_FieldPath(fp gotenobject.RawFieldPath) (DNSResourceRecord_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object DNSResourceRecord")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorName}, nil
		case "rrtype":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorRrtype}, nil
		case "class":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorClass}, nil
		case "ttl":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorTtl}, nil
		case "rdlength":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorRdlength}, nil
		case "rdata":
			return &DNSResourceRecord_FieldTerminalPath{selector: DNSResourceRecord_FieldPathSelectorRdata}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object DNSResourceRecord", fp)
}

func ParseDNSResourceRecord_FieldPath(rawField string) (DNSResourceRecord_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDNSResourceRecord_FieldPath(fp)
}

func MustParseDNSResourceRecord_FieldPath(rawField string) DNSResourceRecord_FieldPath {
	fp, err := ParseDNSResourceRecord_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DNSResourceRecord_FieldTerminalPath struct {
	selector DNSResourceRecord_FieldPathSelector
}

var _ DNSResourceRecord_FieldPath = (*DNSResourceRecord_FieldTerminalPath)(nil)

func (fp *DNSResourceRecord_FieldTerminalPath) Selector() DNSResourceRecord_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DNSResourceRecord_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DNSResourceRecord_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source DNSResourceRecord
func (fp *DNSResourceRecord_FieldTerminalPath) Get(source *DNSResourceRecord) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DNSResourceRecord_FieldPathSelectorName:
			values = append(values, source.Name)
		case DNSResourceRecord_FieldPathSelectorRrtype:
			values = append(values, source.Rrtype)
		case DNSResourceRecord_FieldPathSelectorClass:
			values = append(values, source.Class)
		case DNSResourceRecord_FieldPathSelectorTtl:
			values = append(values, source.Ttl)
		case DNSResourceRecord_FieldPathSelectorRdlength:
			values = append(values, source.Rdlength)
		case DNSResourceRecord_FieldPathSelectorRdata:
			for _, value := range source.GetRdata() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
		}
	}
	return
}

func (fp *DNSResourceRecord_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*DNSResourceRecord))
}

// GetSingle returns value pointed by specific field of from source DNSResourceRecord
func (fp *DNSResourceRecord_FieldTerminalPath) GetSingle(source *DNSResourceRecord) (interface{}, bool) {
	switch fp.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		return source.GetName(), source != nil
	case DNSResourceRecord_FieldPathSelectorRrtype:
		return source.GetRrtype(), source != nil
	case DNSResourceRecord_FieldPathSelectorClass:
		return source.GetClass(), source != nil
	case DNSResourceRecord_FieldPathSelectorTtl:
		return source.GetTtl(), source != nil
	case DNSResourceRecord_FieldPathSelectorRdlength:
		return source.GetRdlength(), source != nil
	case DNSResourceRecord_FieldPathSelectorRdata:
		res := source.GetRdata()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
	}
}

func (fp *DNSResourceRecord_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*DNSResourceRecord))
}

// GetDefault returns a default value of the field type
func (fp *DNSResourceRecord_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		return ""
	case DNSResourceRecord_FieldPathSelectorRrtype:
		return DNSResourceRecordType_DNS_RESOURCE_RECORD_TYPE_UNSPECIFIED
	case DNSResourceRecord_FieldPathSelectorClass:
		return DNSClass_DNS_CLASS_UNSPECIFIED
	case DNSResourceRecord_FieldPathSelectorTtl:
		return uint32(0)
	case DNSResourceRecord_FieldPathSelectorRdlength:
		return uint32(0)
	case DNSResourceRecord_FieldPathSelectorRdata:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
	}
}

func (fp *DNSResourceRecord_FieldTerminalPath) ClearValue(item *DNSResourceRecord) {
	if item != nil {
		switch fp.selector {
		case DNSResourceRecord_FieldPathSelectorName:
			item.Name = ""
		case DNSResourceRecord_FieldPathSelectorRrtype:
			item.Rrtype = DNSResourceRecordType_DNS_RESOURCE_RECORD_TYPE_UNSPECIFIED
		case DNSResourceRecord_FieldPathSelectorClass:
			item.Class = DNSClass_DNS_CLASS_UNSPECIFIED
		case DNSResourceRecord_FieldPathSelectorTtl:
			item.Ttl = uint32(0)
		case DNSResourceRecord_FieldPathSelectorRdlength:
			item.Rdlength = uint32(0)
		case DNSResourceRecord_FieldPathSelectorRdata:
			item.Rdata = nil
		default:
			panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
		}
	}
}

func (fp *DNSResourceRecord_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*DNSResourceRecord))
}

// IsLeaf - whether field path is holds simple value
func (fp *DNSResourceRecord_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DNSResourceRecord_FieldPathSelectorName ||
		fp.selector == DNSResourceRecord_FieldPathSelectorRrtype ||
		fp.selector == DNSResourceRecord_FieldPathSelectorClass ||
		fp.selector == DNSResourceRecord_FieldPathSelectorTtl ||
		fp.selector == DNSResourceRecord_FieldPathSelectorRdlength ||
		fp.selector == DNSResourceRecord_FieldPathSelectorRdata
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithIValue(value interface{}) DNSResourceRecord_FieldPathValue {
	switch fp.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(string)}
	case DNSResourceRecord_FieldPathSelectorRrtype:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(DNSResourceRecordType)}
	case DNSResourceRecord_FieldPathSelectorClass:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(DNSClass)}
	case DNSResourceRecord_FieldPathSelectorTtl:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(uint32)}
	case DNSResourceRecord_FieldPathSelectorRdlength:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(uint32)}
	case DNSResourceRecord_FieldPathSelectorRdata:
		return &DNSResourceRecord_FieldTerminalPathValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
	}
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithIArrayOfValues(values interface{}) DNSResourceRecord_FieldPathArrayOfValues {
	fpaov := &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp}
	switch fp.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([]string)}
	case DNSResourceRecord_FieldPathSelectorRrtype:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([]DNSResourceRecordType)}
	case DNSResourceRecord_FieldPathSelectorClass:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([]DNSClass)}
	case DNSResourceRecord_FieldPathSelectorTtl:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([]uint32)}
	case DNSResourceRecord_FieldPathSelectorRdlength:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([]uint32)}
	case DNSResourceRecord_FieldPathSelectorRdata:
		return &DNSResourceRecord_FieldTerminalPathArrayOfValues{DNSResourceRecord_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
	}
	return fpaov
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithIArrayItemValue(value interface{}) DNSResourceRecord_FieldPathArrayItemValue {
	switch fp.selector {
	case DNSResourceRecord_FieldPathSelectorRdata:
		return &DNSResourceRecord_FieldTerminalPathArrayItemValue{DNSResourceRecord_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fp.selector))
	}
}

func (fp *DNSResourceRecord_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DNSResourceRecord_FieldPathValue allows storing values for DNSResourceRecord fields according to their type
type DNSResourceRecord_FieldPathValue interface {
	DNSResourceRecord_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **DNSResourceRecord)
	CompareWith(*DNSResourceRecord) (cmp int, comparable bool)
}

func ParseDNSResourceRecord_FieldPathValue(pathStr, valueStr string) (DNSResourceRecord_FieldPathValue, error) {
	fp, err := ParseDNSResourceRecord_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSResourceRecord field path value from %s: %v", valueStr, err)
	}
	return fpv.(DNSResourceRecord_FieldPathValue), nil
}

func MustParseDNSResourceRecord_FieldPathValue(pathStr, valueStr string) DNSResourceRecord_FieldPathValue {
	fpv, err := ParseDNSResourceRecord_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DNSResourceRecord_FieldTerminalPathValue struct {
	DNSResourceRecord_FieldTerminalPath
	value interface{}
}

var _ DNSResourceRecord_FieldPathValue = (*DNSResourceRecord_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'DNSResourceRecord' as interface{}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsRrtypeValue() (DNSResourceRecordType, bool) {
	res, ok := fpv.value.(DNSResourceRecordType)
	return res, ok
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsClassValue() (DNSClass, bool) {
	res, ok := fpv.value.(DNSClass)
	return res, ok
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsTtlValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsRdlengthValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *DNSResourceRecord_FieldTerminalPathValue) AsRdataValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object DNSResourceRecord
func (fpv *DNSResourceRecord_FieldTerminalPathValue) SetTo(target **DNSResourceRecord) {
	if *target == nil {
		*target = new(DNSResourceRecord)
	}
	switch fpv.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case DNSResourceRecord_FieldPathSelectorRrtype:
		(*target).Rrtype = fpv.value.(DNSResourceRecordType)
	case DNSResourceRecord_FieldPathSelectorClass:
		(*target).Class = fpv.value.(DNSClass)
	case DNSResourceRecord_FieldPathSelectorTtl:
		(*target).Ttl = fpv.value.(uint32)
	case DNSResourceRecord_FieldPathSelectorRdlength:
		(*target).Rdlength = fpv.value.(uint32)
	case DNSResourceRecord_FieldPathSelectorRdata:
		(*target).Rdata = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fpv.selector))
	}
}

func (fpv *DNSResourceRecord_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*DNSResourceRecord)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DNSResourceRecord_FieldTerminalPathValue' with the value under path in 'DNSResourceRecord'.
func (fpv *DNSResourceRecord_FieldTerminalPathValue) CompareWith(source *DNSResourceRecord) (int, bool) {
	switch fpv.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSResourceRecord_FieldPathSelectorRrtype:
		leftValue := fpv.value.(DNSResourceRecordType)
		rightValue := source.GetRrtype()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSResourceRecord_FieldPathSelectorClass:
		leftValue := fpv.value.(DNSClass)
		rightValue := source.GetClass()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSResourceRecord_FieldPathSelectorTtl:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetTtl()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSResourceRecord_FieldPathSelectorRdlength:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetRdlength()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DNSResourceRecord_FieldPathSelectorRdata:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for DNSResourceRecord: %d", fpv.selector))
	}
}

func (fpv *DNSResourceRecord_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*DNSResourceRecord))
}

// DNSResourceRecord_FieldPathArrayItemValue allows storing single item in Path-specific values for DNSResourceRecord according to their type
// Present only for array (repeated) types.
type DNSResourceRecord_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DNSResourceRecord_FieldPath
	ContainsValue(*DNSResourceRecord) bool
}

// ParseDNSResourceRecord_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDNSResourceRecord_FieldPathArrayItemValue(pathStr, valueStr string) (DNSResourceRecord_FieldPathArrayItemValue, error) {
	fp, err := ParseDNSResourceRecord_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSResourceRecord field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DNSResourceRecord_FieldPathArrayItemValue), nil
}

func MustParseDNSResourceRecord_FieldPathArrayItemValue(pathStr, valueStr string) DNSResourceRecord_FieldPathArrayItemValue {
	fpaiv, err := ParseDNSResourceRecord_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DNSResourceRecord_FieldTerminalPathArrayItemValue struct {
	DNSResourceRecord_FieldTerminalPath
	value interface{}
}

var _ DNSResourceRecord_FieldPathArrayItemValue = (*DNSResourceRecord_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object DNSResourceRecord as interface{}
func (fpaiv *DNSResourceRecord_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *DNSResourceRecord_FieldTerminalPathArrayItemValue) AsRdataItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *DNSResourceRecord_FieldTerminalPathArrayItemValue) GetSingle(source *DNSResourceRecord) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DNSResourceRecord_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*DNSResourceRecord))
}

// Contains returns a boolean indicating if value that is being held is present in given 'DNSResourceRecord'
func (fpaiv *DNSResourceRecord_FieldTerminalPathArrayItemValue) ContainsValue(source *DNSResourceRecord) bool {
	slice := fpaiv.DNSResourceRecord_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DNSResourceRecord_FieldPathArrayOfValues allows storing slice of values for DNSResourceRecord fields according to their type
type DNSResourceRecord_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DNSResourceRecord_FieldPath
}

func ParseDNSResourceRecord_FieldPathArrayOfValues(pathStr, valuesStr string) (DNSResourceRecord_FieldPathArrayOfValues, error) {
	fp, err := ParseDNSResourceRecord_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DNSResourceRecord field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DNSResourceRecord_FieldPathArrayOfValues), nil
}

func MustParseDNSResourceRecord_FieldPathArrayOfValues(pathStr, valuesStr string) DNSResourceRecord_FieldPathArrayOfValues {
	fpaov, err := ParseDNSResourceRecord_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DNSResourceRecord_FieldTerminalPathArrayOfValues struct {
	DNSResourceRecord_FieldTerminalPath
	values interface{}
}

var _ DNSResourceRecord_FieldPathArrayOfValues = (*DNSResourceRecord_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DNSResourceRecord_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case DNSResourceRecord_FieldPathSelectorRrtype:
		for _, v := range fpaov.values.([]DNSResourceRecordType) {
			values = append(values, v)
		}
	case DNSResourceRecord_FieldPathSelectorClass:
		for _, v := range fpaov.values.([]DNSClass) {
			values = append(values, v)
		}
	case DNSResourceRecord_FieldPathSelectorTtl:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case DNSResourceRecord_FieldPathSelectorRdlength:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case DNSResourceRecord_FieldPathSelectorRdata:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsRrtypeArrayOfValues() ([]DNSResourceRecordType, bool) {
	res, ok := fpaov.values.([]DNSResourceRecordType)
	return res, ok
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsClassArrayOfValues() ([]DNSClass, bool) {
	res, ok := fpaov.values.([]DNSClass)
	return res, ok
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsTtlArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsRdlengthArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *DNSResourceRecord_FieldTerminalPathArrayOfValues) AsRdataArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
